<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>プラレールレイアウトシミュレータ v48.1</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
        }
        
        /* 横長画面（landscape）でサイドバー表示 */
        @media (orientation: landscape) and (min-width: 1024px) and (min-height: 600px) {
            body {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            #canvas-container {
                flex: 1 1 calc(100% - 320px);
                max-height: calc(100vh - 60px);
                max-height: calc(100dvh - 60px);
                border-bottom: none;
                border-right: 2px solid #333;
            }
            
            .controls {
                width: 320px;
                height: calc(100vh - 60px) !important;
                height: calc(100dvh - 60px) !important;
                max-height: none !important;
                min-height: auto !important;
                overflow-y: auto;
                flex-shrink: 0;
                padding: 15px;
            }
            
            .color-legend {
                position: fixed;
                bottom: 0;
                left: 0;
                width: calc(100% - 320px);
                margin: 0;
                border-radius: 0;
                border-top: 2px solid #333;
                z-index: 100;
            }
            
            /* ボタンを大きく、使いやすく */
            button {
                padding: 14px 10px;
                font-size: 15px;
                min-width: 90px;
            }
            
            .button-group {
                gap: 8px;
                margin-bottom: 12px;
            }
            
            .slot-btn {
                padding: 10px 5px !important;
                font-size: 13px !important;
            }
            
            .section-title {
                margin-top: 15px;
                margin-bottom: 8px;
            }
        }
        
        /* さらに広い画面ではサイドバーを広く */
        @media (orientation: landscape) and (min-width: 1600px) {
            .controls {
                width: 380px;
            }
            
            #canvas-container {
                flex: 1 1 calc(100% - 380px);
            }
            
            .color-legend {
                width: calc(100% - 380px);
            }
            
            button {
                padding: 16px 12px;
                font-size: 16px;
            }
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 400px;
            max-height: calc(100vh - 150px);
            max-height: calc(100dvh - 150px);
            border-bottom: 2px solid #333;
            background: #f0f0f0;
            touch-action: none;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            display: block;
            touch-action: none;
            /* コンテナに収まる最大サイズで、キャンバス実寸比を維持 */
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }
        
        .controls {
            flex-shrink: 0;
            height: 150px;
            min-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            background: #fafafa;
        }
        
        @media (min-height: 800px) {
            .controls {
                height: 200px;
                min-height: 200px;
            }
            #canvas-container {
                max-height: calc(100vh - 200px);
                max-height: calc(100dvh - 200px);
            }
        }
        
        @media (min-height: 1000px) {
            #canvas-container {
                max-height: calc(100vh - 180px);
                max-height: calc(100dvh - 180px);
            }
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #666;
            background: #fff;
            border-radius: 5px;
            cursor: pointer;
            flex: 1;
            min-width: 80px;
            touch-action: manipulation;
        }
        
        button:active {
            background: #ddd;
        }
        
        .rail-buttons button {
            min-width: 100px;
        }
        
        .slot-btn {
            font-size: 12px !important;
            padding: 8px 5px !important;
            min-width: 0 !important;
        }
        
        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 1px solid #666;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        textarea {
            min-height: 80px;
            font-family: monospace;
        }
        
        .context-menu {
            position: fixed;
            background-color: white;
            border: 2px solid black;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .context-menu div {
            padding: 15px 20px;
            cursor: pointer;
            font-size: 16px;
            border-bottom: 1px solid #ddd;
        }
        
        .context-menu div:last-child {
            border-bottom: none;
        }
        
        .context-menu div:active {
            background-color: #ddd;
        }
        
        .section-title {
            font-weight: bold;
            margin: 10px 0 5px 0;
            color: #333;
        }
        
        .color-legend {
            display: flex;
            flex-wrap: nowrap;  /* 折り返しなし */
            gap: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            margin-bottom: 10px;
            
            /* 横スクロール有効化 */
            overflow-x: auto;
            overflow-y: hidden;
            
            /* スムーズスクロール */
            scroll-behavior: smooth;
            
            /* スクロールバーのスタイリング（Webkit系ブラウザ） */
            scrollbar-width: thin;
            scrollbar-color: #888 #f1f1f1;
        }
        
        .color-legend::-webkit-scrollbar {
            height: 6px;
        }
        
        .color-legend::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .color-legend::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        
        .color-legend::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            white-space: nowrap;  /* テキスト折り返しなし */
            flex-shrink: 0;  /* アイテムが縮まないようにする */
            
            /* タップ可能にする */
            cursor: pointer;
            padding: 5px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .color-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .color-item:active {
            background-color: rgba(0, 0, 0, 0.1);
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
            flex-shrink: 0;  /* サイズ固定 */
        }
        
        @media (max-width: 600px) {
            button {
                font-size: 12px;
                padding: 10px 12px;
            }
            
            .color-legend {
                font-size: 11px;
                gap: 12px;
            }
            
            .color-item {
                padding: 4px 6px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas" width="2400" height="1350"></canvas>
    </div>

    <div class="color-legend">
        <div class="color-item">
            <div class="color-box" style="background: deepskyblue;"></div>
            <span>直線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: pink;"></div>
            <span>カーブ</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: violet;"></div>
            <span>倍曲線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: red;"></div>
            <span>Uターン</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: purple;"></div>
            <span>外カーブ</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: cyan;"></div>
            <span>複線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: lightcyan;"></div>
            <span>複曲線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: turquoise;"></div>
            <span>複線渡り</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: lightseagreen;"></div>
            <span>複線T.O.</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: coral;"></div>
            <span>十字</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: lawngreen;"></div>
            <span>ターンアウト</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: orange;"></div>
            <span>R-13</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: yellowgreen;"></div>
            <span>R-22 Y字</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: mediumseagreen;"></div>
            <span>R-15幅広 / R-30三角</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: plum;"></div>
            <span>8の字</span>
        </div>
    </div>

    <div class="controls">
        <!-- レール数カウンター -->
        <div id="railCounterContainer" style="display: none; margin-bottom: 10px; padding: 10px; background: #f0f0f0; border-radius: 5px; max-height: 150px; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <strong>使用レール数</strong>
                <button id="closeCounter" style="padding: 2px 8px; font-size: 12px;">閉じる</button>
            </div>
            <div id="railCounterContent" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px; font-size: 12px;">
                <!-- カウント内容がここに表示される -->
            </div>
        </div>
        
        <!-- 上部ボタン群 -->
        <div class="button-group" style="margin-bottom: 10px;">
            <button id="toggleCounter">レール数表示</button>
            <button id="toggleDetailMode">表示モード: 詳細</button>
        </div>
        
        <div class="button-group" style="margin-bottom: 10px;">
            <button id="groupMoveToggle" style="flex: 2;">接続まとめて移動: OFF</button>
            <button id="allclear" style="background: #ffcccc;">全クリア</button>
            <button id="canvasreset">表示リセット</button>
        </div>
        
        <div class="section-title">基本レール</div>
        <div class="button-group rail-buttons">
            <button id="addStraight">直線</button>
            <button id="addRightCurve">右カーブ</button>
            <button id="addLeftCurve">左カーブ</button>
        </div>
        
        <div class="button-group">
            <button id="addHalfStraight">1/2直線</button>
            <button id="addDoubleStraight">2倍直線</button>
            <button id="addDoubleLengthCurveRight">倍曲線(右)</button>
            <button id="addDoubleLengthCurveLeft">倍曲線(左)</button>
        </div>
		<div class="button-group">		
			<button id="addQuarterV">1/4 (to凸)</button>  <!-- 終点が凸 -->
			<button id="addQuarterC">1/4 (to凹)</button>  <!-- 終点が凹 -->
		</div>
		<div class="button-group">
            <button id="addJoint">1/6</button>
        </div>
      

        <div class="section-title">ポイント</div>
        <div class="button-group">
            <button id="addTurnoutLeft">ターンアウト (R)</button>
            <button id="addTurnoutRight">(R裏)</button>
            <button id="addTurnoutLeftL">(L)</button>
            <button id="addTurnoutRightL">(L裏)</button>
        </div>

        
        <div class="button-group">
            <button id="addFigure8Point">8の字 R(左)</button>
            <button id="addFigure8PointRRev">R(右)</button>
            <button id="addFigure8PointL">L(左)</button>
            <button id="addFigure8PointLRev">L(右)</button>
        </div>
<div class="button-group">
            <button id="addCrossPoint">十字ポイント</button>  
            <button id="addCrossPointRev">十字(転）</button>  
            <button id="addR30TrianglePoint">R-30三角</button>
            <button id="addR30TrianglePointRev">(裏)</button>
        </div>

        

        <div class="section-title">複線・複曲線レール</div>
        <div class="button-group">
            <button id="addDoubleTrack">複線直線</button>
            <button id="addDoubleCurveLeft">複曲線(左)</button>
            <button id="addDoubleCurveRight">複曲線(右)</button>
        </div>
        <div class="button-group">
            <button id="addRightOuterCurve">右外側</button>
            <button id="addLeftOuterCurve">左外側</button>
        </div>


         <div class="button-group">
            <button id="addUTurnRailU">Uターン(U)</button>
            <button id="addUTurnRailV">Uターン(V)</button>
            <button id="addDoubleTrackCrossover">複線渡り(表)</button>
            <button id="addDoubleTrackCrossoverRev">複線渡り(裏)</button>
        </div>
         <div class="section-title">複線ターンアウト/R-15複線幅広/R-17三方向</div>
         <div class="button-group">
            <button id="addDoubleTrackTurnoutLeft">複T.O.(左)</button>
            <button id="addDoubleTrackTurnoutLeftRev">(左裏)</button>
            <button id="addDoubleTrackTurnoutRight">(右)</button>
            <button id="addDoubleTrackTurnoutRightRev">(右裏)</button>
             <button id="addR15WideA">R-15 (A)</button>
            <button id="addR15WideARev">(A裏)</button>
            <button id="addR15WideB">(B)</button>
            <button id="addR15WideBRev">(B裏)</button>
             <button id="addR17ThreewayPointALeft">R-17 (A左)</button>
            <button id="addR17ThreewayPointARight">R-17 (A右)</button>
            <button id="addR17ThreewayPointBLeft">R-17 (B左)</button>
            <button id="addR17ThreewayPointBRight">R-17 (B右)</button>

 </div>         

        


       <div class="section-title">単複P/R-22 Y字P</div>
        <div class="button-group">
            <button id="addR13PointBRight">単複 (B右)</button>
            <button id="addR13PointBLeft">（B左)</button>
            <button id="addR13PointARight">(A右)</button>
            <button id="addR13PointALeft">(A左)</button>
            <button id="addR22YPointA">Y字(A)</button>
            <button id="addR22YPointARev">(A裏)</button>
            <button id="addR22YPointB">(B)</button>
            <button id="addR22YPointBRev">(B裏)</button>
        </div>
        

        <div class="button-group">
        </div>
        
        <div class="section-title">S字レール</div>
        <div class="button-group">
            <button id="addSlide">S字</button>
            <button id="addRSlide">S字(R)</button>
        </div>

        <div class="section-title">一括追加 (S/R/L)</div>
        <div class="button-group">
            <input type="text" id="railInput" placeholder="例: SSRLLS">
            <button id="addRails">追加</button>
        </div>

         <div class="section-title">レイアウト保存/読込</div>
        
        <!-- ショートカット入力 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">ショートカット入力:</label>
            <textarea id="shortcutInput" placeholder="例: SRL または RRRRRRRR" style="height: 40px;"></textarea>
            <div class="button-group">
                <button id="executeShortcut">実行</button>
                <button id="clearShortcut">クリア</button>
            </div>
            <div style="font-size: 11px; color: #888; margin-top: 3px;">
                S=直線, R=右カーブ, L=左カーブ, J=ジョイント(自動), H=1/2直線
            </div>
        </div>
        
        <!-- テキスト保存 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">テキスト形式:</label>
            <textarea id="layoutData" placeholder="レイアウトデータ" style="height: 60px;"></textarea>
            <div class="button-group">
                <button id="saveLayout">テキスト生成</button>
                <button id="loadLayout">テキスト読込</button>
            </div>
        </div>
        
        <!-- LocalStorage保存 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">スロット保存:</label>
            <div class="button-group" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px;">
                <button id="saveSlot1" class="slot-btn" title="スロット1に保存">保存1</button>
                <button id="saveSlot2" class="slot-btn" title="スロット2に保存">保存2</button>
                <button id="saveSlot3" class="slot-btn" title="スロット3に保存">保存3</button>
                <button id="saveSlot4" class="slot-btn" title="スロット4に保存">保存4</button>
                <button id="saveSlot5" class="slot-btn" title="スロット5に保存">保存5</button>
            </div>
            <div class="button-group" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 5px;">
                <button id="loadSlot1" class="slot-btn" title="スロット1から読込">読込1</button>
                <button id="loadSlot2" class="slot-btn" title="スロット2から読込">読込2</button>
                <button id="loadSlot3" class="slot-btn" title="スロット3から読込">読込3</button>
                <button id="loadSlot4" class="slot-btn" title="スロット4から読込">読込4</button>
                <button id="loadSlot5" class="slot-btn" title="スロット5から読込">読込5</button>
            </div>
        </div>
        
        <!-- URL共有 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">URL共有:</label>
            <div class="button-group">
                <button id="copyURL">URLコピー</button>
                <button id="shareTwitter">X(Twitter)で共有</button>
            </div>
            <div id="urlStatus" style="font-size: 11px; color: #666; margin-top: 5px; min-height: 16px;"></div>
        </div>
    </div>

    <div id="contextMenu" class="context-menu">
        <div id="rotateRight">右回転 (45°)</div>
        <div id="rotateLeft">左回転 (45°)</div>
        <div id="toggleType">タイプ切替 (R/L, A/B)</div>
        <div id="toggleDirection">方向反転 (裏/表)</div>
        <div id="toggleEndpoints">端点切替</div>
        <div id="duplicate">複製</div>
        <div id="delete">削除</div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
	let canvH = canvas.height;
	let canvW = canvas.width;
	const rails =[];
        let dragging = null;
        let offsetX, offsetY;
        let selectedShape = null;
	let LastselectedShape = null;
	let selectedEndpoint = null; // 選択された端点（赤丸表示用）
	let railPlacementHistory = []; // 配置履歴トラッキング

let scale = 3.0;  // Canvas解像度を2400×1350（16:9）に拡大したため、初期スケールを3倍に調整
const scaleFactor = 1.1;

    let canvasOffsetX = canvW/2;
    let canvasOffsetY = canvH/2;
    let isPanning = false;
    let startX, startY;

        // ========================================
        // レスポンシブキャンバスサイズ調整
        // ========================================
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // キャンバスの内部解像度は固定
            // 表示サイズのみCSSで調整
            const aspectRatio = canvas.width / canvas.height; // 2400x1350 (16:9)
            
            let displayWidth = containerWidth;
            let displayHeight = displayWidth / aspectRatio;
            
            // コンテナの高さに収まらない場合は高さ基準
            if (displayHeight > containerHeight) {
                displayHeight = containerHeight;
                displayWidth = displayHeight * aspectRatio;
            }
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            drawAll();
        }
        
        // 初回とリサイズ時にキャンバスサイズを調整
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);


        const DIRECTION_LEFT = 'left';
        const DIRECTION_RIGHT = 'right';
        const RAIL_LENGTH = 80;
        const RAIL_WIDTH = 14;
        const D_TRACK_WIDTH = 22;

        // ジョイント描画設定
        const JOINT_WIDTH = 4;
        const JOINT_LENGTH = 4;
        let useDetailedEndpoints = true; // 詳細端点表示の切替（初期値: true = 詳細）

        // デバッグログ設定
        let isNeedJointConsole = false; // ジョイント/端点関連のコンソールログ（初期値: false = オフ）

        // ========================================
        // リアル描画モード設定
        // ========================================
        let useRealisticRendering = true; // リアル描画モード（初期値: true = 詳細）

        // ========================================
        // レール色定義（ベース色 + ハイライト色）
        // ========================================
        const COLORS = {
            STRAIGHT: { base: 'deepskyblue', highlight: 'lightskyblue' },
            HALF_STRAIGHT: { base: 'lightblue', highlight: 'lightcyan' },
            DOUBLE_STRAIGHT: { base: 'navy', highlight: 'royalblue' },
            CURVE: { base: 'pink', highlight: 'lightpink' },
            DOUBLE_CURVE: { base: 'violet', highlight: 'plum' },
            OUTER_CURVE: { base: 'purple', highlight: 'mediumorchid' },
            SLIDE: { base: 'pink', highlight: 'lightpink' },
            UTURN: { base: 'red', highlight: 'lightcoral' },
            TURNOUT: { base: 'lawngreen', highlight: 'lightgreen' },
            FIGURE8: { base: 'plum', highlight: 'violet' },
            R13: { base: 'orange', highlight: 'lightsalmon' },
            R22: { base: 'yellowgreen', highlight: 'lightgreen' },
            R15: { base: 'mediumseagreen', highlight: 'aquamarine' },
            R30: { base: 'mediumseagreen', highlight: 'aquamarine' },
            R17: { base: 'forestgreen', highlight: 'lightgreen' },  // R-17三方向ポイント（独自色）
            CROSS: { base: 'coral', highlight: 'lightsalmon' },
            DOUBLE_TRACK_STRAIGHT: { base: 'cyan', highlight: 'lightcyan' },
            DOUBLE_TRACK_CURVE: { base: 'lightcyan', highlight: 'azure' },
            DOUBLE_TRACK_CROSS: { base: 'turquoise', highlight: 'paleturquoise' },
            DOUBLE_TRACK_TURNOUT: { base: 'teal', highlight: 'lightseagreen' },  // 複線ターンアウト（独自色）
            QUARTER: { base: 'skyblue', highlight: 'lightskyblue' },
            SIXTH: { base: 'skyblue', highlight: 'lightskyblue' }
        };

        // ========================================
        // レール色の定義（参考用）
        // ========================================
        // 直線レール: 'deepskyblue' (水色)
        // カーブレール: 'pink' (ピンク)
        // S字レール: 'pink' (ピンク)
        // ターンアウト: 'lawngreen' (黄緑)
        // R-13ポイント: 'orange' (オレンジ)
        // 8の字ポイント: 'plum' (梅色)
        // Uターンレール: 'red' (赤)
        // R-17三方向ポイント: 'forestgreen' (深緑)
        // 複線ターンアウト: 'teal' (ティール)
        // ========================================

        // ========================================
        // 統一座標変換関数
        // ========================================
        
        /**
         * スクリーン座標（canvas上のピクセル座標）をワールド座標に変換
         * @param {number} screenX - canvas上のX座標 (e.offsetX)
         * @param {number} screenY - canvas上のY座標 (e.offsetY)
         * @returns {{x: number, y: number}} ワールド座標
         */
        /**
         * スクリーン座標（canvas上のピクセル座標）をワールド座標に変換
         * @param {number} screenX - canvas上のX座標 (e.offsetX)
         * @param {number} screenY - canvas上のY座標 (e.offsetY)
         * @returns {{x: number, y: number}} ワールド座標
         */
        function screenToWorld(screenX, screenY) {
            // キャンバスの表示サイズと内部解像度の比率を計算
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // 表示座標を内部座標に変換
            const canvasX = screenX * scaleX;
            const canvasY = screenY * scaleY;
            
            // スクリーン座標系: 左上が原点、Y軸下向き
            // ワールド座標系: 中央が原点、Y軸上向き
            const worldX = (canvasX - canvasOffsetX) / scale;
            const worldY = (canvH - canvasY - canvasOffsetY) / scale;
            return { x: worldX, y: worldY };
        }

        /**
         * ワールド座標をスクリーン座標に変換（将来の拡張用）
         * @param {number} worldX - ワールドX座標
         * @param {number} worldY - ワールドY座標
         * @returns {{x: number, y: number}} スクリーン座標
         */
        function worldToScreen(worldX, worldY) {
            const screenX = worldX * scale + canvasOffsetX;
            const screenY = canvH - (worldY * scale + canvasOffsetY);
            return { x: screenX, y: screenY };
        } 
		//(x,y)をangle(rad)回転させた座標
		function rotatePoint(x, y, angle){
			const SinA = Math.sin(angle);
			const CosA = Math.cos(angle);
			const x1 = x * CosA - y * SinA; 
			const y1 = x * SinA + y * CosA; 
		return { x: x1, y: y1 };
		}
// 角度を -π から π の範囲に正規化する関数
		function normalizeAngle(angle) {
			while (angle > Math.PI) angle -= 2 * Math.PI;
			while (angle < -Math.PI) angle += 2 * Math.PI;
		return angle;
		}

		function normalizedegAngle(deg) {
			let a = deg % 360;
			if (a > 180) a -= 360;
			if (a <= -180) a += 360;
		return a;
		}
		
		function reversedegAngle(deg) {
		return normalizedegAngle(deg + 180);
		}
		function rotatedegAngle(deg, delta) {
		return normalizedegAngle(deg + delta);
		}


        class StraightRail {
            constructor(x, y, id, length = RAIL_LENGTH, options = {}) {
                this.x = x;
                this.y = y;
                this.width = RAIL_WIDTH;
                this.length = length;  // height から length に変更
                this.id = id;
                this.angle = 0;
				this.color = COLORS.STRAIGHT.base;
				this.highlightColor = COLORS.STRAIGHT.highlight;
				this.endpointIdCounter = 0;
                
                // 端点タイプ（デフォルトは凹凸）
                this.startType = options.startType || 'concave';
                this.endType = options.endType || 'convex';
           }

            draw() {
                if (useRealisticRendering) {
                    // リアル描画（4層）
                    this.drawWithWidth(14, 'black');
                    this.drawWithWidth(12, this.color);
                    this.drawWithWidth(6, this.highlightColor);
                    this.drawWithWidth(4, this.color);
                } else {
                    // シンプル描画（1層）
                    this.drawWithWidth(this.width, this.color);
                }
            }
            
            drawWithWidth(width, color) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
                ctx.fillStyle = color;
                ctx.fillRect(-width / 2, 0, width, this.length);
				ctx.restore();
            }

            contains(mx, my) {
 

				const scaledX = (mx ) ;
				const scaledY = (my ) ;

				const angleRad = -this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const localX = cos * (scaledX - this.x) - sin * (scaledY - this.y) + this.x;
                const localY = sin * (scaledX - this.x) + cos * (scaledY - this.y) + this.y;
                return (localX >= this.x - this.width / 2 && localX <= this.x + this.width / 2 &&
                        localY >= this.y  && localY <= this.y + this.length);
            }

            getEndpoints() {
                const angleRad = this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const x1 = this.x;
                const y1 = this.y;
                const x2 = this.x - (this.length) * sin;
                const y2 = this.y + (this.length) * cos;
                
                // 端点の角度調整
                // 通常（起点:凹、終点:凸）: そのまま
                // 起点が凸の場合のみ: 起点の角度を180度反転
                // 終点が凹の場合のみ: 終点の角度を180度反転
                const angle1 = this.startType === 'convex' ? reversedegAngle(this.angle) : this.angle;
                const angle2 = this.endType === 'concave' ? reversedegAngle(this.angle) : this.angle;
                
                return [
            	   { x: x1, y: y1, angle: angle1, id: `${this.id}-1`, type: this.startType },
            	   { x: x2, y: y2, angle: angle2, id: `${this.id}-2`, type: this.endType }		];
            }
        }


        class Slide {
            constructor(x, y, id, slide, length = RAIL_LENGTH) {
                this.x = x;
                this.y = y;
                this.width = RAIL_WIDTH;
                this.length = length;
                this.id = id;
                this.angle = 0;
				this.color = COLORS.SLIDE.base;
				this.highlightColor = COLORS.SLIDE.highlight;
                this.slide = slide;
           }

            draw() {
                if (useRealisticRendering) {
                    // リアル描画（4層）
                    this.drawWithWidth(14, 'black');
                    this.drawWithWidth(12, this.color);
                    this.drawWithWidth(6, this.highlightColor);
                    this.drawWithWidth(4, this.color);
                } else {
                    // シンプル描画（1層）
                    this.drawWithWidth(this.width, this.color);
                }
            }
            
            drawWithWidth(width, color) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
				ctx.strokeStyle = color;
				ctx.lineWidth = width;
                ctx.lineCap = 'butt';

				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.bezierCurveTo(0, this.length * 0.5, this.slide, this.length * 0.5, this.slide, this.length);
				ctx.stroke();
				ctx.restore();
            }

            contains(mx, my) {
                const angleRad = -this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const localY = sin * (mx - this.x) + cos * (my - this.y) + this.y;
                const localX = cos * (mx - this.x) - sin * (my - this.y) + this.x - (localY- this.y)/this.length * this.slide ;

                return (localX >= this.x - this.width / 2 && localX <= this.x + this.width / 2 &&
                        localY >= this.y  && localY <= this.y + this.length);
            }

            getEndpoints() {
                const angleRad = this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const x1 = this.x;
                const y1 = this.y;
                const x2 = this.x - (this.length) * sin + this.slide * cos ;
                const y2 = this.y + (this.length) * cos + this.slide * sin ; 
                return [
            	   { x: x1, y: y1, angle: this.angle, id: `${this.id}-1`, type: 'concave' },
            	   { x: x2, y: y2, angle: this.angle, id: `${this.id}-2`, type: 'convex' }		];
            }
        }




class Curve {
    constructor(x, y, id, direction = DIRECTION_LEFT, radius = RAIL_LENGTH) {
        this.x = x;
        this.y = y;
        this.width = RAIL_WIDTH;
        this.radius = radius;
        this.id = id;
        this.angle = 0;
		this.color = COLORS.CURVE.base;
		this.highlightColor = COLORS.CURVE.highlight;
        this.direction = direction; // 'left' or 'right'
		this.turnAngle = 45;
    }

     draw() {
        if (useRealisticRendering) {
            // リアル描画（4層）
            this.drawWithWidth(14, 'black');
            this.drawWithWidth(12, this.color);
            this.drawWithWidth(6, this.highlightColor);
            this.drawWithWidth(4, this.color);
        } else {
            // シンプル描画（1層）
            this.drawWithWidth(this.width, this.color);
        }
    }
    
    drawWithWidth(width, color) {
		const turnRad = this.turnAngle/180 * Math.PI;
	 
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle * Math.PI / 180);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = 'butt';
        ctx.beginPath();
        if (this.direction === DIRECTION_LEFT) {
            ctx.arc(-this.radius, 0, this.radius, 0, turnRad);
        } else if (this.direction === DIRECTION_RIGHT) {
            ctx.arc(this.radius, 0, this.radius, Math.PI -turnRad, Math.PI);
        } else {
            throw new Error(`Invalid direction: ${this.direction}`);
        }
        ctx.stroke();
        ctx.restore();
    }

    contains(mx, my) {
        const angleRad = this.angle * Math.PI / 180;
		const turnRad = this.turnAngle/180 * Math.PI;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);

        const x1 = this.direction === DIRECTION_LEFT 
		? this.x - this.radius * cos
		: this.x + this.radius * cos;
        const y1 = this.direction === DIRECTION_LEFT 
		? this.y - this.radius * sin 
		: this.y + this.radius * sin;

        const dx = mx - x1;
        const dy = my - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let angle = Math.atan2(dy, dx) - this.angle * Math.PI / 180;
        angle = normalizeAngle(angle);

        // 左カーブ: 0 → turnRad
        // turnRad > πの場合、normalizeAngle後は一部が負の値になる
        // 例: 270度 = 3π/2 → 正規化後 0~π と -π~-π/2 の範囲
        let withinArc;
        if (this.direction === DIRECTION_LEFT) {
            if (turnRad <= Math.PI) {
                // 180度以下: 通常通り
                withinArc = (angle >= 0 && angle <= turnRad);
            } else {
                // 180度超: 0~π または -(2π-turnRad)~0 の範囲
                const negativeEnd = turnRad - Math.PI * 2;
                withinArc = (angle >= 0 && angle <= Math.PI) || (angle <= negativeEnd && angle > -Math.PI);
            }
        } else {
                withinArc = (angle >= (Math.PI - turnRad) && angle <= Math.PI);
        }
        
        return distance >= this.radius - this.width / 2 && 
               distance <= this.radius + this.width / 2 && 
               withinArc;
    }


    getEndpoints() {
        const angleRad = this.angle * Math.PI / 180;
		const turnRad = this.turnAngle/180 * Math.PI;
		
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        const x1 = this.x ;
        const y1 = this.y ;
        const x2 = this.direction === DIRECTION_LEFT ? this.x  - this.radius * cos + this.radius * Math.cos(angleRad + turnRad) : this.x  + this.radius * cos + this.radius * Math.cos(angleRad + Math.PI-turnRad);
        const y2 = this.direction === DIRECTION_LEFT ? this.y  - this.radius * sin + this.radius * Math.sin(angleRad + turnRad) : this.y  + this.radius * sin + this.radius * Math.sin(angleRad + Math.PI-turnRad);
        return [
            { x: x1, y: y1, angle:  this.angle  , id: `${this.id}-1`, type: 'concave' },
            { x: x2, y: y2, angle: this.direction === DIRECTION_LEFT ? this.angle + this.turnAngle : this.angle -this.turnAngle, id: `${this.id}-2`, type: 'convex' }
        ];
    }
}



class TurnoutRail {
    constructor(x, y, id, turnoutType = 'R', direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.turnoutType = turnoutType;   // 'R' or 'L'
        this.direction = direction;       // 'left' or 'right'
        this.components = [];
        this.color = COLORS.TURNOUT.base;
        this.highlightColor = COLORS.TURNOUT.highlight;
        
        // 端点構造の説明（実在製品に準拠）:
        // R型: 起点(凹) → 直線終点(凸) + 曲線終点(凸)
        //      起点から直線と曲線が分岐。両方とも接続元
        // L型: 起点(凹) → 直線終点(凸) → 曲線終点(凹)
        //      直線終点から180度反転した曲線。直線は凸、曲線は凹
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;

        const base = this.angle;
        const dir = this.direction;

        /* ===== R型：起点共有・直線と曲線が分岐 ===== */
        if (this.turnoutType === 'R') {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;
            straight.highlightColor = this.highlightColor;

            // 曲線部（起点共有）
            const curve = new Curve(this.x, this.y, this.id + '-C', dir);
            curve.angle = base;
            curve.color = this.color;
            curve.highlightColor = this.highlightColor;

            this.components.push(straight, curve);
        }

        /* ===== L型：直線終点から180度反転した曲線 ===== */
        else {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;
            straight.highlightColor = this.highlightColor;

            // 曲線部（直線終点から180度反転）
            const straightEp = straight.getEndpoints()[1];
            const curve = new Curve(straightEp.x, straightEp.y, this.id + '-C', dir);
            curve.angle = reversedegAngle(straightEp.angle);
            curve.color = this.color;
            curve.highlightColor = this.highlightColor;

            this.components.push(straight, curve);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.components.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // R型の場合：起点共有・直線と曲線が分岐
        if (this.turnoutType === 'R') {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 曲線終点（凸）
            eps.push({
                ...this.components[1].getEndpoints()[1],
                id: this.id + '-4',
                type: 'convex'
            });
        }
        // L型の場合：直線終点から180度反転した曲線
        else {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 曲線終点（凹）- L型は曲線が凹（接続を受ける側）
            const curveEp = this.components[1].getEndpoints()[1];
            eps.push({
                x: curveEp.x,
                y: curveEp.y,
                angle: reversedegAngle(curveEp.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        }

        return eps;
    }
}


class R17ThreewayRail {
    constructor(x, y, id, ThreewayType = 'B', direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.ThreewayType = ThreewayType;   // 'A' or 'B'
        this.direction = direction;       // 'left' or 'right'
        this.components = [];
        this.color = COLORS.R17.base;
        this.highlightColor = COLORS.R17.highlight;
        
        // R-17 三方向ポイント（実在製品に準拠）:
        // B型: 起点(凹) → 直線終点(凸) + 左曲線終点(凸) + 右曲線終点(凸)
        //      起点から直線と左右のカーブが分岐する三方向
        // A型: 起点(凹) → 直線終点(凸) → 左曲線終点(凸) + 右曲線終点(凸)
        //      直線終点から180度反転した左右カーブ
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;

        const base = this.angle;
        const dir = this.direction;
		const dir2 =  (this.direction === 'right') ? 'left' : 'right';
		

        /* ===== B型：起点共有・直線と曲線が分岐 ===== */
        if (this.ThreewayType === 'B') {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;
            straight.highlightColor = this.highlightColor;

            // 曲線部（起点共有）
            const curve = new Curve(this.x, this.y, this.id + '-C', dir);
            curve.angle = base;
            curve.color = this.color;
            curve.highlightColor = this.highlightColor;

            // 曲線部2（起点共有）（起点共有）
            const curve2 = new Curve(this.x, this.y, this.id + '-C2', dir2);
            curve2.angle = base;
            curve2.color = this.color;
            curve2.highlightColor = this.highlightColor;

            this.components.push(straight, curve, curve2);
        }

        /* ===== L型：直線終点から180度反転した曲線 ===== */
        else {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;
            straight.highlightColor = this.highlightColor;

            // 曲線部（直線終点から180度反転）
            const straightEp = straight.getEndpoints()[1];
            const curve = new Curve(straightEp.x, straightEp.y, this.id + '-C', dir);
            curve.angle = reversedegAngle(straightEp.angle);
            curve.color = this.color;
            curve.highlightColor = this.highlightColor;

            // 曲線部（直線終点から180度反転）
            const curve2 = new Curve(straightEp.x, straightEp.y, this.id + '-C2', dir2);
            curve2.angle = reversedegAngle(straightEp.angle);
            curve2.color = this.color;
            curve2.highlightColor = this.highlightColor;


            this.components.push(straight, curve, curve2);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.components.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // B型の場合：起点共有・直線と曲線が分岐
        if (this.ThreewayType === 'B') {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 曲線終点（凸）
            eps.push({
                ...this.components[1].getEndpoints()[1],
                id: this.id + '-4',
                type: 'convex'
            });

            // 曲線2終点（凹）
            eps.push({
                ...this.components[2].getEndpoints()[1],
                angle: reversedegAngle(this.components[2].getEndpoints()[1].angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });

        }
        // A型の場合：直線終点から180度反転した曲線
        else {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 曲線終点（凹）- L型は曲線が凹（接続を受ける側）
            const curveEp = this.components[1].getEndpoints()[1];
            eps.push({
                x: curveEp.x,
                y: curveEp.y,
                angle: reversedegAngle(curveEp.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        
            // 曲線終点（凸）
            eps.push({
                ...this.components[2].getEndpoints()[1],
                id: this.id + '-4',
                type: 'convex'
            });

		
		}

        return eps;
    }
}


class R13PointRail {
    constructor(x, y, id, pointType = 'B', direction = 'right') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'B' or 'A'
        this.direction = direction;   // 'right' or 'left' (スライドの方向)
        this.components = [];
        this.color = COLORS.R13.base;
        this.highlightColor = COLORS.R13.highlight;
        this.isDoubleTrack = true;  // 単複ポイントは複線扱い
        // R-13は単線→複線なので特殊: Bタイプは[1]→[2,4]、Aタイプは[1,3]→[2]
        this.endpointPairs = pointType === 'B' ? [[2, 4]] : [[1, 3]];
        
        // 端点構造の説明（R-13単線・複線ポイント）:
        // Bタイプ: 起点(凹-1) → 直線終点(凸-2) + スライド終点(凸-4)
        //          起点から直線とスライドが分岐。端点2と4がペア
        // Aタイプ: 起点(凹-1) → 直線終点(凸-2) → スライド終点(凹-3)
        //          直線終点から180度反転したスライド。端点1と2がペア
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;

        const base = this.angle;
        const slideAmount = this.direction === 'right' ? D_TRACK_WIDTH : -D_TRACK_WIDTH;

        /* ===== Bタイプ：起点共有・直線とスライドが分岐 ===== */
        if (this.pointType === 'B') {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;
            straight.highlightColor = this.highlightColor;

            // スライド部（起点共有）
            const slide = new Slide(this.x, this.y, this.id + '-SL', slideAmount);
            slide.angle = base;
            slide.color = this.color;
            slide.highlightColor = this.highlightColor;

            this.components.push(straight, slide);
        }

        /* ===== Aタイプ：直線終点から180度反転したスライド ===== */
        else {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;
            straight.highlightColor = this.highlightColor;

            // スライド部（直線終点から180度反転）
            const straightEp = straight.getEndpoints()[1];
            const slide = new Slide(straightEp.x, straightEp.y, this.id + '-SL', slideAmount);
            slide.angle = reversedegAngle(straightEp.angle);
            slide.color = this.color;
            slide.highlightColor = this.highlightColor;

            this.components.push(straight, slide);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.components.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // Bタイプの場合：起点共有・直線とスライドが分岐
        if (this.pointType === 'B') {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // スライド終点（凸）
            eps.push({
                ...this.components[1].getEndpoints()[1],
                id: this.id + '-4',
                type: 'convex'
            });
        }
        // Aタイプの場合：直線終点から180度反転したスライド
        else {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // スライド終点（凹）- Aタイプはスライドが凹（接続を受ける側）
            const slideEp = this.components[1].getEndpoints()[1];
            eps.push({
                x: slideEp.x,
                y: slideEp.y,
                angle: reversedegAngle(slideEp.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        }

        return eps;
    }
}

class R22YPointRail {
    constructor(x, y, id, pointType = 'A', isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'A' or 'B'
        this.isReversed = isReversed; // 裏タイプ
        this.slides = [];
        this.color = COLORS.R22.base;
        this.highlightColor = COLORS.R22.highlight;  // R-22 Y字ポイント専用の色
        
        // 端点構造の説明（R-22 Y字ポイント）:
        // Aタイプ: 起点(凹) → 1本目(右20スライド)終点(凸) → 2本目(左20スライド)終点(凸)
        //          1本目の終点から反転して2本目が分岐
        // Bタイプ: 起点(凹) → 1本目(左20スライド)終点(凸) + 2本目(右20スライド)終点(凹)
        //          起点共有、左右に分岐（8の字に類似）
        // 裏タイプ: 左右反転
    }

    /* =========================
       内部構築
    ========================= */
    _buildSlides() {
        this.slides.length = 0;
        const base = this.angle;

        /* ===== Aタイプ：1本目終点から2本目が反転 ===== */
        if (this.pointType === 'A') {
            const direction = this.isReversed ? -1 : 1;
            
            // 1本目: 右に20スライド (or 左に20)
            const slide1 = new Slide(this.x, this.y, this.id + '-A', 20 * direction);
            slide1.angle = base;
            slide1.color = this.color;

            // 2本目: 1本目の終点から反転して左に20スライド (or 右に20)
            const ep1 = slide1.getEndpoints()[1];
            const slide2 = new Slide(ep1.x, ep1.y, this.id + '-B', -20 * direction);
            slide2.angle = reversedegAngle(ep1.angle);
            slide2.color = this.color;

            this.slides.push(slide1, slide2);
        }

        /* ===== Bタイプ：起点共有、左右に分岐 ===== */
        else {
            const direction = this.isReversed ? 1 : -1;
            
            // 1本目: 左に20スライド (or 右に20)
            const slide1 = new Slide(this.x, this.y, this.id + '-A', 20 * direction);
            slide1.angle = base;
            slide1.color = this.color;

            // 2本目: 起点共有、右に20スライド (or 左に20)
            const slide2 = new Slide(this.x, this.y, this.id + '-B', -20 * direction);
            slide2.angle = base;
            slide2.color = this.color;

            this.slides.push(slide1, slide2);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildSlides();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.slides.forEach(c => c.drawWithWidth(14, 'black'));
            this.slides.forEach(c => c.drawWithWidth(12, this.color));
            this.slides.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.slides.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.slides.forEach(c => c.draw());
        }    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.slides.some(s => s.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // Aタイプの場合：1本目終点から2本目が反転
        if (this.pointType === 'A') {
            // 1本目終点（凸）
            const ep1 = this.slides[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凸）
            const ep2 = this.slides[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: ep2.angle,
                id: this.id + '-4',
                type: 'convex'
            });
        }
        // Bタイプの場合：起点共有、左右に分岐
        else {
            // 1本目終点（凸）
            const ep1 = this.slides[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凹）- Bタイプは凹（接続を受ける側）
            const ep2 = this.slides[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: reversedegAngle(ep2.angle),
                id: this.id + '-3',
                type: 'concave'
            });
        }

        return eps;
    }
}

class R15WidePointRail {
    constructor(x, y, id, pointType = 'A', isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'A' or 'B'
        this.isReversed = isReversed; // 裏タイプ
        this.components = [];
        this.color = COLORS.R15.base;
        this.highlightColor = COLORS.R15.highlight;
        this.isDoubleTrack = true;  // 複線ポイント
        // R-15は3本分岐なので2組のペア（3本目は1本目と共通端点）
        this.endpointPairs = pointType === 'A' ? [[2, 4]] : [[2, 4], [5, 7]];
        
        // 端点構造の説明（R-15複線幅広ポイント）:
        // Aタイプ: 起点(凹-1) → 1本目S字(右40)終点(凸-2,4共通) + 2本目直線終点(凹-3) + 3本目S字(右18)
        // Bタイプ: 起点(凹-1) → 1本目S字(左40)終点(凸-2) + 2本目S字(左18)終点(凸-4) + 3本目直線終点(凸-5,7)
        // 裏タイプ: 左右反転
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;

        /* ===== Aタイプ ===== */
        if (this.pointType === 'A') {
            const direction = this.isReversed ? -1 : 1;
            
            // 1本目: S字(右40 or 左40) 長さ100
            const slide1 = new Slide(this.x, this.y, this.id + '-1', 40 * direction, 100);
            slide1.angle = base;
            slide1.color = this.color;
            
            // 2本目: 直線 長さ100
            const straight = new StraightRail(this.x, this.y, this.id + '-2', 100);
            straight.angle = base;
            straight.color = this.color;
            
            // 3本目: 起点から右22(or左22)の位置、S字(右18 or 左18) 長さ100
            const offsetX = 22 * direction * Math.sin(angleRad + Math.PI * 0.5);
            const offsetY = -22 * direction * Math.cos(angleRad + Math.PI * 0.5);
            const slide3 = new Slide(this.x + offsetX, this.y + offsetY, this.id + '-3', 18 * direction, 100);
            slide3.angle = base;
            slide3.color = this.color;
            
            this.components.push(slide1, straight, slide3);
        }
        
        /* ===== Bタイプ ===== */
        else {
            const direction = this.isReversed ? 1 : -1;  // Bタイプは左が基本
            
            // 1本目: S字(左40 or 右40) 長さ100
            const slide1 = new Slide(this.x, this.y, this.id + '-1', 40 * direction, 100);
            slide1.angle = base;
            slide1.color = this.color;
            
            // 2本目: S字(左18 or 右18) 長さ100
            const slide2 = new Slide(this.x, this.y, this.id + '-2', 18 * direction, 100);
            slide2.angle = base;
            slide2.color = this.color;
            
            // 3本目: 起点から左40(or右40)の位置から直線 長さ100
            const offsetX = 40 * direction * Math.sin(angleRad + Math.PI * 0.5);
            const offsetY = -40 * direction * Math.cos(angleRad + Math.PI * 0.5);
            const straight = new StraightRail(this.x + offsetX, this.y + offsetY, this.id + '-3', 100);
            straight.angle = base;
            straight.color = this.color;
            // 3本目の起点は凸
            straight.startType = 'convex';
            straight.endType = 'convex';
            
            this.components.push(slide1, slide2, straight);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        if (useRealisticRendering) {
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            this.components.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        /* ===== Aタイプ ===== */
        if (this.pointType === 'A') {
            // 起点（凹）- 1本目と2本目と3本目の共通起点
            eps.push({
                x: this.x,
                y: this.y,
                angle: this.angle,
                id: this.id + '-1',
                type: 'concave'
            });
            
            // 1本目終点（凸）- 次レール接続点
            const ep1 = this.components[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });
            
            // 2本目終点（凹）
            const ep2 = this.components[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: reversedegAngle(ep2.angle),
                id: this.id + '-3',
                type: 'concave'
            });
            
            // 3本目起点（凹）
            const ep3start = this.components[2].getEndpoints()[0];
            eps.push({
                x: ep3start.x,
                y: ep3start.y,
                angle: ep3start.angle,
                id: this.id + '-5',
                type: 'concave'
            });
            
            // 注: 3本目終点は1本目終点と共通なので追加しない
        }
        
        /* ===== Bタイプ ===== */
        else {
            // 起点（凹）- 1本目と2本目の共通起点
            eps.push({
                x: this.x,
                y: this.y,
                angle: this.angle,
                id: this.id + '-1',
                type: 'concave'
            });
            
            // 1本目終点（凸）- 次レール接続点
            const ep1 = this.components[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });
            
            // 2本目終点（凸）
            const ep2 = this.components[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: ep2.angle,
                id: this.id + '-4',
                type: 'convex'
            });
            
            // 3本目起点（凸）
            const ep3start = this.components[2].getEndpoints()[0];
            eps.push({
                x: ep3start.x,
                y: ep3start.y,
                angle: ep3start.angle,
                id: this.id + '-6',
                type: 'convex'
            });
        }

        return eps;
    }
}

class R30TrianglePointRail {
    constructor(x, y, id, isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.isReversed = isReversed; // 裏タイプ
        this.components = [];
        this.color = COLORS.R30.base;
        this.highlightColor = COLORS.R30.highlight;
        
        // 端点構造の説明（R-30三角ポイント）:
        // 表タイプ: 起点(凹) → 1本目左90度カーブ終点(凸) +右側に3点目
        // 裏タイプ: 起点(凹) → 1本目右90度カーブ終点(凸) +左側に3点目
        // 定数（元のスクリプトから）
        this.TRI_P_A = 0.585786;
        this.TRI_P_B = 0.171573;
        
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;

        const dir = this.isReversed ? 'left' : 'right';
        const dir2 = this.isReversed ? 'right' : 'left';
            
        // 主カーブ（90度）
        const curve1 = new Curve(this.x, this.y, this.id + '-1', dir);
        curve1.angle = base;
        curve1.turnAngle = 90;
        curve1.color = this.color;
            
        // 2本目: 導入直線 
        const straight1 = new StraightRail(this.x, this.y, this.id + '-2', this.TRI_P_A * RAIL_LENGTH);
        straight1.angle = base;
        straight1.color = this.color;
            
        // 3本目: 反対に曲がるカーブ
        const startCurve1 = straight1.getEndpoints()[1];
        const curve3 = new Curve(startCurve1.x, startCurve1.y, this.id + '-3', dir2);
        curve3.angle = base;
        curve3.color = this.color;

        // 4本目: 直線第三のジョイント
        const endCurve1 = curve3.getEndpoints()[1];
        const straight2 = new StraightRail(endCurve1.x, endCurve1.y, this.id + '-4', this.TRI_P_B * RAIL_LENGTH);
        straight2.angle = endCurve1.angle;
        straight2.color = this.color;

        // 5本目：戻りカーブ
        const curve5 = new Curve(endCurve1.x, endCurve1.y, this.id + '-5', dir2);
        curve5.angle = reversedegAngle(endCurve1.angle);
        curve5.color = this.color;

        // 6本目
        const mainCurveEnd = curve1.getEndpoints()[1];
        const straight3 = new StraightRail(mainCurveEnd.x, mainCurveEnd.y, this.id + '-6', this.TRI_P_A * RAIL_LENGTH);
        straight3.angle = reversedegAngle(mainCurveEnd.angle);
        straight3.color = this.color;
            
        this.components.push(curve1, straight1, curve3, straight2, curve5, straight3);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        if (useRealisticRendering) {
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            this.components.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）- 1本目と2本目と3本目の共通起点
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });
            
        // 1本目終点（凸）- 次レール接続点
        const ep1 = this.components[0].getEndpoints()[1];
        eps.push({
            x: ep1.x,
            y: ep1.y,
            angle: ep1.angle,
            id: this.id + '-2',
            type: 'convex'
        });
            
        // 2本目終点
        const ep2 = this.components[3].getEndpoints()[1];
        eps.push({
            x: ep2.x,
            y: ep2.y,
            angle: ep2.angle,
            id: this.id + '-4',
            type: 'convex'
        });
            
        return eps;
    }
}

class CrossPointRail {
    constructor(x, y, id, isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.isReversed = isReversed; // 裏タイプ
        this.components = [];
        this.color = COLORS.CROSS.base;
        this.highlightColor = COLORS.CROSS.highlight;
        
        // 端点構造の説明（十字ポイント・実際の仕様）:
        // 1本目: 横方向直線 起点(凹) → 終点(凸)
        // 2本目: 縦方向直線 起点(左・凸) → 終点(右・凹)、中央で交差
        // カーブ1: 1本目起点 → 2本目終点へ90度カーブ（半径40、中心は起点から左40）
        // カーブ2: 2本目起点 → 1本目終点へ90度カーブ（半径40）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const rev = this.isReversed ? -1 : 1;
        const dir = this.isReversed ? 'left' : 'right';
        const dir2 = this.isReversed ? 'right' : 'left';



        
        // 1本目: 横方向直線（起点凹→終点凸）
        const straight1 = new StraightRail(this.x, this.y, this.id + '-1');
        straight1.angle = base;
        straight1.color = this.color;
        
        // 2本目: 縦方向直線（左→右）
        // 起点は1本目起点から左に40
		const { x: offset2X, y: offset2Y } = rotatePoint(rev * RAIL_LENGTH/2, RAIL_LENGTH/2, angleRad);
        const straight2 = new StraightRail(this.x + offset2X, this.y + offset2Y, this.id + '-2');
        straight2.angle = base + rev * 90;
        straight2.color = this.color;
        straight2.startType = 'convex';  // 左側は凸
        straight2.endType = 'concave';   // 右側は凹
        
        // カーブ1: 1本目起点 → 2本目終点へ（半径40、90度左カーブ）
        const curve1 = new Curve(this.x, this.y, this.id + '-C1', dir2);
        curve1.angle = base;
		curve1.turnAngle = 90;
		curve1.radius = RAIL_LENGTH/2;
		curve1.color = this.color;
        
        // カーブ2: 2本目起点 → 1本目終点へ（半径40、90度右カーブ）
        const curve2 = new Curve(this.x + offset2X, this.y + offset2Y, this.id + '-C2', dir);
        curve2.angle = base + rev * 90 ;
		curve2.turnAngle = 90;
		curve2.radius = RAIL_LENGTH/2;
        curve2.color = this.color;
		
        // カーブ3: 3本目起点 → 2本目終点へ（半径40、90度左カーブ）
        const curve3 = new Curve(this.x, this.y, this.id + '-C3', dir, RAIL_LENGTH/2);
        curve3.angle = base;
		curve3.turnAngle = 90;
		curve3.radius = RAIL_LENGTH/2;
		curve3.color = this.color;
		curve3.structure = 'true';
		
		const { x: offset3X, y: offset3Y } = rotatePoint(0, RAIL_LENGTH, angleRad);
        
        // カーブ4: 4本目起点 → 1本目終点へ（半径40、90度右カーブ）
        const curve4 = new Curve(this.x + offset3X, this.y + offset3Y, this.id + '-C4', dir);
        curve4.angle = reversedegAngle(base);
		curve4.turnAngle = 90;
		curve4.radius = RAIL_LENGTH/2;
        curve4.color = this.color;
 		curve3.structure = 'true';
       
        this.components.push(straight1, straight2, curve1, curve2,curve3,curve4);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        if (useRealisticRendering) {
			//走行路でないパーツ
            this.components.slice(-2).forEach(c => c.drawWithWidth(14, 'black'));
            this.components.slice(-2).forEach(c => c.drawWithWidth(12, this.color));
		
		　　//走行路部分
            this.components.slice(0, 4).forEach(c => c.drawWithWidth(14, 'black'));
            this.components.slice(0, 4).forEach(c => c.drawWithWidth(12, this.color));
            this.components.slice(0, 4).forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.slice(0, 4).forEach(c => c.drawWithWidth(4, this.color));
        } else {
            this.components.forEach(c => c.draw());
        }
	}

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 1本目起点（凹）
        const ep1Start = this.components[0].getEndpoints()[0];
        eps.push({
            x: ep1Start.x,
            y: ep1Start.y,
            angle: ep1Start.angle,
            id: this.id + '-1',
            type: 'concave'
        });
        
        // 1本目終点（凸）
        const ep1End = this.components[0].getEndpoints()[1];
        eps.push({
            x: ep1End.x,
            y: ep1End.y,
            angle: ep1End.angle,
            id: this.id + '-2',
            type: 'convex'
        });
        
        // 2本目起点（左・凹）
        const ep2Start = this.components[1].getEndpoints()[0];
        eps.push({
            x: ep2Start.x,
            y: ep2Start.y,
            angle: reversedegAngle(ep2Start.angle),
            id: this.id + '-3',
            type: 'concave'
        });
        
        // 2本目終点（右・凸）
        const ep2End = this.components[1].getEndpoints()[1];
        eps.push({
            x: ep2End.x,
            y: ep2End.y,
            angle: reversedegAngle(ep2End.angle),
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleTrackCrossoverRail {
    constructor(x, y, id, isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.isReversed = isReversed;  // 表裏
        this.components = [];
        this.color = COLORS.DOUBLE_TRACK_CROSS.base;
        this.highlightColor = COLORS.DOUBLE_TRACK_CROSS.highlight;
        this.isDoubleTrack = true;  // 複線レールフラグ
        this.endpointPairs = [[1, 3], [2, 4]];  // 端点ペア
        
        // 端点構造の説明（複線渡り・実際の仕様）:
        // 複線直線2本 + S字2本（交差）
        // 表: 左→右、右→左
        // 裏: 右→左、左→右（逆）
        // 端点: 1,3が起点側（凹×2）、2,4が終点側（凸×2）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const direction = this.isReversed ? 1 : -1;
        const flg = this.isReversed ? 0 : 1;
        
        // 複線直線2本（DoubleTrackRailと同じ配置）
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH , 0 , angleRad);
        const Straight1 = new StraightRail(this.x, this.y, this.id + '-fS');
        Straight1.angle = base;
        Straight1.color = this.color;
        
        const Straight2 = new StraightRail(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-sS');
        Straight2.angle = base;
        Straight2.color = this.color;
        
        // S字2本（交差）
        const Slide1 = new Slide(this.x + track1OffsetX * flg, this.y + track1OffsetY * flg, this.id + '-L', D_TRACK_WIDTH * direction);
        Slide1.angle = base;
        Slide1.color = this.color;
        
        
        this.components.push(Straight1, Straight2, Slide1);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.components.forEach(c => c.draw());
        }    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];
        // 起点側（左）
        const leftStart = this.components[0].getEndpoints()[0];
        eps.push({
            x: leftStart.x,
            y: leftStart.y,
            angle: leftStart.angle,
            id: this.id + '-1',
            type: 'concave'
        });
 
        // 終点側（左）- 左レールの終点
        const leftEnd = this.components[0].getEndpoints()[1];
        eps.push({
            x: leftEnd.x,
            y: leftEnd.y,
            angle: leftEnd.angle,
            id: this.id + '-2',
            type: 'convex'
        });
        // 起点側（右）
        const rightStart = this.components[1].getEndpoints()[0];
        eps.push({
            x: rightStart.x,
            y: rightStart.y,
            angle: rightStart.angle,
            id: this.id + '-3',
            type: 'concave'
        });
        // 終点側（右）- 右レールの終点
        const rightEnd = this.components[1].getEndpoints()[1];
        eps.push({
            x: rightEnd.x,
            y: rightEnd.y,
            angle: rightEnd.angle,
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleTrackTurnoutRail {
    constructor(x, y, id, direction = 'right', isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.direction = direction;  // 'right' or 'left'
        this.isReversed = isReversed;  // 裏タイプ
        this.components = [];
        this.color = COLORS.DOUBLE_TRACK_TURNOUT.base;
        this.highlightColor = COLORS.DOUBLE_TRACK_TURNOUT.highlight;
        this.isDoubleTrack = true;  // 複線レールフラグ
        // 複線ターンアウトは4組の端点ペア: 直線2本+分岐2本
        this.endpointPairs = [[1, 3], [2, 4], [5, 7],[6, 8]];  
        
        // 複線ターンアウトレール（単線→複線への分岐ポイント）:
        // 複線幅(22mm)の直線2本（長さ120）- 端点 1,3（凹）→ 2,4（凸）
        // 複曲線カーブ2本（90度、外側カーブ使用）- 端点 5,7（凸）→ 6,8（凸）
        // 4種類のバリエーション: 左/右 × 表/裏
        // ※R-17三方向ポイントとは全く別のレール
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const dir = this.direction === 'right' ? -1 : 1;
        const rev = this.isReversed ? -1 : 1;
        const curveDir = this.isReversed ? 'right' : 'left';
        
        // 複線幅の計算（表裏で入れ替わる）
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH , 0 , angleRad);
        
        // 直線2本（長さ120）
        const straight1 = new StraightRail(this.x , this.y, this.id + '-S1', 120);
        straight1.angle = base;
        straight1.color = this.color;
        straight1.highlightColor = this.highlightColor;
        
        const straight2 = new StraightRail(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-S2', 120);
        straight2.angle = base;
        straight2.color = this.color;
        straight2.highlightColor = this.highlightColor;
        
        // 複曲線カーブ2本（90度、外側カーブ使用）
        // 起点はそれぞれの直線の起点
		const C1radius = curveDir === 'left'? RAIL_LENGTH : RAIL_LENGTH + D_TRACK_WIDTH;
		const C2radius = curveDir === 'left'? RAIL_LENGTH + D_TRACK_WIDTH : RAIL_LENGTH;

		let curve1, curve2;
		if(this.direction === 'left'){	
        curve1 = new Curve(this.x, this.y , this.id + '-C1', curveDir, C1radius);
        curve1.angle = base;
        curve1.turnAngle = 90;
       
        curve2 = new Curve(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-C2', curveDir,C2radius);
        curve2.angle = base;
        curve2.turnAngle = 90;
        }else{
		const {x:L_startX,y:L_startY} = straight1.getEndpoints()[1]; 
        curve1 = new Curve(L_startX + track1OffsetX, L_startY + track1OffsetY , this.id + '-C1', curveDir,C1radius);
        curve1.angle = reversedegAngle(base);
        curve1.turnAngle = 90;

        curve2 = new Curve(L_startX , L_startY, this.id + '-C2', curveDir,C2radius);
        curve2.angle = curve1.angle;
        curve2.turnAngle = 90;
		} 
        curve1.color = this.color;
        curve1.highlightColor = this.highlightColor;
        curve2.color = this.color;
        curve2.highlightColor = this.highlightColor;

        this.components.push(straight1, straight2, curve1, curve2);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.components.forEach(c => c.drawWithWidth(14, 'black'));
            this.components.forEach(c => c.drawWithWidth(12, this.color));
            this.components.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.components.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点側（内）
        const leftStart = this.components[0].getEndpoints()[0];
        eps.push({
            x: leftStart.x,
            y: leftStart.y,
            angle: leftStart.angle,
            id: this.id + '-1',
            type: 'concave'
        });

         // 終点側（内）
        const leftEnd = this.components[0].getEndpoints()[1];
        eps.push({
            x: leftEnd.x,
            y: leftEnd.y,
            angle: leftStart.angle,
            id: this.id + '-2',
            type: 'convex'
        });

       // 起点側（外）
        const rightStart = this.components[1].getEndpoints()[0];
        eps.push({
            x: rightStart.x,
            y: rightStart.y,
            angle: rightStart.angle,
            id: this.id + '-3',
            type: 'concave'
        });


        // 終点側（右直線）
        const rightEnd = this.components[1].getEndpoints()[1];
        eps.push({
            x: rightEnd.x,
            y: rightEnd.y,
            angle: rightStart.angle,
            id: this.id + '-4',
            type: 'convex'
        });

//Lタイプの場合
		if(this.direction === 'left'){
        // 終点側（分岐カーブ内）
        const branchEnd = this.components[2].getEndpoints()[1];
        eps.push({
            x: branchEnd.x,
            y: branchEnd.y,
            angle: branchEnd.angle,
            id: this.id + '-6',
            type: 'convex'
        });
        // 終点側（分岐カーブ外）
        const branchEnd2 = this.components[3].getEndpoints()[1];
        eps.push({
            x: branchEnd2.x,
            y: branchEnd2.y,
            angle: branchEnd2.angle,
            id: this.id + '-8',
            type: 'convex'
        });
		}
	//Rタイプの場合
		else{
        // 終点側（分岐カーブ内）
        const branchEnd = this.components[2].getEndpoints()[1];
        eps.push({
            x: branchEnd.x,
            y: branchEnd.y,
            angle: reversedegAngle(branchEnd.angle),
            id: this.id + '-5',
            type: 'concave'
        });
        // 終点側（分岐カーブ外）
        const branchEnd2 = this.components[3].getEndpoints()[1];
        eps.push({
            x: branchEnd2.x,
            y: branchEnd2.y,
            angle: reversedegAngle(branchEnd2.angle),
            id: this.id + '-7',
            type: 'concave'
        });
			
		
		}
	
        return eps;
    }
}

class DoubleTrackRail {
    constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.components = [];
        this.color = 'cyan';  // 複線レール専用の色
        this.isDoubleTrack = true;  // 複線レールフラグ
        this.endpointPairs = [[1, 3], [2, 4]];  // 端点ペア: [1,3]と[2,4]がペア
        
        // 端点構造の説明:
        // 起点側: 2本のレール（凹×2） - ID末尾 1, 3
        // 終点側: 2本のレール（凸×2） - ID末尾 2, 4
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        
        // 角度のラジアン変換
        const angleRad = base * Math.PI / 180;
        
        // 1本目: 基準位置の直線
        const rail1 = new StraightRail(this.x, this.y, this.id + '-1');
        rail1.angle = base;
        rail1.color = this.color;
        
        // 2本目: D_TRACK_WIDTH分、進行方向に対して右90度方向にオフセット
        // 進行方向がangleRadのとき、右90度方向（時計回りに90度）は:
        // offsetX = D_TRACK_WIDTH * sin(angleRad)
        // offsetY = -D_TRACK_WIDTH * cos(angleRad)
        const offsetX =  D_TRACK_WIDTH * Math.sin(angleRad+Math.PI*0.5);
        const offsetY = -D_TRACK_WIDTH * Math.cos(angleRad+Math.PI*0.5);
        
        const rail2 = new StraightRail(this.x + offsetX, this.y + offsetY, this.id + '-2');
        rail2.angle = base;
        rail2.color = this.color;
        
        this.components.push(rail1, rail2);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 1本目の起点（凹）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[0],
            id: this.id + '-1',
            type: 'concave'
        });
        
        // 1本目の終点（凸）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[1],
            id: this.id + '-2',
            type: 'convex'
        });

        // 2本目の起点（凹）
        eps.push({
            ...this.components[1].getEndpoints()[0],
            id: this.id + '-3',
            type: 'concave'
        });
        
        // 2本目の終点（凸）
        eps.push({
            ...this.components[1].getEndpoints()[1],
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleCurveRail {
    constructor(x, y, id, direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.direction = direction;  // 'left' or 'right'
        this.components = [];
        this.color = 'lightcyan';  // 複曲線レール専用の色
        this.isDoubleTrack = true;  // 複線レールフラグ
        this.endpointPairs = [[1, 3], [2, 4]];  // 端点ペア
        
        // 端点構造の説明:
        // 起点側: 2本のカーブ（凹×2） - ID末尾 1, 3
        // 終点側: 2本のカーブ（凸×2） - ID末尾 2, 4
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;

        // 角度のラジアン変換
        const angleRad = base * Math.PI / 180;


        const dir = this.direction;
        
        // 1本目: 基準位置からのカーブ
		//右曲がり　外側カーブ、　左曲がりカーブ
		const innerradius = dir === 'left'? RAIL_LENGTH : RAIL_LENGTH + D_TRACK_WIDTH;
        const innerCurve = new Curve(this.x, this.y, this.id + '-I', dir, innerradius);
        innerCurve.angle = base;
        innerCurve.color = this.color;
        
        // 2本目: 基準位置から右側にオフセットした外側カーブ
		
        const offsetX =  D_TRACK_WIDTH * Math.sin(angleRad+Math.PI*0.5);
        const offsetY = -D_TRACK_WIDTH * Math.cos(angleRad+Math.PI*0.5);
	
        const outerStartX = this.x + offsetX;
        const outerStartY = this.y + offsetY;
        
        // 右置きカーブ（右曲がり　カーブ　左曲がり　外側カーブ）
		const outerradius = dir === 'left'? RAIL_LENGTH + D_TRACK_WIDTH : RAIL_LENGTH; 
        const outerCurve = new Curve(outerStartX, outerStartY, this.id + '-O', dir, outerradius);
        outerCurve.angle = base;
        outerCurve.color = this.color;
        
        this.components.push(innerCurve, outerCurve);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 内側カーブの起点（凹）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[0],
            id: this.id + '-1',
            type: 'concave'
        });
        
        // 内側カーブの終点（凸）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[1],
            id: this.id + '-2',
            type: 'convex'
        });

        // 外側カーブの起点（凹）
        eps.push({
            ...this.components[1].getEndpoints()[0],
            id: this.id + '-3',
            type: 'concave'
        });
        
        // 外側カーブの終点（凸）
        eps.push({
            ...this.components[1].getEndpoints()[1],
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleLengthCurve {
    constructor(x, y, id, direction = DIRECTION_LEFT) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
		this.radius = RAIL_LENGTH;  // 通常カーブと同じ半径
        this.direction = direction;  // 'left' or 'right'
        this.color = COLORS.DOUBLE_CURVE.base;
        this.highlightColor = COLORS.DOUBLE_CURVE.highlight;
        
        // 端点構造の説明（倍曲線）:
        // 通常カーブ2本分で90度曲がる
        // 半径: RAIL_LENGTH = 80（通常カーブと同じ）
        // 角度: 90度（通常カーブの2倍）
        // 起点(凹) → 終点(凸)
    }

    /* =========================
       描画
    ========================= */
    draw() {
        if (useRealisticRendering) {
            // リアル描画（4層）
            this.drawWithWidth(14, 'black');
            this.drawWithWidth(12, this.color);
            this.drawWithWidth(6, this.highlightColor);
            this.drawWithWidth(4, this.color);
        } else {
            // シンプル描画（1層）
            this.drawWithWidth(RAIL_WIDTH, this.color);
        }
    }
    
    drawWithWidth(width, color) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle * Math.PI / 180);

        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = 'butt';
        ctx.beginPath();
        
        const radius = this.radius;
        
        if (this.direction === DIRECTION_LEFT) {
            ctx.arc(-radius, 0, radius, 0, Math.PI / 2);  // 0度から90度
        } else if (this.direction === DIRECTION_RIGHT) {
            ctx.arc(radius, 0, radius, Math.PI / 2, Math.PI);  // 90度から180度
        }
        ctx.stroke();
        ctx.restore();
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        const angleRad = this.angle * Math.PI / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
  //      const radius = this.radius;  // 通常カーブと同じ半径

        const x1 = this.direction === DIRECTION_LEFT ? this.x - this.radius * cos : this.x + this.radius * cos;
        const y1 = this.direction === DIRECTION_LEFT ? this.y - this.radius * sin : this.y + this.radius * sin;

        const dx = mx - x1;
        const dy = my - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let angle = Math.atan2(dy, dx) - this.angle * Math.PI / 180;
        angle = normalizeAngle(angle);

        const withinArc = this.direction === DIRECTION_LEFT ? 
            (angle >= 0 && angle <= Math.PI / 2) : 
            (angle >= Math.PI / 2 && angle <= Math.PI);
        
        return distance >= this.radius - RAIL_WIDTH / 2 && 
               distance <= this.radius + RAIL_WIDTH / 2 && 
               withinArc;
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        const angleRad = this.angle * Math.PI / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
 //       const radius = RAIL_LENGTH;  // 通常カーブと同じ半径
        
        const x1 = this.x;
        const y1 = this.y;
        
        // 90度（π/2）回転後の終点
        const x2 = this.direction === DIRECTION_LEFT ? 
            this.x - this.radius * cos + this.radius * Math.cos(angleRad + Math.PI / 2) : 
            this.x + this.radius * cos + this.radius * Math.cos(angleRad + Math.PI / 2);
        const y2 = this.direction === DIRECTION_LEFT ? 
            this.y - this.radius * sin + this.radius * Math.sin(angleRad + Math.PI / 2) : 
            this.y + this.radius * sin + this.radius * Math.sin(angleRad + Math.PI / 2);
        
        return [
            { x: x1, y: y1, angle: this.angle, id: `${this.id}-1`, type: 'concave' },
            { x: x2, y: y2, angle: this.direction === DIRECTION_LEFT ? this.angle + 90 : this.angle - 90, id: `${this.id}-2`, type: 'convex' }
        ];
    }
}

class UTurnRail {
    constructor(x, y, id, type = 'U') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.type = type;  // 'U' or 'V' (逆U)
        this.components = [];
        this.color = COLORS.UTURN.base;
        this.highlightColor = COLORS.UTURN.highlight;
        
        // 定数（元のスクリプトから）
        this.DOUBLE_TRACK_DISTANCE_RATIO = 0.278;
        this.URAIL_RADIUS_RATIO = 0.62037;
        this.URAIL_CNCT_R_RATIO = 1.02351;
        
        // 端点構造の説明（Uターンレール）:
        // U字型に180度折り返すレール
        // type='U': 通常、type='V': 逆向き
    }
    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const rev = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const b = (this.type === 'V' || this.type === 'v') ? 0 : 1;
        const c = (this.type === 'V' || this.type === 'v') ? 1 : 0;
        const dir = (this.type === 'V' || this.type === 'v') ? 'right' : 'left';
        const dir2 = (this.type === 'V' || this.type === 'v') ? 'left' : 'right';
 
//起点からの接続レール
		const Curve1 = new Curve(this.x, this.y, this.id + '-U1', dir,RAIL_LENGTH * this.URAIL_CNCT_R_RATIO); 
			Curve1.angle = base;
			Curve1.color = this.color;
			Curve1.highlightColor = this.highlightColor;

//ターン円
		const C1end = Curve1.getEndpoints()[1];
		const UturnMain = new Curve(C1end.x, C1end.y, this.id +'-U2',dir2,RAIL_LENGTH * this.URAIL_RADIUS_RATIO);
		UturnMain.angle = C1end.angle;
		UturnMain.turnAngle = 270;
		UturnMain.color = this.color;
		UturnMain.highlightColor = this.highlightColor;

//もう一つの接続レール
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH * rev, 0 , angleRad);
		const Curve2 = new Curve(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-U3', dir2 ,RAIL_LENGTH * this.URAIL_CNCT_R_RATIO); 
				Curve2.angle = base;
				Curve2.color = this.color;
				Curve2.highlightColor = this.highlightColor;
        
//レールでないパーツ
		const UturnPart1 = new Curve(C1end.x, C1end.y, this.id +'-p1',dir,RAIL_LENGTH * this.URAIL_RADIUS_RATIO);
		UturnPart1.angle = reversedegAngle(C1end.angle);
		UturnPart1.turnAngle = 90;
		UturnPart1.color = this.color;
		UturnPart1.highlightColor = this.highlightColor;

        
        this.components.push(Curve1,UturnMain,Curve2,UturnPart1);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        const a = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const angleRad = this.angle * Math.PI / 180;
        const deg_sin = -Math.sin(angleRad);
        const deg_cos = -Math.cos(angleRad);

        const a1 = RAIL_LENGTH * this.URAIL_CNCT_R_RATIO * 0.5;
        const b1 = RAIL_LENGTH * this.URAIL_CNCT_R_RATIO * 0.2 * a;
        const d1 = RAIL_LENGTH * a * this.DOUBLE_TRACK_DISTANCE_RATIO;
        
        ctx.save();
        
        // 塗りつぶし部分（複線の間）
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + a1 * deg_sin + b1 * deg_cos, this.y - a1 * deg_cos + b1 * deg_sin);
        ctx.lineTo(this.x + a1 * deg_sin - (b1 + d1) * deg_cos, this.y - a1 * deg_cos - (b1 + d1) * deg_sin);
        ctx.lineTo(this.x - d1 * deg_cos, this.y - d1 * deg_sin);
        ctx.closePath();
        ctx.fill();

        ctx.restore();

        this._sync();
        
		this.components.slice(-1).forEach(c => c.drawWithWidth(14, this.color));
		
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.components.slice(0,3).forEach(c => c.drawWithWidth(14, 'black'));
            this.components.slice(0,3).forEach(c => c.drawWithWidth(12, this.color));
            this.components.slice(0,3).forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.components.slice(0,3).forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.components.slice(0,3).forEach(c => c.draw());
        }
    }


    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        const rev = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const angleRad = this.angle * Math.PI / 180;
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH * rev, 0 , angleRad);
      
        return [
            { x: this.x, y: this.y, angle: this.angle, id: `${this.id}-1`, type: 'concave' },
            { x: this.x + track1OffsetX, y: this.y + track1OffsetY, angle: this.angle , id: `${this.id}-3`, type: 'concave' }
        ];
    }
}


class Figure8PointRail {
    constructor(x, y, id, pointType = 'R', direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'R', 'R_REV', 'L', 'L_REV'
        this.direction = direction;   // 'left' or 'right'
        this.curves = [];
        this.color = COLORS.FIGURE8.base;
        this.highlightColor = COLORS.FIGURE8.highlight;
        
        // 端点構造の説明（実在製品に合わせた定義）:
        // L型: 起点(凹) → 1本目終点(凸) + 2本目終点(凹)
        //      起点から左右に分岐。1本目は接続元、2本目は接続先
        // R型: 起点(凹) → 1本目終点(凸) → 2本目終点(凸)
        //      1本目終点から180度反転して2本目。両方とも接続元
    }

    /* =========================
       内部構築
    ========================= */
    _buildCurves() {
        this.curves.length = 0;

        const base = this.angle;
        const dir = this.direction;
		const oppDir = (dir === 'left') ? 'right' : 'left';

        /* ===== L 系：起点共有・左右分岐（実在製品のL型） ===== */
        if (this.pointType === 'L') {

            // 左（または右）カーブ：凸
            const c1 = new Curve(this.x, this.y, this.id + '-A', dir);
            c1.angle = base ;
            c1.color = this.color;
            c1.highlightColor = this.highlightColor;

            // 反対側カーブ：凹（direction を反転）
            
            const c2 = new Curve(this.x, this.y, this.id + '-B', oppDir);
            c2.angle = base ;
            c2.color = this.color;
            c2.highlightColor = this.highlightColor;

            this.curves.push(c1, c2);
        }

        /* ===== R 系：1本目終点から折り返し（実在製品のR型） ===== */
        else {

            // 1本目：通常カーブ
            const c1 = new Curve(this.x, this.y, this.id + '-A', dir);
            c1.angle = base ;
            c1.color = this.color;
            c1.highlightColor = this.highlightColor;

            // 2本目：1本目終点から 180° 反転
            const ep = c1.getEndpoints()[1];

            const c2 = new Curve(ep.x, ep.y, this.id + '-B', dir);
            c2.angle = reversedegAngle(ep.angle) ;
            c2.color = this.color;
            c2.highlightColor = this.highlightColor;

            this.curves.push(c1, c2);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildCurves();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        
        if (useRealisticRendering) {
            // リアル描画（層ごと全体）
            this.curves.forEach(c => c.drawWithWidth(14, 'black'));
            this.curves.forEach(c => c.drawWithWidth(12, this.color));
            this.curves.forEach(c => c.drawWithWidth(6, this.highlightColor));
            this.curves.forEach(c => c.drawWithWidth(4, this.color));
        } else {
            // シンプル描画
            this.curves.forEach(c => c.draw());
        }
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.curves.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // L型の場合：起点共有・左右分岐（実在製品のL型）
        if (this.pointType === 'L') {
            // 1本目終点（凸）
            eps.push({
                ...this.curves[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凹）- L型は2本目が凹（接続を受ける側）
            const ep3 = this.curves[1].getEndpoints()[1];
            eps.push({
                x: ep3.x,
                y: ep3.y,
                angle: reversedegAngle(ep3.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        }
        // R型の場合：1本目終点から折り返し（実在製品のR型）
        else {
            // 1本目終点（凸）
            eps.push({
                ...this.curves[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凸）- R型は2本目も凸
            eps.push({
                ...this.curves[1].getEndpoints()[1],
                id: this.id + '-3',
                type: 'convex'
            });
        }

        return eps;
    }
}

    // ==========================================
    // ジョイント描画関数
    // ==========================================
    
    /**
     * ジョイントを描画（レール色対応・向き修正版）
     */
    function drawJoint(ctx, x, y, angle, head, railColor = 'deepskyblue') {
        const adjustedAngle = angle + 180;
        const deg_sin = Math.sin(adjustedAngle * Math.PI / 180.0);
        const deg_cos = Math.cos(adjustedAngle * Math.PI / 180.0);
        
        if (head) {
            ctx.fillStyle = railColor;
            ctx.beginPath();
            ctx.moveTo(x + JOINT_WIDTH * 0.5 * deg_cos, y + JOINT_WIDTH * 0.5 * deg_sin);
            ctx.lineTo(x + JOINT_WIDTH * 0.5 * deg_cos + JOINT_LENGTH * deg_sin, y + JOINT_WIDTH * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
            ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos + JOINT_LENGTH * deg_sin, y - JOINT_WIDTH * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
            ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos, y - JOINT_WIDTH * 0.5 * deg_sin);
            ctx.fill();
        }
        
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgb(0, 0, 0)';
        ctx.moveTo(x + RAIL_WIDTH * 0.5 * deg_cos, y + RAIL_WIDTH * 0.5 * deg_sin);
        ctx.lineTo(x + JOINT_WIDTH * 0.5 * deg_cos, y + JOINT_WIDTH * 0.5 * deg_sin);
        ctx.lineTo(x + JOINT_WIDTH * 0.5 * deg_cos + JOINT_LENGTH * deg_sin, y + JOINT_WIDTH * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
        ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos + JOINT_LENGTH * deg_sin, y - JOINT_WIDTH * 0.5 * deg_sin - JOINT_LENGTH * deg_cos);
        ctx.lineTo(x - JOINT_WIDTH * 0.5 * deg_cos, y - JOINT_WIDTH * 0.5 * deg_sin);
        ctx.lineTo(x - RAIL_WIDTH * 0.5 * deg_cos, y - RAIL_WIDTH * 0.5 * deg_sin);
        ctx.stroke();
    }
    
    /**
     * 単一レールのジョイントを描画
     */
    function drawRailEndpoints(rail) {
        if (!useDetailedEndpoints) return;
        
        const endpoints = rail.getEndpoints();
        const railColor = rail.color || 'deepskyblue';
        
        endpoints.forEach(endpoint => {
            // 端点タイプ判定（typeプロパティを優先）
            let isConvex;
            if (endpoint.type) {
                isConvex = endpoint.type === 'convex';
            } else {
                isConvex = endpoint.id.slice(-1) == '2' || endpoint.id.slice(-1) == '4';
            }
            
            drawJoint(ctx, endpoint.x, endpoint.y, endpoint.angle, isConvex, railColor);
        });
    }
    
    /**
     * シンプルモード用の全端点描画
     */
    function drawSimpleEndpoints() {
        const rootPoints = [];
        
        // 端点タイプ判定関数（typeプロパティを優先）
        const getEndpointType = (endpoint) => {
            if (endpoint.type) return endpoint.type;
            const lastChar = endpoint.id.slice(-1);
            const num = parseInt(lastChar);
            if (!isNaN(num)) {
                return num % 2 === 1 ? 'concave' : 'convex';
            }
            return null;
        };
        
        // 凸端点（接続する側）- 青色
        ctx.fillStyle = 'blue';
        rails.forEach(shape => {
            shape.getEndpoints().forEach(endpoint => {
                const epType = getEndpointType(endpoint);
                
                if (epType === 'convex') {
                    const pointAngleRad = endpoint.angle * Math.PI / 180;
                    ctx.beginPath();
                    ctx.arc(endpoint.x, endpoint.y, 4, pointAngleRad, pointAngleRad + Math.PI);
                    ctx.fill();
                } else if (epType === 'concave') {
                    rootPoints.push(endpoint);
                }
            });
        });
        
        // 凹端点（受け入れる側）- オレンジ色
        ctx.fillStyle = 'orange';
        rootPoints.forEach(rpoint => {
            const pointAngleRad = rpoint.angle * Math.PI / 180;
            ctx.beginPath();
            ctx.arc(rpoint.x, rpoint.y, 4, pointAngleRad + Math.PI, pointAngleRad + 2 * Math.PI);
            ctx.fill();
        });
    }

    function drawAll() {


	ctx.restore();ctx.save();
	ctx.setTransform(1,0,0,1,0,0);
//        ctx.clearRect(-canvasOffsetX/scale, -canvasOffsetY/scale, canvas.width/scale, canvas.height/scale);
	ctx.translate(0,canvas.height);
	ctx.translate(canvasOffsetX,- canvasOffsetY);
	//ctx.scale(1,-1);

	ctx.scale(scale,-scale);
      	
        ctx.clearRect(-canvasOffsetX/scale, -canvasOffsetY/scale, canvas.width/scale, canvas.height/scale);


       // ctx.save(); ctx.setTransform(scale, 0, 0, scale, canvasOffsetX, canvasOffsetY);
        
	//    

	// レールとジョイントの描画（描画順序修正版）
	if (useDetailedEndpoints) {
		// 詳細モード: レール描画直後にそのジョイントを描画
		rails.forEach(rail => {
			rail.draw();
			drawRailEndpoints(rail);
		});
	} else {
		// シンプルモード: 従来の方式
		rails.forEach(rail => rail.draw());
		drawSimpleEndpoints();
	}

	// 選択された端点を赤丸で強調表示
	if (selectedEndpoint) {
		ctx.strokeStyle = 'red';
		ctx.lineWidth = 3;
		ctx.beginPath();
		ctx.arc(selectedEndpoint.x, selectedEndpoint.y, 8, 0, Math.PI * 2);
		ctx.stroke();
	}

        ctx.restore();
    }


// ========================================
// グループ移動機能
// ========================================

let groupMoveEnabled = false;
let draggingGroup = null;

// 2つの端点が接続されているか判定（厳格な条件）
function areEndpointsConnected(ep1, ep2) {
    const dx = ep1.x - ep2.x;
    const dy = ep1.y - ep2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 距離チェック: 厳格に（2px以内）
    if (distance > 2) return false;
    
    // 端点タイプを取得（typeプロパティまたはIDから判定）
    // 奇数(1,3,5,7)=凹(concave)、偶数(2,4,6,8)=凸(convex)
    const getEndpointType = (ep) => {
        if (ep.type) return ep.type;
        const lastChar = ep.id.slice(-1);
        const num = parseInt(lastChar);
        if (!isNaN(num)) {
            return num % 2 === 1 ? 'concave' : 'convex';
        }
        return null;
    };
    
    const ep1Type = getEndpointType(ep1);
    const ep2Type = getEndpointType(ep2);
    
    // 凹と凸のペアでなければ接続しない
    const validPair = (ep1Type === 'concave' && ep2Type === 'convex') || 
                      (ep1Type === 'convex' && ep2Type === 'concave');
    if (!validPair) return false;
    
    // 角度差を計算
    let angleDiff = Math.abs(ep1.angle - ep2.angle);
    angleDiff = angleDiff % 360;
    if (angleDiff > 180) angleDiff = 360 - angleDiff;
    
    // 角度が同じ（0度±5度）なら接続
    const sameDirection = angleDiff < 5;
    return sameDirection;
}

// 2つの端点がスナップ可能か判定（緩い条件）
function canSnapEndpoints(ep1, ep2) {
    const dx = ep1.x - ep2.x;
    const dy = ep1.y - ep2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 距離チェック: 20px以内
    if (distance > 20) return false;
    
    // 端点タイプを取得
    const getEndpointType = (ep) => {
        if (ep.type) return ep.type;
        const lastChar = ep.id.slice(-1);
        const num = parseInt(lastChar);
        if (!isNaN(num)) {
            return num % 2 === 1 ? 'concave' : 'convex';
        }
        return null;
    };
    
    const ep1Type = getEndpointType(ep1);
    const ep2Type = getEndpointType(ep2);
    
    // 凹と凸のペアでなければスナップ不可
    const validPair = (ep1Type === 'concave' && ep2Type === 'convex') || 
                      (ep1Type === 'convex' && ep2Type === 'concave');
    if (!validPair) return false;
    
    // 角度差を計算
    let angleDiff = Math.abs(ep1.angle - ep2.angle);
    angleDiff = angleDiff % 360;
    if (angleDiff > 180) angleDiff = 360 - angleDiff;
    
    // -90度～+90度以内（90度未満）ならスナップ可能
    const validAngle = angleDiff < 90;
    return validAngle;
}

// 特定の端点が他のレールと接続済みかチェック
function isEndpointConnected(rail, endpointId) {
    const targetEndpoint = rail.getEndpoints().find(ep => ep.id === endpointId);
    if (!targetEndpoint) return false;
    
    // 他のレールの全端点をチェック
    for (const otherRail of rails) {
        if (otherRail === rail) continue;
        
        const otherEndpoints = otherRail.getEndpoints();
        for (const otherEp of otherEndpoints) {
            // 厳格な接続判定を使用
            if (areEndpointsConnected(targetEndpoint, otherEp)) {
                return true;  // 接続済み
            }
        }
    }
    return false;  // 未接続
}

// 接続されているレール群を検出
function findConnectedGroup(startRail) {
    const connected = new Set();
    const queue = [startRail];
    connected.add(startRail);
    
    while (queue.length > 0) {
        const current = queue.shift();
        const currentEndpoints = current.getEndpoints();
        
        // 全レールをチェック
        rails.forEach(other => {
            if (connected.has(other)) return;
            
            const otherEndpoints = other.getEndpoints();
            
            // 端点同士が接続されているかチェック
            for (const ep1 of currentEndpoints) {
                for (const ep2 of otherEndpoints) {
                    if (areEndpointsConnected(ep1, ep2)) {
                        connected.add(other);
                        queue.push(other);
                        return;
                    }
                }
            }
        });
    }
    
    return Array.from(connected);
}

// グループ全体を移動
function moveGroup(group, dx, dy) {
    group.forEach(rail => {
        rail.x += dx;
        rail.y += dy;
    });
}

// グリップ位置に基づいてインテリジェントにグループを検出
function findGroupByGripPosition(rail, gripX, gripY) {
    const endpoints = rail.getEndpoints();
    
    // 各端点からグリップ位置までの距離を計算
    let closestEndpoint = null;
    let closestDistance = Infinity;
    
    endpoints.forEach(ep => {
        const dx = gripX - ep.x;
        const dy = gripY - ep.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
            closestDistance = distance;
            closestEndpoint = ep;
        }
    });
    
    // グリップ位置による判定
    if (closestDistance <= 20) {
        // 20px以内: ジョイント近く → この端点で切断して反対側のみ移動
        if (isNeedJointConsole) console.log('Grip near endpoint:', closestEndpoint.id, 'distance:', closestDistance.toFixed(1));
        return findGroupExcludingEndpoint(rail, closestEndpoint);
    } else if (closestDistance >= 24) {
        // 24px以遠: レール中央 → 全グループ移動
        if (isNeedJointConsole) console.log('Grip at center, full group move');
        return findConnectedGroup(rail);
    } else {
        // 20-23px: デッドゾーン → 単独移動
        if (isNeedJointConsole) console.log('Grip in dead zone (20-23px), single rail move');
        return null;
    }
}

// 特定の端点を除外してグループを検出（複線レールのペア接続を考慮）
function findGroupExcludingEndpoint(startRail, excludeEndpoint) {
    // まず、除外する端点に接続しているレールを特定
    let excludedRails = new Set();
    
    // 複線レールの場合、ペアになっている端点も一緒に除外する必要がある
    let excludeEndpointIds = [excludeEndpoint.id];
    
    if (startRail.isDoubleTrack && startRail.endpointPairs) {
        // 除外する端点の番号を取得
        const excludeNum = parseInt(excludeEndpoint.id.slice(-1));
        
        // このendpointPairs内に含まれていれば、ペア全体を除外
        startRail.endpointPairs.forEach(pair => {
            if (pair.includes(excludeNum)) {
                // このペアの全端点を除外リストに追加
                pair.forEach(num => {
                    excludeEndpointIds.push(`${startRail.id}-${num}`);
                });
                if (isNeedJointConsole) console.log('Double track detected, excluding pair:', pair);
            }
        });
    }
    
    if (isNeedJointConsole) console.log('Excluding endpoints:', excludeEndpointIds);
    
    // 除外する端点群に接続している全レールを特定
    const allStartEndpoints = startRail.getEndpoints();
    allStartEndpoints.forEach(startEp => {
        if (excludeEndpointIds.includes(startEp.id)) {
            // この端点に接続しているレールを探す
            rails.forEach(other => {
                if (other === startRail) return;
                
                const otherEndpoints = other.getEndpoints();
                for (const otherEp of otherEndpoints) {
                    if (areEndpointsConnected(startEp, otherEp)) {
                        excludedRails.add(other);
                        if (isNeedJointConsole) console.log('Excluding rail:', other.id, 'connected via', startEp.id, '-', otherEp.id);
                    }
                }
            });
        }
    });
    
    if (isNeedJointConsole) console.log('Total excluded rails:', excludedRails.size);
    
    // グループ検出（除外するレール群との接続は全て無視）
    const connected = new Set();
    const queue = [startRail];
    connected.add(startRail);
    
    while (queue.length > 0) {
        const current = queue.shift();
        const currentEndpoints = current.getEndpoints();
        
        // 全レールをチェック
        rails.forEach(other => {
            if (connected.has(other)) return;
            
            // 除外するレールへの接続はスキップ
            if (excludedRails.has(other)) {
                return;
            }
            
            const otherEndpoints = other.getEndpoints();
            
            // 端点同士が接続されているかチェック
            for (const ep1 of currentEndpoints) {
                // startRailの除外端点群はスキップ
                if (current === startRail && excludeEndpointIds.includes(ep1.id)) {
                    continue;
                }
                
                for (const ep2 of otherEndpoints) {
                    if (areEndpointsConnected(ep1, ep2)) {
                        connected.add(other);
                        queue.push(other);
                        return;
                    }
                }
            }
        });
    }
    
    return Array.from(connected);
}

// グループ全体を回転
function rotateGroup(group, centerX, centerY, angleDelta) {
    const angleRad = angleDelta * Math.PI / 180;
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);
    
    group.forEach(rail => {
        // 中心からの相対位置を計算
        const dx = rail.x - centerX;
        const dy = rail.y - centerY;
        
        // 回転後の位置を計算
        const newDx = dx * cos - dy * sin;
        const newDy = dx * sin + dy * cos;
        
        // 新しい位置を設定
        rail.x = centerX + newDx;
        rail.y = centerY + newDy;
        
        // レール自体の角度も回転
        rail.angle += angleDelta;
    });
}

// グループ全体をスナップ
function snapGroupToClosestEndpoint(group, draggedRail) {
    // グループ内の全端点を取得
    let allEndpoints = [];
    group.forEach(rail => {
        const endpoints = rail.getEndpoints();
        endpoints.forEach(ep => {
            allEndpoints.push({ rail: rail, endpoint: ep });
        });
    });
    
    // グループ外のレールの全端点を取得
    let externalEndpoints = [];
    rails.forEach(rail => {
        if (!group.includes(rail)) {
            const endpoints = rail.getEndpoints();
            endpoints.forEach(ep => {
                externalEndpoints.push({ rail: rail, endpoint: ep });
            });
        }
    });
    
    // 最も近い端点ペアを見つける
    let closestPair = null;
    let closestDistance = Infinity;
    
    allEndpoints.forEach(groupEp => {
        externalEndpoints.forEach(extEp => {
            // 両端点が未接続かチェック
            if (isEndpointConnected(groupEp.rail, groupEp.endpoint.id)) return;
            if (isEndpointConnected(extEp.rail, extEp.endpoint.id)) return;
            
            // スナップ可能かチェック
            if (!canSnapEndpoints(groupEp.endpoint, extEp.endpoint)) return;
            
            const dx = groupEp.endpoint.x - extEp.endpoint.x;
            const dy = groupEp.endpoint.y - extEp.endpoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestPair = {
                    groupEndpoint: groupEp,
                    externalEndpoint: extEp
                };
            }
        });
    });
    
    // スナップ実行
    if (closestPair) {
        const groupEp = closestPair.groupEndpoint.endpoint;
        const extEp = closestPair.externalEndpoint.endpoint;
        
        // 1. まず角度を合わせる（グループの掴んでいるレールを中心に回転）
        const angleDiff = extEp.angle - groupEp.angle;
        rotateGroup(group, draggedRail.x, draggedRail.y, angleDiff);
        
        // 2. 回転後の端点位置を再計算
        const updatedGroupEndpoints = closestPair.groupEndpoint.rail.getEndpoints();
        const updatedGroupEp = updatedGroupEndpoints.find(ep => ep.id === groupEp.id);
        
        // 3. 位置を合わせる（平行移動）
        const dx = extEp.x - updatedGroupEp.x;
        const dy = extEp.y - updatedGroupEp.y;
        moveGroup(group, dx, dy);
        
        return true; // スナップした
    }
    
    return false; // スナップしなかった
}

// レールを指定点を中心に回転（グループ移動と共通化）
function rotateRailAroundPoint(rail, centerX, centerY, angleDelta) {
    const angleRad = angleDelta * Math.PI / 180;
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);
    
    // 中心からの相対位置
    const dx = rail.x - centerX;
    const dy = rail.y - centerY;
    
    // 回転後の位置
    const newDx = dx * cos - dy * sin;
    const newDy = dx * sin + dy * cos;
    
    rail.x = centerX + newDx;
    rail.y = centerY + newDy;
    rail.angle += angleDelta;
}

function snapToClosestEndpoint(shape) {
    const endpoints = shape.getEndpoints();
    let closestEndpoint = null;
    let closestDistance = Infinity;

    rails.forEach(otherShape => {
        if (otherShape !== shape) {
            otherShape.getEndpoints().forEach(endpoint => {
                endpoints.forEach(shapeEndpoint => {
                    // 両端点が未接続かチェック
                    if (isEndpointConnected(shape, shapeEndpoint.id)) return;
                    if (isEndpointConnected(otherShape, endpoint.id)) return;
                    
                    // スナップ可能かチェック（緩い条件: 20px, -90～+90度）
                    if (!canSnapEndpoints(shapeEndpoint, endpoint)) return;
                    
                    const dx = shapeEndpoint.x - endpoint.x;
                    const dy = shapeEndpoint.y - endpoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEndpoint = { shape: otherShape, endpoint, shapeEndpoint };
                    }
                });
            });
        }
    });

    if (closestEndpoint) {
        // 角度を合わせる
        const angleDiff = closestEndpoint.endpoint.angle - closestEndpoint.shapeEndpoint.angle;
        shape.angle += angleDiff;

        // 再度端点を計算
        const newEndpoints = shape.getEndpoints();
        const newEndpoint = newEndpoints.find(ep => ep.id === closestEndpoint.shapeEndpoint.id);

        // 位置を合わせる
        const dx = closestEndpoint.endpoint.x - newEndpoint.x;
        const dy = closestEndpoint.endpoint.y - newEndpoint.y;
        shape.x += dx;
        shape.y += dy;
    }
}

    canvas.addEventListener('mousedown', (e) => {
      //  console.log('Screen: x=' + e.offsetX + ', y=' + e.offsetY);
        const world = screenToWorld(e.offsetX, e.offsetY);
     //   console.log('World: x=' + world.x.toFixed(2) + ', y=' + world.y.toFixed(2));
        
        dragging = null;
        draggingGroup = null;
        selectedShape = null;

        rails.forEach(rect => {
            if (rect.contains(world.x, world.y)) {
                dragging = rect;
                selectedShape = rect;
                offsetX = world.x - rect.x;
                offsetY = world.y - rect.y;
                
                // レール移動開始時は選択端点をクリア
                selectedEndpoint = null;
                
                // グループ移動モードならグリップ位置に基づいて接続グループを検出
                if (groupMoveEnabled) {
                    draggingGroup = findGroupByGripPosition(rect, world.x, world.y);
                }
            }
        });

        if (!dragging) {
            isPanning = true;
            startX = e.offsetX;
            startY = e.offsetY;
        }
    });

    // クリックイベント: 端点選択（レール追加の進行方向変更）
    canvas.addEventListener('click', (e) => {
        // ドラッグしていた場合はスキップ
        if (dragging || isPanning) return;
        
        const world = screenToWorld(e.offsetX, e.offsetY);
        
        // 端点をクリックして進行方向を変更
        if (selectEndpointForProgression(world.x, world.y)) {
            if (isNeedJointConsole) console.log('Endpoint selected for rail progression');
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (dragging) {
            const world = screenToWorld(e.offsetX, e.offsetY);
            const newX = world.x - offsetX;
            const newY = world.y - offsetY;
            
            if (draggingGroup) {
                // グループ移動: 相対移動量を計算
                const dx = newX - dragging.x;
                const dy = newY - dragging.y;
                moveGroup(draggingGroup, dx, dy);
            } else {
                // 単独移動
                dragging.x = newX;
                dragging.y = newY;
            }
            drawAll();
        } else if (isPanning) {
            // Canvas表示サイズと内部解像度の比率を取得
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // offsetXを内部座標に変換してから差分を計算
            const dx = (e.offsetX - startX) * scaleX;
            const dy = (e.offsetY - startY) * scaleY;
            
            canvasOffsetX += dx;
            canvasOffsetY -= dy;
            
            // 次回のために現在の位置を保存
            startX = e.offsetX;
            startY = e.offsetY;
            drawAll();
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (dragging) {
            if (draggingGroup) {
                // グループ移動の場合、グループ全体をスナップ
                snapGroupToClosestEndpoint(draggingGroup, dragging);
            } else {
                // 単独移動の場合のみスナップ
                snapToClosestEndpoint(dragging);
            }
	    LastselectedShape = dragging;
            dragging = null;
            draggingGroup = null;
        }
        isPanning = false;
        drawAll();
    });

    // ========================================
    // タッチイベントのサポート
    // ========================================
    
    function getTouchPos(canvas, touchEvent) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: touchEvent.touches[0].clientX - rect.left,
            y: touchEvent.touches[0].clientY - rect.top
        };
    }

    let lastTouchTime = 0;
    let touchStartPos = null;
    let lastTouchDistance = 0;

    canvas.addEventListener('touchstart', (e) => {
        // ピンチズーム開始（2本指）
        if (e.touches.length === 2) {
            e.preventDefault();
            isPanning = false;
            dragging = null;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            lastTouchDistance = Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) +
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            return;
        }
        
        // 1本指タッチ
        if (e.touches.length === 1) {
            e.preventDefault();
            const touch = getTouchPos(canvas, e);
            const world = screenToWorld(touch.x, touch.y);
            
            // ダブルタップ検出
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTouchTime;
            if (tapLength < 300 && tapLength > 0) {
                // ダブルタップ: 削除
                rails.forEach((rect, index) => {
                    if (rect.contains(world.x, world.y)) {
                        rails.splice(index, 1);
                        drawAll();
                    }
                });
                lastTouchTime = 0;
                return;
            }
            lastTouchTime = currentTime;
            
            // シングルタップ: ドラッグ開始またはパン開始
            touchStartPos = {x: touch.x, y: touch.y};
            dragging = null;
            draggingGroup = null;
            selectedShape = null;

            rails.forEach(rect => {
                if (rect.contains(world.x, world.y)) {
                    dragging = rect;
                    selectedShape = rect;
                    offsetX = world.x - rect.x;
                    offsetY = world.y - rect.y;
                    
                    // レール移動開始時は選択端点をクリア
                    selectedEndpoint = null;
                    
                    // グループ移動モードならグリップ位置に基づいて接続グループを検出
                    if (groupMoveEnabled) {
                        draggingGroup = findGroupByGripPosition(rect, world.x, world.y);
                    }
                }
            });

            if (!dragging) {
                isPanning = true;
                startX = touch.x;
                startY = touch.y;
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        
        // ピンチズーム（2本指）
        if (e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) +
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            
            if (lastTouchDistance > 0) {
                const delta = currentDistance - lastTouchDistance;
                if (delta > 0) {
                    scale *= 1.02;
                } else {
                    scale /= 1.02;
                }
                drawAll();
            }
            lastTouchDistance = currentDistance;
            return;
        }
        
        // 1本指ドラッグ/パン
        if (e.touches.length === 1) {
            const touch = getTouchPos(canvas, e);
            
            if (dragging) {
                const world = screenToWorld(touch.x, touch.y);
                const newX = world.x - offsetX;
                const newY = world.y - offsetY;
                
                if (draggingGroup) {
                    // グループ移動: 相対移動量を計算
                    const dx = newX - dragging.x;
                    const dy = newY - dragging.y;
                    moveGroup(draggingGroup, dx, dy);
                } else {
                    // 単独移動
                    dragging.x = newX;
                    dragging.y = newY;
                }
                drawAll();
            } else if (isPanning) {
                // Canvas表示サイズと内部解像度の比率を取得
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // touchPosを内部座標に変換してから差分を計算
                const dx = (touch.x - startX) * scaleX;
                const dy = (touch.y - startY) * scaleY;
                
                canvasOffsetX += dx;
                canvasOffsetY -= dy;
                startX = touch.x;
                startY = touch.y;
                drawAll();
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        
        // ピンチズーム終了
        if (e.touches.length < 2) {
            lastTouchDistance = 0;
        }
        
        // タッチ終了時の処理（1本指→0本指）
        if (e.touches.length === 0) {
            // 長押し検出（コンテキストメニュー表示）
            if (touchStartPos && selectedShape) {
                const touch = e.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const endX = touch.clientX - rect.left;
                const endY = touch.clientY - rect.top;
                const distance = Math.sqrt(
                    Math.pow(endX - touchStartPos.x, 2) + 
                    Math.pow(endY - touchStartPos.y, 2)
                );
                
                // ほとんど動いていない場合
                if (distance < 10) {
                    // 端点選択を試みる（タップ）
                    const rect = canvas.getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    const world = screenToWorld(touchX, touchY);
                    
                    if (selectEndpointForProgression(world.x, world.y)) {
                        if (isNeedJointConsole) console.log('Endpoint selected via touch');
                    } else {
                        // 端点が見つからない場合、コンテキストメニュー
                        const menu = document.getElementById('contextMenu');
                        menu.style.left = `${touch.clientX}px`;
                        menu.style.top = `${touch.clientY}px`;
                        menu.style.display = 'block';
                    }
                }
            }
            
            if (dragging) {
                if (draggingGroup) {
                    // グループ移動の場合、グループ全体をスナップ
                    snapGroupToClosestEndpoint(draggingGroup, dragging);
                } else {
                    // 単独移動の場合のみスナップ
                    snapToClosestEndpoint(dragging);
                }
                LastselectedShape = dragging;
                dragging = null;
                draggingGroup = null;
            }
            isPanning = false;
            touchStartPos = null;
            drawAll();
        }
    }, {passive: false});

        canvas.addEventListener('dblclick', (e) => {
        const world = screenToWorld(e.offsetX, e.offsetY);

            rails.forEach((rect, index) => {
                if (rect.contains(world.x, world.y)) {
                    rails.splice(index, 1);
                    drawAll();
                }
            });


        });

 canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    
    // マウス位置（スクリーン座標）
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;
    
    // ズーム前のマウス位置（ワールド座標）
    const worldBeforeZoom = screenToWorld(mouseX, mouseY);
    
    // ズーム実行
    const oldScale = scale;
    if (e.deltaY < 0) {
        // ズームイン
        scale *= scaleFactor;
    } else {
        // ズームアウト
        scale /= scaleFactor;
    }
    
    // ズーム後のマウス位置（ワールド座標）を計算
    // スクリーン座標からワールド座標への変換式:
    // worldX = (screenX - canvasOffsetX) / scale
    // worldY = (canvH - screenY - canvasOffsetY) / scale
    //
    // ズーム前後でマウス位置のワールド座標を一致させるため、
    // canvasOffsetを調整する
    const worldAfterZoom = screenToWorld(mouseX, mouseY);
    
    // ワールド座標のズレを補正（符号を逆転）
    const worldDeltaX = worldAfterZoom.x - worldBeforeZoom.x;
    const worldDeltaY = worldAfterZoom.y - worldBeforeZoom.y;
    
    // オフセットを調整してズレを補正
    canvasOffsetX += worldDeltaX * scale;
    canvasOffsetY += worldDeltaY * scale;
    
    drawAll();
});




// ==========================================
// タッチメニュー修正コード（v37.1用）
// ==========================================
//
// 手順:
// 1. 既存のcontextmenuイベントリスナーを置き換え
// 2. documentのclickリスナーを置き換え
// 3. 新しいタッチイベントリスナーを追加
//
// ==========================================

// ===== 共通関数 =====

// メニューを閉じる
function closeContextMenu() {
    document.getElementById('contextMenu').style.display = 'none';
}

// メニューを表示
function showContextMenu(pageX, pageY, offsetX, offsetY) {
    const world = screenToWorld(offsetX, offsetY);
    
    selectedShape = null;
    rails.forEach(rect => {
        if (rect.contains(world.x, world.y)) {
            selectedShape = rect;
        }
    });
    
    if (selectedShape) {
        const menu = document.getElementById('contextMenu');
        menu.style.left = `${pageX}px`;
        menu.style.top = `${pageY}px`;
        menu.style.display = 'block';
    }
}

// ===== イベントリスナー =====

// 右クリックでメニュー表示（マウス）
canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    showContextMenu(e.pageX, e.pageY, e.offsetX, e.offsetY);
});

// 長押しでメニュー表示（タッチデバイス）
let longPressTimer = null;
let longPressStartX = 0;
let longPressStartY = 0;

canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        longPressStartX = touch.clientX;
        longPressStartY = touch.clientY;
        
        // 座標を事前にキャプチャ（グローバル変数として保存）
        const savedPageX = touch.pageX;
        const savedPageY = touch.pageY;
        const savedOffsetX = touch.clientX - rect.left;
        const savedOffsetY = touch.clientY - rect.top;
        
        longPressTimer = setTimeout(() => {
            // 500ms後、移動していなければメニュー表示
            showContextMenu(savedPageX, savedPageY, savedOffsetX, savedOffsetY);
            longPressTimer = null;
        }, 500); // 500ms長押し
    }
});

canvas.addEventListener('touchend', () => {
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
});

canvas.addEventListener('touchmove', (e) => {
    // 移動したら長押しキャンセル
    if (longPressTimer) {
        const touch = e.touches[0];
        const moved = Math.abs(touch.clientX - longPressStartX) > 10 || 
                     Math.abs(touch.clientY - longPressStartY) > 10;
        if (moved) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }
});

// メニュー外クリック/タッチで閉じる
document.addEventListener('click', (e) => {
    const menu = document.getElementById('contextMenu');
    if (!menu.contains(e.target)) {
        closeContextMenu();
    }
});

document.addEventListener('touchstart', (e) => {
    const menu = document.getElementById('contextMenu');
    // メニューの外をタッチした場合のみ閉じる
    if (menu.style.display === 'block' && !menu.contains(e.target)) {
        closeContextMenu();
    }
});

// ===== 置き換え対象（削除する既存コード） =====
/*
削除する既存コード:

// 既存のcontextmenuリスナー（3421行目付近）
canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const world = screenToWorld(e.offsetX, e.offsetY);
    selectedShape = null;
    rails.forEach(rect => {
        if (rect.contains(world.x, world.y)) {
            selectedShape = rect;
        }
    });
    if (selectedShape) {
        const menu = document.getElementById('contextMenu');
        menu.style.left = `${e.pageX}px`;
        menu.style.top = `${e.pageY}px`;
        menu.style.display = 'block';
    }
});

// 既存のdocument clickリスナー（3559行目付近）
document.addEventListener('click', () => {
    document.getElementById('contextMenu').style.display = 'none';
});
*/

// ==========================================
// 補足：メニューボタンのイベントリスナー修正
// ==========================================
//
// 各メニューボタンのリスナーも closeContextMenu() を使用するように修正
//

document.getElementById('rotateRight').addEventListener('click', () => {
    if (selectedShape) {
        selectedShape.angle -= 45;
        drawAll();
        closeContextMenu();
    }
});

document.getElementById('rotateLeft').addEventListener('click', () => {
    if (selectedShape) {
        selectedShape.angle += 45;
        drawAll();
        closeContextMenu();
    }
});

document.getElementById('duplicate').addEventListener('click', () => {
    if (selectedShape) {
        if (selectedShape instanceof Rect) {
            const newRect = new Rect(selectedShape.x + 100, selectedShape.y + 100, `S${rails.length + 1}`);
            newRect.angle = selectedShape.angle;
            rails.push(newRect);
        } else if (selectedShape instanceof Curve) {
            const newRect = new Curve(selectedShape.x + 100, selectedShape.y + 100, `L${rails.length + 1}`);
            newRect.angle = selectedShape.angle;
            rails.push(newRect);
        }
        drawAll();
        closeContextMenu();
    }
});

document.getElementById('delete').addEventListener('click', () => {
    if (selectedShape) {
        const index = rails.indexOf(selectedShape);
        if (index > -1) {
            rails.splice(index, 1);
        }
        drawAll();
        closeContextMenu();
    }
});
        // タイプ切替 (R/L, A/B)
        document.getElementById('toggleType').addEventListener('click', () => {
            if (selectedShape) {
                // ターンアウトのR/L切替
                if (selectedShape.turnoutType) {
                    selectedShape.turnoutType = selectedShape.turnoutType === 'R' ? 'L' : 'R';
                }
                // R-13ポイントのA/B切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'R13PointRail') {
                    selectedShape.pointType = selectedShape.pointType === 'A' ? 'B' : 'A';
                }
                // R-22 Y字ポイントのA/B切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'R22YPointRail') {
                    selectedShape.pointType = selectedShape.pointType === 'A' ? 'B' : 'A';
                }
                // R-15複線幅広ポイントのA/B切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'R15WidePointRail') {
                    selectedShape.pointType = selectedShape.pointType === 'A' ? 'B' : 'A';
                }
                // R-17三方向ポイントのA/B切替
                else if (selectedShape.ThreewayType && selectedShape.constructor.name === 'R17ThreewayRail') {
                    selectedShape.ThreewayType = selectedShape.ThreewayType === 'A' ? 'B' : 'A';
                }
                // 8の字ポイントのR/L切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'Figure8PointRail') {
                    if (selectedShape.pointType === 'R') selectedShape.pointType = 'L';
                    else if (selectedShape.pointType === 'L') selectedShape.pointType = 'R';
                    else if (selectedShape.pointType === 'R_REV') selectedShape.pointType = 'L_REV';
                    else if (selectedShape.pointType === 'L_REV') selectedShape.pointType = 'R_REV';
                }
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        // 方向反転 (裏/表、左/右)
        document.getElementById('toggleDirection').addEventListener('click', () => {
            if (selectedShape) {
                if (selectedShape.direction) {
                    selectedShape.direction = selectedShape.direction === 'left' ? 'right' : 'left';
                }
                // スライドレールの方向反転
                if (selectedShape.slide !== undefined) {
                    selectedShape.slide = -selectedShape.slide;
                }
                // R-15複線幅広ポイントの裏タイプ切替
                if (selectedShape.isReversed !== undefined) {
                    selectedShape.isReversed = !selectedShape.isReversed;
                }
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        // 端点切替 (凹凸/凸凸/凹凹)
        document.getElementById('toggleEndpoints').addEventListener('click', () => {
            if (selectedShape && selectedShape.constructor.name === 'StraightRail') {
                // 現在の状態を判定
                const current = `${selectedShape.startType}-${selectedShape.endType}`;
                
                // 凹凸 → 凹凹 → 凸凸 → 凹凸 の順で切り替え
                if (current === 'concave-convex') {
                    selectedShape.startType = 'concave';
                    selectedShape.endType = 'concave';
                } else if (current === 'concave-concave') {
                    selectedShape.startType = 'convex';
                    selectedShape.endType = 'convex';
                } else {
                    selectedShape.startType = 'concave';
                    selectedShape.endType = 'convex';
                }
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.addEventListener('click', () => {
            document.getElementById('contextMenu').style.display = 'none';
        });


// 最後に置いたレールの端点を取得する関数
// 最後に配置したレールの端点を取得する関数
// レール追加の進行方向を管理
let railProgression = {
    rail: null,           // 最後に選択されたレール
    endpointIndex: 1,     // 使用する端点のインデックス（デフォルト1=第2端点）
    isReversed: false     // 逆方向フラグ（凹進行か凸進行か）
};

// 端点をクリック/タップして進行方向を変更
function selectEndpointForProgression(x, y) {
    let closestEndpoint = null;
    let closestDistance = Infinity;
    let closestRail = null;
    let closestIndex = -1;
    
    rails.forEach(rail => {
        const endpoints = rail.getEndpoints();
        endpoints.forEach((ep, index) => {
            const dx = x - ep.x;
            const dy = y - ep.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < closestDistance && distance < 15) { // 15px以内
                closestDistance = distance;
                closestEndpoint = ep;
                closestRail = rail;
                closestIndex = index;
            }
        });
    });
    
    if (closestEndpoint) {
        railProgression.rail = closestRail;
        railProgression.endpointIndex = closestIndex;
        
        // 端点タイプから進行方向を判定
        const getEndpointType = (ep) => {
            if (ep.type) return ep.type;
            const lastChar = ep.id.slice(-1);
            const num = parseInt(lastChar);
            if (!isNaN(num)) {
                return num % 2 === 1 ? 'concave' : 'convex';
            }
            return null;
        };
        
        const epType = getEndpointType(closestEndpoint);
        railProgression.isReversed = (epType === 'concave'); // 凹なら逆方向
        
        if (isNeedJointConsole) console.log('Selected endpoint:', closestEndpoint.id, 'type:', epType, 'reversed:', railProgression.isReversed);
        
        // 選択端点を保存（次の操作まで表示し続ける）
        selectedEndpoint = closestEndpoint;
        drawAll();
        
        return true;
    }
    
    return false;
}

function getLastEndpoint() {
    if (rails.length === 0) return {x: 0, y: 0, angle: 0, type: 'convex'};
    
    let targetRail = railProgression.rail || LastselectedShape || rails.slice(-1)[0];
    const endpoints = targetRail.getEndpoints();
    
    // 指定されたインデックスの端点を取得
    let endpoint = endpoints[railProgression.endpointIndex] || endpoints[endpoints.length - 1];
    
    if (isNeedJointConsole) console.log('getLastEndpoint: rail=', targetRail.id, 'endpointIndex=', railProgression.endpointIndex, 
                'isReversed=', railProgression.isReversed, 'endpoint=', endpoint.id);
    
    // 凹端点を選択した場合（逆方向フラグが立っている）
    if (railProgression.isReversed) {
        // 凹進行では eps[0] (凹) の位置と角度をそのまま使用
        // 新レールの eps[1] (凸) を eps[0] (凹) に接続する
        
        if (isNeedJointConsole) console.log('Reversed (concave selected): endpoint angle=', endpoint.angle, 'placeFromEnd=true');
        
        // 端点情報を返す + placeFromEnd フラグ
        return {
            x: endpoint.x,
            y: endpoint.y,
            angle: endpoint.angle,  // eps[0]の角度をそのまま使用
            id: endpoint.id,
            type: endpoint.type,
            placeFromEnd: true
        };
    }
    
    // 通常の場合
    return {
        x: endpoint.x,
        y: endpoint.y,
        angle: endpoint.angle,
        id: endpoint.id,
        type: endpoint.type,
        placeFromEnd: false
    };
}

// レール配置位置の調整（凹端点から配置する場合）
function adjustRailPlacement(rail, lastEndpoint) {
    if (!lastEndpoint.placeFromEnd) {
        return; // 通常配置
    }
    
    if (isNeedJointConsole) console.log('=== Adjusting placement for concave connection ===');
    
    // 角度を0-360度に正規化
    const normalizedAngle = ((lastEndpoint.angle % 360) + 360) % 360;
    if (isNeedJointConsole) console.log('Target concave endpoint:', lastEndpoint.id, 'at (', lastEndpoint.x.toFixed(1), ',', lastEndpoint.y.toFixed(1), ') angle=', normalizedAngle);
    
    // Step 1: レールを180度反転
    const reversedAngle = (normalizedAngle + 180) % 360;
    rail.angle = reversedAngle;
    if (isNeedJointConsole) console.log('Step 1: Reversed rail angle to', reversedAngle, '(concave angle + 180)');
    
    // Step 2: 接続すべき端点を決定
    // ⚠️ 重要: rail.angle設定後にgetEndpoints()を呼ぶ（実際の長さ・角度で端点計算）
    let railEndpoints = rail.getEndpoints();
    let endPoint;
    
    // 【原則】凹進行時は常にeps[1]（ID-2、主要凸端点）を目標に配置
    // 
    // 【例外処理】以下のレールのみ特殊な端点を使用:
    
    // 例外1: ターンアウトL、8の字L、R15A、単複Bは終点3が凹なので、終点2（直線凸）を使用
    const needsEndpoint2 = (
        (rail.constructor.name === 'TurnoutRail' && rail.turnoutType === 'L') ||
        (rail.constructor.name === 'Figure8PointRail' && (rail.pointType === 'L' || rail.pointType === 'L_REV')) ||
        (rail.constructor.name === 'R15WidePointRail' && rail.pointType === 'A') ||
        (rail.constructor.name === 'R13PointRail' && rail.pointType === 'B')
    );
    
    // 例外2: Uターンレールは両端が凹で同じ角度なので、endpoint 1を目標に配置
    const isUTurn = rail.constructor.name === 'UTurnRail';
    
    if (isUTurn) {
        // Uターン: もう一方の凹を使用
        endPoint = railEndpoints[1]; // endpoint 1 (もう一方の凹)
        if (isNeedJointConsole) console.log('Step 2: UTurn - using endpoint 1 (other concave) at (', endPoint.x.toFixed(1), ',', endPoint.y.toFixed(1), ') angle=', endPoint.angle);
    } else if (needsEndpoint2 && railEndpoints.length >= 2) {
        // 特定ポイントレール: 直線凸を使用
        endPoint = railEndpoints[1]; // endpoint 2 (index 1, 直線凸)
        if (isNeedJointConsole) console.log('Step 2: Using endpoint 2 (straight convex) at (', endPoint.x.toFixed(1), ',', endPoint.y.toFixed(1), ') angle=', endPoint.angle);
    } else if (railEndpoints.length >= 2) {
        // 【原則】eps[1]（ID-2、主要凸端点）を使用
        endPoint = railEndpoints[1]; // endpoint 2 (index 1)
        if (isNeedJointConsole) console.log('Step 2: Using endpoint 2 (principle: ID-2) at (', endPoint.x.toFixed(1), ',', endPoint.y.toFixed(1), ') angle=', endPoint.angle);
    } else {
        // 端点が1つしかない場合（通常ありえない）
        endPoint = railEndpoints[0];
        if (isNeedJointConsole) console.log('Step 2: Only one endpoint available at (', endPoint.x.toFixed(1), ',', endPoint.y.toFixed(1), ') angle=', endPoint.angle);
    }
    
    // Step 3: 終点を目標位置（選択された凹端点）に移動
    const dx = lastEndpoint.x - endPoint.x;
    const dy = lastEndpoint.y - endPoint.y;
    rail.x += dx;
    rail.y += dy;
    console.log('Step 3: Translated by dx=', dx.toFixed(2), 'dy=', dy.toFixed(2));
    console.log('        New rail position (', rail.x.toFixed(1), ',', rail.y.toFixed(1), ')');
    
    // Step 4: 終点の角度を目標角度に合わせる
    railEndpoints = rail.getEndpoints();
    if (isUTurn) {
        endPoint = railEndpoints[1];
    } else if (needsEndpoint2 && railEndpoints.length >= 2) {
        endPoint = railEndpoints[1];
    } else if (railEndpoints.length >= 2) {
        endPoint = railEndpoints[1];
    } else {
        endPoint = railEndpoints[0];
    }
    
    const targetEndAngle = normalizedAngle;  // 正規化された凹端点の角度
    const currentEndAngle = ((endPoint.angle % 360) + 360) % 360;  // 終点角度も正規化
    
    // 角度差を計算（-180～180の範囲に正規化）
    let angleDiff = targetEndAngle - currentEndAngle;
    while (angleDiff > 180) angleDiff -= 360;
    while (angleDiff < -180) angleDiff += 360;
    
    console.log('Step 4: Target end angle=', targetEndAngle, 'Current end angle=', currentEndAngle);
    console.log('        Angle difference=', angleDiff.toFixed(2), 'degrees');
    
    if (Math.abs(angleDiff) > 0.1) {
        console.log('        Rotating around (', lastEndpoint.x.toFixed(1), ',', lastEndpoint.y.toFixed(1), ')');
        rotateRailAroundPoint(rail, lastEndpoint.x, lastEndpoint.y, angleDiff);
        
        // 回転後の角度を正規化
        rail.angle = ((rail.angle % 360) + 360) % 360;
        console.log('        Rotated. New rail angle=', rail.angle);
    }
    
    // 検証
    const finalEndpoints = rail.getEndpoints();
    let finalEndPoint;
    if (isUTurn) {
        finalEndPoint = finalEndpoints[1];
    } else if (needsEndpoint2 && finalEndpoints.length >= 2) {
        finalEndPoint = finalEndpoints[1];
    } else if (finalEndpoints.length >= 2) {
        finalEndPoint = finalEndpoints[1];
    } else {
        finalEndPoint = finalEndpoints[0];
    }
    const finalDx = lastEndpoint.x - finalEndPoint.x;
    const finalDy = lastEndpoint.y - finalEndPoint.y;
    const finalDistance = Math.sqrt(finalDx * finalDx + finalDy * finalDy);
    
    const finalEndAngle = ((finalEndPoint.angle % 360) + 360) % 360;
    let finalAngleDiff = Math.abs(normalizedAngle - finalEndAngle);
    if (finalAngleDiff > 180) finalAngleDiff = 360 - finalAngleDiff;
    
    console.log('Verification: Final distance=', finalDistance.toFixed(3), 'px, angle diff=', finalAngleDiff.toFixed(2), 'deg');
    console.log('=== Adjustment complete ===');
}

// レール追加後の進行方向更新
function updateProgressionAfterAdd(addedRail, wasPlacedFromEnd) {
    LastselectedShape = addedRail;
    railProgression.rail = addedRail;
    
    // レールタイプによって進行方向を自動調整
    const endpoints = addedRail.getEndpoints();
    
    console.log('updateProgression: rail=', addedRail.id, 'type=', addedRail.constructor.name, 
                'railType=', addedRail.railType, 'endpoints=', endpoints.length, 
                'wasPlacedFromEnd=', wasPlacedFromEnd);
    
    // 【最優先】1/4凸凸・1/6凸凸（ジョイント凸凸）: 凹進行を停止
    if (addedRail.railType === 'QuarterVV' ||
        addedRail.railType === 'SixthVV' ||
        (addedRail.endpointTypes && 
         addedRail.endpointTypes.endType === 'convex' &&
         addedRail.endpointTypes.startType === 'convex')) {
        
        if (wasPlacedFromEnd) {
            // 凹から配置された凸凸レール: 起点(凸)が次の接続点、凹進行停止
            railProgression.endpointIndex = 0; // 起点(凸)
            railProgression.isReversed = false; // ❗ 凹進行停止
            console.log('→ VV rail (from concave): endpoint 0 (start, convex), reversed=false (stop concave progression)');
        } else {
            // 通常配置された凸凸レール: 終点(凸)が次の接続点
            railProgression.endpointIndex = endpoints.length - 1; // 最後の端点(凸)
            railProgression.isReversed = false; // 通常進行
            console.log('→ VV rail: endpoint', endpoints.length - 1, '(end convex), reversed=false');
        }
        return;
    }
    
    // 【最優先】1/4凹凹・1/6凹凹（ジョイント凹凹）: 凹進行を開始/継続
    if (addedRail.railType === 'QuarterCC' ||
        addedRail.railType === 'SixthCC' ||
        (addedRail.endpointTypes && 
         addedRail.endpointTypes.endType === 'concave')) {
        railProgression.endpointIndex = endpoints.length - 1; // 最後の端点(凹)
        railProgression.isReversed = true;  // 凹進行開始/継続
        
        if (wasPlacedFromEnd) {
            console.log('→ CC rail (from concave): endpoint', endpoints.length - 1, '(end concave), reversed=true (continue)');
        } else {
            console.log('→ CC rail: endpoint', endpoints.length - 1, '(end concave), reversed=true (start concave progression)');
        }
        return;
    }
    
    // 凹端点から配置された場合: 配置したレールの起点（凹）が次の接続点
    if (wasPlacedFromEnd) {
        railProgression.endpointIndex = 0;  // 起点（凹）
        railProgression.isReversed = true;  // 凹端点なので逆方向フラグを立てる
        console.log('→ Placed from concave: endpoint 0 (start, concave), reversed=true');
        return;
    }
    
    // ポイントレール: 常にendpoints[1]（ID-2の主要終点）を使用
    if (addedRail.constructor.name === 'TurnoutRail' ||
        addedRail.constructor.name === 'R13PointRail' ||
        addedRail.constructor.name === 'R22YPointRail' ||
        addedRail.constructor.name === 'R15WidePointRail' ||
        addedRail.constructor.name === 'R30TrianglePointRail' ||
        addedRail.constructor.name === 'CrossPointRail' ||
        addedRail.constructor.name === 'DoubleTrackCrossoverRail' ||
        addedRail.constructor.name === 'DoubleTrackTurnoutRail') {
        railProgression.endpointIndex = 1;  // 固定: endpoints[1] = -2の主要終点
        railProgression.isReversed = false;
        console.log('→ Point rail: endpoint 1 (ID-2), reversed=false');
        return;
    }
    
    // 8の字ポイント: タイプ別処理
    if (addedRail.constructor.name === 'Figure8PointRail') {
        // 8の字R系: 終点3が凹なので、凹進行を停止
        if (addedRail.pointType === 'R' || addedRail.pointType === 'R_REV') {
            if (wasPlacedFromEnd) {
                // 凹から配置された場合: 起点(凹)を次の接続点にするが、凹進行は停止
                railProgression.endpointIndex = 0;  // 起点(凹)
                railProgression.isReversed = false; // ❗ 凹進行停止（手動選択待ち）
                console.log('→ Figure8 R-type (from concave): endpoint 0 (concave), reversed=false (stop auto-concave)');
            } else {
                // 通常配置: endpoint 1から
                railProgression.endpointIndex = 1;
                railProgression.isReversed = false;
                console.log('→ Figure8 R-type: endpoint 1 (ID-2), reversed=false');
            }
        } else {
            // 8の字L系: 通常のポイントレールと同じ
            railProgression.endpointIndex = 1;
            railProgression.isReversed = false;
            console.log('→ Figure8 L-type: endpoint 1 (ID-2), reversed=false');
        }
        return;
    }
    
    // Uターンレール: 両端が凹なので特殊処理
    if (addedRail.constructor.name === 'UTurnRail') {
        if (wasPlacedFromEnd) {
            // 凹から配置された場合: もう一方の凹端点(endpoint 1)を次の起点に
            railProgression.endpointIndex = 1; // endpoint 1 (もう一方の凹)
            railProgression.isReversed = true;  // 引き続き凹端点
            console.log('→ UTurn placed from concave: endpoint 1 (other concave), reversed=true');
        } else {
            // 通常配置（凸から）: endpoint 1から逆方向で続ける
            railProgression.endpointIndex = 1; // endpoint 1 (凹)
            railProgression.isReversed = true;  // 逆方向
            console.log('→ UTurn: endpoint 1, reversed=true');
        }
        return;
    }
    
    // 複線レール（4端点）: 凹進行時と通常時で異なる処理
    if (addedRail.isDoubleTrack && endpoints.length === 4) {
        if (wasPlacedFromEnd) {
            // 凹から配置された場合: 内側凹（endpoint 2, ID-3）を次の起点に
            railProgression.endpointIndex = 2; // eps[2] (内側凹)
            railProgression.isReversed = true; // 凹進行継続
            console.log('→ Double track rail (from concave): endpoint 2 (ID-3, inner concave), reversed=true');
        } else {
            // 通常配置: 外側凸（endpoint 1, ID-2）を次の起点に
            railProgression.endpointIndex = 1; // eps[1] (外側凸)
            railProgression.isReversed = false;
            console.log('→ Double track rail: endpoint 1 (ID-2, outer convex), reversed=false');
        }
        return;
    }
    
    // 【原則】通常レール: endpoint 1（ID-2）を使用
    if (endpoints.length >= 2) {
        railProgression.endpointIndex = 1; // eps[1] (ID-2)
        railProgression.isReversed = false;
        console.log('→ Normal rail: endpoint 1 (ID-2), reversed=false');
    } else {
        // 端点が1つしかない場合（通常ありえない）
        railProgression.endpointIndex = 0;
        railProgression.isReversed = false;
        console.log('→ Single endpoint: endpoint 0, reversed=false');
    }
}

function addRailCommon(rail, lastEndpoint, options = {}) {
    const { setAngle = true } = options;
    if (setAngle) {
        rail.angle = lastEndpoint.angle;
    }
    adjustRailPlacement(rail, lastEndpoint);
    
    // 配置前の状態を保存
    const prevRail = railProgression.rail;
    const prevEpsIndex = railProgression.endpointIndex;
    const prevIsReversed = railProgression.isReversed;
    
    rails.push(rail);
    updateProgressionAfterAdd(rail, lastEndpoint.placeFromEnd);
    
    // 配置後に履歴に記録（prevの状態を使う）
    railPlacementHistory.push({
        id: rail.id,
        connectedFrom: prevRail ? {
            railId: prevRail.id,
            epsIndex: prevEpsIndex
        } : null,
        isReversed: prevIsReversed
    });
    
    drawAll();
}


// ==========================================
// イベントリスナー（v37用）
// ==========================================

// ===== 基本レール =====
document.getElementById('addStraight').addEventListener('click', () => {
    addRailByType('straight');
});

document.getElementById('addHalfStraight').addEventListener('click', () => {
    addRailByType('halfStraight');
});

document.getElementById('addDoubleStraight').addEventListener('click', () => {
    addRailByType('doubleStraight');
});

document.getElementById('addRightCurve').addEventListener('click', () => {
    addRailByType('curve', { direction: 'right' });
});

document.getElementById('addLeftCurve').addEventListener('click', () => {
    addRailByType('curve', { direction: 'left' });
});

// ===== 外側曲線 =====
document.getElementById('addRightOuterCurve').addEventListener('click', () => {
    addRailByType('outerCurve', { direction: 'right' });
});

document.getElementById('addLeftOuterCurve').addEventListener('click', () => {
    addRailByType('outerCurve', { direction: 'left' });
});

// ===== 倍曲線（90度） =====
document.getElementById('addDoubleLengthCurveRight').addEventListener('click', () => {
    addRailByType('doubleLengthCurve', { direction: 'right' });
});

document.getElementById('addDoubleLengthCurveLeft').addEventListener('click', () => {
    addRailByType('doubleLengthCurve', { direction: 'left' });
});

// ===== スライド =====
document.getElementById('addSlide').addEventListener('click', () => {
    addRailByType('slide', { reversed: false });
});

document.getElementById('addRSlide').addEventListener('click', () => {
    addRailByType('slide', { reversed: true });
});

// ===== ターンアウト =====
document.getElementById('addTurnoutLeft').addEventListener('click', () => {
    addRailByType('turnout', { direction: 'left', type: 'R' });
});

document.getElementById('addTurnoutRight').addEventListener('click', () => {
    addRailByType('turnout', { direction: 'right', type: 'R' });
});

document.getElementById('addTurnoutLeftL').addEventListener('click', () => {
    addRailByType('turnout', { direction: 'left', type: 'L' });
});

document.getElementById('addTurnoutRightL').addEventListener('click', () => {
    addRailByType('turnout', { direction: 'right', type: 'L' });
});

// ===== 8の字ポイント =====
document.getElementById('addFigure8Point').addEventListener('click', () => {
    addRailByType('figure8', { type: 'R', direction: 'left' });
});

document.getElementById('addFigure8PointL').addEventListener('click', () => {
    addRailByType('figure8', { type: 'L', direction: 'left' });
});

document.getElementById('addFigure8PointRRev').addEventListener('click', () => {
    addRailByType('figure8', { type: 'R', direction: 'right' });
});

document.getElementById('addFigure8PointLRev').addEventListener('click', () => {
    addRailByType('figure8', { type: 'L', direction: 'right' });
});

// ===== 十字ポイント =====
document.getElementById('addCrossPoint').addEventListener('click', () => {
    addRailByType('crossPoint', { reversed: false });
});
document.getElementById('addCrossPointRev').addEventListener('click', () => {
    addRailByType('crossPoint', { reversed: true });
});

// ===== Uターン =====
document.getElementById('addUTurnRailU').addEventListener('click', () => {
    addRailByType('uturn', { type: 'U' });
});

document.getElementById('addUTurnRailV').addEventListener('click', () => {
    addRailByType('uturn', { type: 'V' });
});

// ===== R13ポイント =====
document.getElementById('addR13PointARight').addEventListener('click', () => {
    addRailByType('r13', { type: 'A', direction: 'right' });
});

document.getElementById('addR13PointALeft').addEventListener('click', () => {
    addRailByType('r13', { type: 'A', direction: 'left' });
});

document.getElementById('addR13PointBRight').addEventListener('click', () => {
    addRailByType('r13', { type: 'B', direction: 'right' });
});

document.getElementById('addR13PointBLeft').addEventListener('click', () => {
    addRailByType('r13', { type: 'B', direction: 'left' });
});

// ===== R22 Y字 =====
document.getElementById('addR22YPointA').addEventListener('click', () => {
    addRailByType('r22', { type: 'A', reversed: false });
});

document.getElementById('addR22YPointARev').addEventListener('click', () => {
    addRailByType('r22', { type: 'A', reversed: true });
});

document.getElementById('addR22YPointB').addEventListener('click', () => {
    addRailByType('r22', { type: 'B', reversed: false });
});

document.getElementById('addR22YPointBRev').addEventListener('click', () => {
    addRailByType('r22', { type: 'B', reversed: true });
});

// ===== R15ワイドポイント =====
document.getElementById('addR15WideA').addEventListener('click', () => {
    addRailByType('r15', { type: 'A', reversed: false });
});

document.getElementById('addR15WideARev').addEventListener('click', () => {
    addRailByType('r15', { type: 'A', reversed: true });
});

document.getElementById('addR15WideB').addEventListener('click', () => {
    addRailByType('r15', { type: 'B', reversed: false });
});

document.getElementById('addR15WideBRev').addEventListener('click', () => {
    addRailByType('r15', { type: 'B', reversed: true });
});

// ===== R17ポイント =====
document.getElementById('addR17ThreewayPointARight').addEventListener('click', () => {
    addRailByType('r17', { type: 'A', direction: 'right' });
});

document.getElementById('addR17ThreewayPointALeft').addEventListener('click', () => {
    addRailByType('r17', { type: 'A', direction: 'left' });
});

document.getElementById('addR17ThreewayPointBRight').addEventListener('click', () => {
    addRailByType('r17', { type: 'B', direction: 'right' });
});

document.getElementById('addR17ThreewayPointBLeft').addEventListener('click', () => {
    addRailByType('r17', { type: 'B', direction: 'left' });
});

// ===== R30三角ポイント =====
document.getElementById('addR30TrianglePoint').addEventListener('click', () => {
    addRailByType('r30', { reversed: false });
});

document.getElementById('addR30TrianglePointRev').addEventListener('click', () => {
    addRailByType('r30', { reversed: true });
});

// ===== 複線レール =====
document.getElementById('addDoubleTrack').addEventListener('click', () => {
    addRailByType('doubleTrack');
});

document.getElementById('addDoubleCurveRight').addEventListener('click', () => {
    addRailByType('doubleCurve', { direction: 'right' });
});

document.getElementById('addDoubleCurveLeft').addEventListener('click', () => {
    addRailByType('doubleCurve', { direction: 'left' });
});

document.getElementById('addDoubleTrackCrossover').addEventListener('click', () => {
    addRailByType('doubleCrossover', { reversed: false });
});

document.getElementById('addDoubleTrackCrossoverRev').addEventListener('click', () => {
    addRailByType('doubleCrossover', { reversed: true });
});

document.getElementById('addDoubleTrackTurnoutLeft').addEventListener('click', () => {
    addRailByType('doubleTurnout', { direction: 'left', reversed: false });
});

document.getElementById('addDoubleTrackTurnoutRight').addEventListener('click', () => {
    addRailByType('doubleTurnout', { direction: 'right', reversed: false });
});

document.getElementById('addDoubleTrackTurnoutLeftRev').addEventListener('click', () => {
    addRailByType('doubleTurnout', { direction: 'left', reversed: true });
});

document.getElementById('addDoubleTrackTurnoutRightRev').addEventListener('click', () => {
    addRailByType('doubleTurnout', { direction: 'right', reversed: true });
});

// ===== 1/4・1/6レール =====
document.getElementById('addQuarterV').addEventListener('click', () => {
    addRailByType('quarterV');
});

document.getElementById('addQuarterC').addEventListener('click', () => {
    addRailByType('quarterC');
});

document.getElementById('addJoint').addEventListener('click', () => {
    addRailByType('joint');
});

// 1/4直線を追加するボタンのイベントリスナー（凹凸）
// 以下のボタンは削除済みだが、将来の使用のためイベントリスナーを残す
/*
document.getElementById('addQuarterStraight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `Q${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25);
        rect.color = 'skyblue';
        addRailCommon(rect, lastEndpoint);
    }
});

// 1/4直線を追加するボタンのイベントリスナー（凹凹）
document.getElementById('addQuarterCC').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `QCC${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25, 
            { startType: 'concave', endType: 'concave' });
        rect.color = 'skyblue';
        rect.railType = 'QuarterCC';  // 識別用
        addRailCommon(rect, lastEndpoint);
    }
});

// 1/4直線を追加するボタンのイベントリスナー（凸凸）
document.getElementById('addQuarterVV').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `QVV${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25, 
            { startType: 'convex', endType: 'convex' });
        rect.color = 'skyblue';
        rect.railType = 'QuarterVV';  // 識別用
        addRailCommon(rect, lastEndpoint);
    }
});
*/







// レールを追加する関数
function addRail(type) {
    const lastEndpoint = getLastEndpoint();
    if (!lastEndpoint) return;

    if (type === 'S' || type ==='s') {
        const id = `S${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id);
        addRailCommon(rect, lastEndpoint);
    } else if (type === 'R'|| type ==='r') {
        const id = `R${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'right');
        curve.angle = (lastEndpoint.angle + 360) % 360;
        addRailCommon(curve, lastEndpoint, { setAngle: false });
    } else if (type === 'L'|| type ==='l') {
        const id = `L${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'left');
        addRailCommon(curve, lastEndpoint);
    }
}

// ========================
// レール追加ヘルパー関数群（フェーズ1: 直線・曲線のみ）
// ========================

// ID生成ヘルパー
function generateRailId(railType) {
    const prefixes = {
        // 基本レール
        'straight': 'R',
        'halfStraight': 'H',
        'doubleStraight': 'D',
        'curve': 'C',
        
        // 特殊直線・曲線
        'outerCurve': 'OC',
        'doubleLengthCurve': 'DLC',
        'slide': 'Sl',
        
        // ポイントレール
        'turnout': 'T',
        'figure8': 'F',
        'crossPoint': 'CP',
        'uturn': 'UT',
        'r13': 'R13',
        'r22': 'R22',
        'r15': 'R15',
        'r17': 'R17',
        'r30': 'R30',
        
        // 複線レール
        'doubleTrack': 'DT',
        'doubleCurve': 'DC',
        'doubleCrossover': 'DTCR',
        'doubleTurnout': 'DTT',
        
        // 1/4・1/6レール
        'quarterV': 'QV',
        'quarterC': 'QC',
        'joint': 'J'
    };
    const prefix = prefixes[railType] || 'R';
    return `${prefix}${rails.length + 1}`;
}

// 統一レール追加関数
function addRailByType(railType, options = {}) {
    // レール追加時は選択端点をクリア
    selectedEndpoint = null;
    
    // 座標指定モード（options.x, options.y, options.angleが指定されている場合）
    const isPositionMode = options.x !== undefined && options.y !== undefined && options.angle !== undefined;
    
    let lastEndpoint;
    if (isPositionMode) {
        // 座標指定モード: 指定された座標・角度を使用
        lastEndpoint = {
            x: options.x,
            y: options.y,
            angle: options.angle,
            type: 'convex',
            placeFromEnd: false
        };
        console.log('addRailByType (座標指定モード):', { x: options.x, y: options.y, angle: options.angle, railType });
    } else {
        // 通常モード: 最後の端点から配置
        lastEndpoint = getLastEndpoint();
        if (!lastEndpoint) return;
    }
    
    const id = generateRailId(railType);
    let rail = null;
    
    switch(railType) {
        // ===== 基本直線 =====
        case 'straight':
            rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id);
            break;
            
        case 'halfStraight':
            rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.5);
            rail.color = 'lightblue';
            break;
            
        case 'doubleStraight':
            rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 2);
            rail.color = 'navy';
            break;
            
        // ===== 基本曲線 =====
        case 'curve':
            const direction = options.direction || 'right';
            rail = new Curve(lastEndpoint.x, lastEndpoint.y, id, direction);
            break;
            
        case 'outerCurve':
            const outerDir = options.direction || 'right';
            rail = new Curve(lastEndpoint.x, lastEndpoint.y, id, outerDir);
            rail.radius = RAIL_LENGTH + D_TRACK_WIDTH;
            rail.color = 'purple';
            break;
            
        case 'doubleLengthCurve':
            const dlDir = options.direction || 'right';
            rail = new DoubleLengthCurve(lastEndpoint.x, lastEndpoint.y, id, dlDir);
            break;
            
        // ===== スライドレール =====
        case 'slide':
            const slideOffset = options.reversed ? -D_TRACK_WIDTH : D_TRACK_WIDTH;
            rail = new Slide(lastEndpoint.x, lastEndpoint.y, id, slideOffset);
            break;
            
        // ===== ターンアウト =====
        case 'turnout':
            const turnoutDir = options.direction || 'left';
            const turnoutType = options.type || 'R';
            rail = new TurnoutRail(lastEndpoint.x, lastEndpoint.y, id, turnoutType, turnoutDir);
            break;
            
        // ===== 8の字ポイント =====
        case 'figure8':
            const f8Type = options.type || 'R';
            const f8Direction = options.direction || 'left';
            rail = new Figure8PointRail(lastEndpoint.x, lastEndpoint.y, id, f8Type, f8Direction);
            break;
            
        // ===== 十字ポイント =====
        case 'crossPoint':
			const CPReversed = options.reversed || false;
            rail = new CrossPointRail(lastEndpoint.x, lastEndpoint.y, id,CPReversed);
            break;
            
        // ===== Uターンレール =====
        case 'uturn':
            const uturnType = options.type || 'U';
            rail = new UTurnRail(lastEndpoint.x, lastEndpoint.y, id, uturnType);
            break;
            
        // ===== R13ポイント =====
        case 'r13':
            const r13Type = options.type || 'A';
            const r13Dir = options.direction || 'right';
            rail = new R13PointRail(lastEndpoint.x, lastEndpoint.y, id, r13Type, r13Dir);
            break;

        // ===== R17ポイント =====
        case 'r17':
            const r17Type = options.type || 'A';
            const r17Dir = options.direction || 'right';
            rail = new R17ThreewayRail(lastEndpoint.x, lastEndpoint.y, id, r17Type, r17Dir);
            break;
            
        // ===== R22 Y字ポイント =====
        case 'r22':
            const r22Type = options.type || 'A';
            const r22Reversed = options.reversed || false;
            rail = new R22YPointRail(lastEndpoint.x, lastEndpoint.y, id, r22Type, r22Reversed);
            break;
            
        // ===== R15ワイドポイント =====
        case 'r15':
            const r15Type = options.type || 'A';
            const r15Reversed = options.reversed || false;
            rail = new R15WidePointRail(lastEndpoint.x, lastEndpoint.y, id, r15Type, r15Reversed);
            break;
            
        // ===== R30三角ポイント =====
        case 'r30':
            const r30Reversed = options.reversed || false;
            rail = new R30TrianglePointRail(lastEndpoint.x, lastEndpoint.y, id, r30Reversed);
            break;
            
        // ===== 複線直線 =====
        case 'doubleTrack':
            rail = new DoubleTrackRail(lastEndpoint.x, lastEndpoint.y, id);
            break;
            
        // ===== 複線曲線 =====
        case 'doubleCurve':
            const dcDir = options.direction || 'right';
            rail = new DoubleCurveRail(lastEndpoint.x, lastEndpoint.y, id, dcDir);
            break;
            
        // ===== 複線渡り =====
        case 'doubleCrossover':
            const dcReversed = options.reversed || false;
            rail = new DoubleTrackCrossoverRail(lastEndpoint.x, lastEndpoint.y, id, dcReversed);
            break;
            
        // ===== 複線ターンアウト =====
        case 'doubleTurnout':
            const dtDir = options.direction || 'right';
            const dtReversed = options.reversed || false;
            rail = new DoubleTrackTurnoutRail(lastEndpoint.x, lastEndpoint.y, id, dtDir, dtReversed);
            break;
            
        // ===== 1/4レール =====
        case 'quarterV':
        case 'quarterConvex':
            if (isPositionMode) {
                // 座標指定モード: 凸凸を作成
                rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25,
                    { startType: 'convex', endType: 'convex' });
                rail.railType = 'QuarterVV';
            } else if (lastEndpoint.placeFromEnd) {
                rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25,
                    { startType: 'convex', endType: 'convex' });
                rail.railType = 'QuarterVV';
            } else {
                rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25,
                    { startType: 'concave', endType: 'convex' });
            }
            rail.color = 'skyblue';
            break;
            
        case 'quarterC':
        case 'quarterConcave':
            if (isPositionMode) {
                // 座標指定モード: 凹凹を作成
                rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25,
                    { startType: 'concave', endType: 'concave' });
                rail.railType = 'QuarterCC';
            } else if (lastEndpoint.placeFromEnd) {
                rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25,
                    { startType: 'concave', endType: 'convex' });
            } else {
                rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25,
                    { startType: 'concave', endType: 'concave' });
                rail.railType = 'QuarterCC';
            }
            rail.color = 'skyblue';
            break;
            
        // ===== 1/6ジョイント =====
        case 'joint':
        case 'jointConvex':
        case 'jointConcave':
            if (isPositionMode) {
                // 座標指定モード: railTypeに応じて凸凸または凹凹を作成
                const isConvex = (railType === 'jointConvex' || railType === 'joint');
                if (isConvex) {
                    rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH / 6,
                        { startType: 'convex', endType: 'convex' });
                    rail.railType = 'SixthVV';
                } else {
                    rail = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH / 6,
                        { startType: 'concave', endType: 'concave' });
                    rail.railType = 'SixthCC';
                }
                rail.color = 'lightgray';
                break;
            } else {
                return addJointRail(lastEndpoint.placeFromEnd);
            }
            
        default:
            console.error('Unknown rail type:', railType);
            return;
    }
    
    if (rail) {
        // ポイントレール系は_syncを呼ぶ
        if (typeof rail._sync === 'function') {
            rail._sync();
        }
        
        if (isPositionMode) {
            // 座標指定モード: 直接角度を設定
            rail.angle = options.angle;
            
            // _syncをもう一度呼ぶ（角度変更後）
            if (typeof rail._sync === 'function') {
                rail._sync();
            }
            
            rails.push(rail);
            
            // railProgressionを更新
            updateProgressionAfterAdd(rail, false);
            
            // 凹進行フラグ
            if (options.isReversed) {
                railProgression.isReversed = true;
                railProgression.endpointIndex = 0;
            }
            
            // 配置履歴に記録
            railPlacementHistory.push({ 
                id: rail.id, 
                connectedFrom: null, 
                isReversed: options.isReversed || false
            });
            
            // selectedEndpointを更新
            const endpoints = rail.getEndpoints();
            for (let ep of endpoints) {
                if (ep.type === 'convex') {
                    selectedEndpoint = { ...ep, placeFromEnd: false };
                    break;
                }
            }
            
            drawAll();
            console.log('addRailByType (座標指定) 完了:', rail.id);
        } else {
            // 通常モード
            addRailCommon(rail, lastEndpoint);
        }
    } else {
        if (isPositionMode) {
            console.error('addRailByType: レール生成失敗:', railType, options);
        }
    }
}

function addJointRail(isConcaveProgression) {
    const lastEndpoint = getLastEndpoint();
    if (!lastEndpoint) return;
    
    if (isConcaveProgression) {
        // 凹進行時 → 1/6凸凸
        const id = `JVV${rails.length + 1}`;
        const rect = new StraightRail(
            lastEndpoint.x, lastEndpoint.y, id, 
            RAIL_LENGTH / 6,
            { startType: 'convex', endType: 'convex' }
        );
        rect.color = 'lightgray';
        rect.railType = 'SixthVV';
        addRailCommon(rect, lastEndpoint);
    } else {
        // 凸進行時 → 1/6凹凹
        const id = `JCC${rails.length + 1}`;
        const rect = new StraightRail(
            lastEndpoint.x, lastEndpoint.y, id, 
            RAIL_LENGTH / 6,
            { startType: 'concave', endType: 'concave' }
        );
        rect.color = 'lightgray';
        rect.railType = 'SixthCC';
        addRailCommon(rect, lastEndpoint);
    }
}
// 縮尺リセット　イベントリスナー
document.getElementById('canvasreset').addEventListener('click', () => {
 scale = 3.0;  // 初期スケールに戻す

     canvasOffsetX = canvW/2;
     canvasOffsetY = canvH/2;

drawAll();


});

// リセット　イベントリスナー
document.getElementById('allclear').addEventListener('click', () => {
    scale = 3.0;  // 初期スケールに戻す
    canvasOffsetX = canvW/2;
    canvasOffsetY = canvH/2;
    rails.length = 0;
    railPlacementHistory = []; // 配置履歴もクリア
    drawAll();
});



// テキストボックスの入力を処理するイベントリスナー
document.getElementById('addRails').addEventListener('click', () => {
    const input = document.getElementById('railInput').value.toUpperCase();
    for (const char of input) {
        if (['S', 'R', 'L'].includes(char)) {
            addRail(char);
        }
    }
    document.getElementById('railInput').value = ''; // 入力をクリア
});


// レイアウトをコンパクトな文字列に変換
function saveLayout() {
    const data = saveLayoutAsShortcut();
    document.getElementById('layoutData').value = data;
    return data;
}

// ========================================
// ショートカット形式の保存/読込
// ========================================

// 連続判定（シンプル版）
function isConnectedToAnyEndpoint(prevRail, currRail) {
    if (!prevRail) return false;
    
    try {
        const prevEps = prevRail.getEndpoints();
        const currEps = currRail.getEndpoints();
        
        const tolerance = 0.5;
        
        // すべての端点ペアをチェック
        for (let prevEp of prevEps) {
            for (let currEp of currEps) {
                const dx = Math.abs(prevEp.x - currEp.x);
                const dy = Math.abs(prevEp.y - currEp.y);
                
                // 角度の差（0度付近で一致）
                let da = Math.abs(prevEp.angle - currEp.angle);
                da = Math.min(da, 360 - da);
                
                // 座標と角度が一致
                if (dx < tolerance && dy < tolerance && da < 5) {
                    return true;
                }
            }
        }
        
        return false;
    } catch (error) {
        console.warn('連続判定エラー:', error);
        return false;
    }
}

// ショートカット形式で保存
function loadLayout() {
    const layoutData = document.getElementById('layoutData').value.trim();
    if (!layoutData) return;
    
    rails.length = 0;
    railPlacementHistory = [];
    
    // ショートカット形式で読み込み
    executeShortcutBuffer(layoutData);
}

// LocalStorage保存/読込
function saveToSlot(slot) {
    const data = saveLayout();
    localStorage.setItem(`plarail_layout_slot${slot}`, data);
    showStatus(`スロット${slot}に保存しました`);
}

function loadFromSlot(slot) {
    const data = localStorage.getItem(`plarail_layout_slot${slot}`);
    if (data) {
        document.getElementById('layoutData').value = data;
        loadLayout();
        showStatus(`スロット${slot}から読み込みました`);
    } else {
        showStatus(`スロット${slot}は空です`);
    }
}

// URL共有機能
function getLayoutURL() {
    const data = saveLayout();
    const compressed = encodeURIComponent(data);
    const url = `${window.location.origin}${window.location.pathname}?layout=${compressed}`;
    return url;
}

function copyURLToClipboard() {
    const url = getLayoutURL();
    
    // クリップボードにコピー
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).then(() => {
            showStatus('URLをコピーしました！');
        }).catch(() => {
            fallbackCopyTextToClipboard(url);
        });
    } else {
        fallbackCopyTextToClipboard(url);
    }
}

function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.top = "0";
    textArea.style.left = "0";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showStatus('URLをコピーしました！');
    } catch (err) {
        showStatus('コピーに失敗しました');
    }
    
    document.body.removeChild(textArea);
}

function shareToTwitter() {
    const url = getLayoutURL();
    const text = 'プラレールレイアウトを作りました！';
    const twitterURL = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
    window.open(twitterURL, '_blank');
}

function showStatus(message) {
    const status = document.getElementById('urlStatus');
    status.textContent = message;
    setTimeout(() => {
        status.textContent = '';
    }, 3000);
}

// URLからレイアウトを読み込み
function loadFromURL() {
    const params = new URLSearchParams(window.location.search);
    const layoutData = params.get('layout');
    if (layoutData) {
        try {
            document.getElementById('layoutData').value = decodeURIComponent(layoutData);
            loadLayout();
            showStatus('URLからレイアウトを読み込みました');
        } catch (e) {
            console.error('レイアウト読み込みエラー:', e);
        }
    }
}

// イベントリスナー設定
document.getElementById('saveLayout').addEventListener('click', saveLayout);
document.getElementById('loadLayout').addEventListener('click', loadLayout);



// スロット保存/読込
for (let i = 1; i <= 5; i++) {
    document.getElementById(`saveSlot${i}`).addEventListener('click', () => saveToSlot(i));
    document.getElementById(`loadSlot${i}`).addEventListener('click', () => loadFromSlot(i));
}

// URL共有
document.getElementById('copyURL').addEventListener('click', copyURLToClipboard);
document.getElementById('shareTwitter').addEventListener('click', shareToTwitter);

// ページ読み込み時にURLからレイアウトを復元
window.addEventListener('DOMContentLoaded', loadFromURL);

// グループ移動モードのチェックボックス
// 接続まとめて移動ボタン
document.getElementById('groupMoveToggle').addEventListener('click', () => {
    groupMoveEnabled = !groupMoveEnabled;
    const btn = document.getElementById('groupMoveToggle');
    btn.textContent = `接続まとめて移動: ${groupMoveEnabled ? 'ON' : 'OFF'}`;
    btn.style.background = groupMoveEnabled ? '#cfc' : '#fff';
});



// 初期レール生成
function initializeRails() {
    // 初期の長方形を追加
    for (let i = 0; i < 1; i++) {
        const id = `S${i + 1}`;
        const rect = new StraightRail(0 , 0, id);
        rect.angle = 0;
        rails.push(rect);
        railPlacementHistory.push({ id: rect.id, connectedFrom: null, isReversed: false });
    }
    drawAll();
}

// DOMContentLoaded後に初期レール生成
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeRails);
} else {
    initializeRails();
}

// ==========================================
// 凡例カルーセル機能
// ==========================================

// 凡例アイテムとボタンのマッピング
const legendToButton = {
    '直線': 'addStraight',
    'カーブ': 'addRightCurve',
    '倍曲線': 'addDoubleLengthCurveRight',
    'Uターン': 'addUTurnRailU',
    '外カーブ': 'addRightOuterCurve',
    '複線': 'addDoubleTrack',
    '複曲線': 'addDoubleCurveRight',
    '複線渡り': 'addDoubleTrackCrossover',
    '複線T.O.': 'addDoubleTrackTurnoutLeft',
    '十字': 'addCrossPoint',
    'ターンアウト': 'addTurnoutLeft',
    'R-13': 'addR13PointARight',
    'R-22 Y字': 'addR22YPointA',
    'R-15幅広 / R-30三角': 'addR15WideA',
    '8の字': 'addFigure8Point'
};

// 凡例アイテムクリック時の処理
document.addEventListener('DOMContentLoaded', () => {
    const legendItems = document.querySelectorAll('.color-item');
    
    legendItems.forEach(item => {
        item.addEventListener('click', () => {
            const railName = item.querySelector('span').textContent;
            const buttonId = legendToButton[railName];
            
            if (buttonId) {
                const button = document.getElementById(buttonId);
                if (button) {
                    // ボタンまでスクロール
                    button.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'nearest',
                        inline: 'center'
                    });
                    
                    // ボタンをハイライト（0.8秒）
                    button.style.backgroundColor = '#ffd700';
                    button.style.transition = 'background-color 0.3s';
                    setTimeout(() => {
                        button.style.backgroundColor = '';
                    }, 800);
                }
            }
        });
    });
    
    // マウスドラッグでスクロール（PC用）
    const legend = document.querySelector('.color-legend');
    let isDown = false;
    let startX;
    let scrollLeft;
    
    legend.addEventListener('mousedown', (e) => {
        isDown = true;
        legend.style.cursor = 'grabbing';
        startX = e.pageX - legend.offsetLeft;
        scrollLeft = legend.scrollLeft;
    });
    
    legend.addEventListener('mouseleave', () => {
        isDown = false;
        legend.style.cursor = 'grab';
    });
    
    legend.addEventListener('mouseup', () => {
        isDown = false;
        legend.style.cursor = 'grab';
    });
    
    legend.addEventListener('mousemove', (e) => {
        if (!isDown) return;
        e.preventDefault();
        const x = e.pageX - legend.offsetLeft;
        const walk = (x - startX) * 2; // スクロール速度
        legend.scrollLeft = scrollLeft - walk;
    });
    
    // 初期カーソル設定
    legend.style.cursor = 'grab';
});

// ==========================================
// レール数カウンター機能
// ==========================================

function countRails() {
    const counter = {};
    
    rails.forEach(rail => {
        let key = '';
        
        // クラス名で判定
        const className = rail.constructor.name;
        
        if (className === 'StraightRail') {
            // 直線系（長さと端点タイプで判別）
            const length = rail.length || RAIL_LENGTH;
            const railType = rail.railType || '';
            
            if (Math.abs(length - RAIL_LENGTH * 2) < 1) {
                key = '2倍直線';
            } else if (Math.abs(length - RAIL_LENGTH * 0.5) < 1) {
                key = '1/2直線';
            } else if (Math.abs(length - RAIL_LENGTH * 0.25) < 1) {
                // 1/4レール（端点タイプで判別）
                const startType = rail.startType || 'concave';
                const endType = rail.endType || 'convex';
                
                if (railType === 'QuarterCC' || (startType === 'concave' && endType === 'concave')) {
                    key = '1/4 (凹→凹)';
                } else if (railType === 'QuarterVV' || (startType === 'convex' && endType === 'convex')) {
                    key = '1/4 (凸→凸)';
                } else {
                    key = '1/4 (凹→凸)';
                }
            } else if (Math.abs(length - RAIL_LENGTH / 6) < 1) {
                // 1/6ジョイント（端点タイプで判別）
                const startType = rail.startType || 'concave';
                const endType = rail.endType || 'convex';
                
                if (railType === 'SixthCC' || (startType === 'concave' && endType === 'concave')) {
                    key = '1/6 (凹→凹)';
                } else if (railType === 'SixthVV' || (startType === 'convex' && endType === 'convex')) {
                    key = '1/6 (凸→凸)';
                } else {
                    key = '1/6 (凹→凸)';
                }
            } else {
                key = '直線';
            }
        } else if (className === 'Curve') {
            // 曲線（半径で判別）
            if (rail.radius > RAIL_LENGTH + 10) {
                key = '外側曲線';
            } else {
                key = 'カーブ';
            }
        } else if (className === 'DoubleLengthCurve') {
            key = '倍曲線';
        } else if (className === 'Slide') {
            key = 'スライド';
        } else if (className === 'UTurnRail') {
            key = 'Uターン';
        } else if (className === 'TurnoutRail') {
            // ターンアウト（タイプで判別）
            const type = rail.turnoutType || 'R';
            key = `ターンアウト (${type}型)`;
        } else if (className === 'Figure8PointRail') {
            // 8の字（タイプで判別）
            const type = rail.pointType || 'R';
            key = `8の字 (${type}型)`;
        } else if (className === 'CrossPointRail') {
            key = '十字ポイント';
        } else if (className === 'R13PointRail') {
            // R13（タイプで判別）
            const type = rail.pointType || 'A';
            key = `R-13 (${type}型)`;
        } else if (className === 'R22YPointRail') {
            // R22（タイプで判別）
            const type = rail.pointType || 'A';
            key = `R-22 (${type}型)`;
        } else if (className === 'R15WidePointRail') {
            // R15（タイプで判別）
            const type = rail.pointType || 'A';
            key = `R-15 (${type}型)`;
        } else if (className === 'R17ThreewayRail') {
            // R-17三方向ポイント（タイプで判別）
            const type = rail.ThreewayType || 'B';
            key = `R-17三方向 (${type}型)`;
        } else if (className === 'R30TrianglePointRail') {
            key = 'R-30三角';
        } else if (className === 'DoubleTrackRail') {
            key = '複線直線';
        } else if (className === 'DoubleCurveRail') {
            key = '複線カーブ';
        } else if (className === 'DoubleTrackCrossoverRail') {
            key = '複線渡り';
        } else if (className === 'DoubleTrackTurnoutRail') {
            // 複線ターンアウト（単線→複線分岐）
            const dir = rail.direction || 'left';
            const rev = rail.isReversed ? '裏' : '表';
            key = `複線T.O. (${dir === 'left' ? '左' : '右'}${rev})`;
        } else {
            key = 'その他';
        }
        
        counter[key] = (counter[key] || 0) + 1;
    });
    
    return counter;
}

function displayRailCounter() {
    const counter = countRails();
    const container = document.getElementById('railCounterContent');
    container.innerHTML = '';
    
    // ソートして表示
    const sorted = Object.entries(counter).sort((a, b) => {
        // カテゴリ順にソート
        const order = [
            '直線', '2倍直線', '1/2直線',
            'カーブ', '倍曲線', '外側曲線',
            'スライド',
            'Uターン',
            'ターンアウト', '8の字', '十字ポイント',
            'R-13', 'R-22', 'R-15','R-17', 'R-30三角',
            '複線直線', '複線カーブ', '複線渡り', '複線T.O.',
            '1/4', '1/6'
        ];
        
        const aPrefix = a[0].split(' ')[0];
        const bPrefix = b[0].split(' ')[0];
        const aIndex = order.findIndex(o => aPrefix.includes(o) || o.includes(aPrefix));
        const bIndex = order.findIndex(o => bPrefix.includes(o) || o.includes(bPrefix));
        
        if (aIndex !== bIndex) {
            return aIndex - bIndex;
        }
        return a[0].localeCompare(b[0]);
    });
    
    sorted.forEach(([name, count]) => {
        const item = document.createElement('div');
        item.style.padding = '4px 8px';
        item.style.background = 'white';
        item.style.borderRadius = '3px';
        item.innerHTML = `<strong>${name}</strong>: ${count}本`;
        container.appendChild(item);
    });
    
    // 合計
    const total = Object.values(counter).reduce((sum, val) => sum + val, 0);
    const totalItem = document.createElement('div');
    totalItem.style.padding = '4px 8px';
    totalItem.style.background = '#fffacd';
    totalItem.style.borderRadius = '3px';
    totalItem.style.fontWeight = 'bold';
    totalItem.innerHTML = `合計: ${total}本`;
    container.appendChild(totalItem);
}

// トグルボタン
document.getElementById('toggleCounter').addEventListener('click', () => {
    const container = document.getElementById('railCounterContainer');
    if (container.style.display === 'none') {
        displayRailCounter();
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
});

// 閉じるボタン
document.getElementById('closeCounter').addEventListener('click', () => {
    document.getElementById('railCounterContainer').style.display = 'none';
});

// 表示モード切替（端点表示 + レール描画を同時に切替）
document.getElementById('toggleDetailMode').addEventListener('click', () => {
    // 両方を同時に切替
    useDetailedEndpoints = !useDetailedEndpoints;
    useRealisticRendering = !useRealisticRendering;
    
    const btn = document.getElementById('toggleDetailMode');
    btn.textContent = useDetailedEndpoints ? '表示モード: 詳細' : '表示モード: 簡易';
    drawAll();
});

// ========================================
// ショートカット形式の保存/読込
// ========================================

// レールをショートカット文字列に変換
function railToShortcut(rail) {
    const className = rail.constructor.name;
    const dir = rail.direction;
    const rev = rail.isReversed;
    const type = rail.pointType || rail.ThreewayType;
    const turnoutType = rail.turnoutType;
    
    switch(className) {
        case 'StraightRail':
            if (rail.length === RAIL_LENGTH * 2) return 'BS';
            if (rail.length === RAIL_LENGTH * 0.5) return 'H';
            if (rail.length === RAIL_LENGTH * 0.25) {
                if (rail.startType === 'convex' && rail.endType === 'convex') return 'Qv';
                if (rail.startType === 'concave' && rail.endType === 'concave') return 'Qc';
                return 'Q.';
            }
            if (rail.length === RAIL_LENGTH / 6) {
                if (rail.startType === 'convex' && rail.endType === 'convex') return 'Jv';
                if (rail.startType === 'concave' && rail.endType === 'concave') return 'Jc';
                return 'Jv'; // フォールバック
            }
            return 'S';
            
        case 'Curve':
            if (rail.radius > RAIL_LENGTH + 10) {
                return dir === 'right' ? 'Or' : 'Ol';
            }
            return dir === 'right' ? 'R' : 'L';
            
        case 'DoubleLengthCurve':
            return dir === 'right' ? 'Br' : 'Bl';
            
        case 'Slide':
            return rail.slide > 0 ? 'Zr' : 'Zl';
            
        case 'DoubleTrackRail':
            return 'DS';
            
        case 'DoubleCurveRail':
            return dir === 'right' ? 'Dr' : 'Dl';
            
        case 'DoubleTrackCrossoverRail':
            return rev ? 'DCv' : 'DC.';
            
        case 'DoubleTrackTurnoutRail':
            if (dir === 'left') return rev ? 'DOlv' : 'DOl.';
            return rev ? 'DOrv' : 'DOr.';
            
        case 'TurnoutRail':
            if (dir === 'left') return turnoutType === 'L' ? 'POlv' : 'POl.';
            return turnoutType === 'L' ? 'POrv' : 'POr.';
            
        case 'Figure8PointRail':
            // pointType: 'R' or 'L', direction: 'left' or 'right'
            const isRType = type === 'R';
            const isReversed = dir === 'right';
            
            if (isRType) {
                return isReversed ? 'PErv' : 'PEr.';
            } else {
                return isReversed ? 'PElv' : 'PEl.';
            }
            
        case 'R30TrianglePointRail':
            return rev ? 'PTv' : 'PT.';
            
        case 'CrossPointRail':
            return rev ? 'PCv' : 'PC.';
            
        case 'UTurnRail':
            return type === 'U' ? 'PUu' : 'PUv';
            
        case 'R13PointRail':
            if (type === 'A') return dir === 'left' ? 'P3al' : 'P3a.';
            return dir === 'left' ? 'P3bl' : 'P3b.';
            
        case 'R22YPointRail':
            if (type === 'A') return rev ? 'P2av' : 'P2a.';
            return rev ? 'P2bv' : 'P2b.';
            
        case 'R15WidePointRail':
            if (type === 'A') return rev ? 'P5av' : 'P5a.';
            return rev ? 'P5bv' : 'P5b.';
            
        case 'R17ThreewayRail':
            if (type === 'A') return dir === 'left' ? 'P7al' : 'P7ar';
            return dir === 'left' ? 'P7bl' : 'P7br';
            
        default:
            return '?';
    }
}

// レールが接続されているか判定（シンプル版：全端点をチェック）
function isConnectedToAnyEndpoint(prevRail, currRail) {
    if (!prevRail || !currRail) return false;
    
    try {
        const prevEps = prevRail.getEndpoints();
        const currEps = currRail.getEndpoints();
        
        const tolerance = 0.5;
        
        for (let prevEp of prevEps) {
            for (let currEp of currEps) {
                const dx = Math.abs(prevEp.x - currEp.x);
                const dy = Math.abs(prevEp.y - currEp.y);
                let da = Math.abs(prevEp.angle - currEp.angle);
                da = Math.min(da, 360 - da);
                
                // 座標が一致 かつ 角度が一致
                if (dx < tolerance && dy < tolerance && da < 5) {
                    return true;
                }
            }
        }
        
        return false;
    } catch (error) {
        console.warn('接続判定エラー:', error);
        return false;
    }
}

// レイアウトをショートカット形式で保存
// ========================================
// キーボードショートカットシステム
// ========================================

// ショートカット定義（ジョイント・1/4は凸凹を区別）
const railShortcuts = {
    // 基本レール（1文字）
    'S': { type: 'straight' },
    'R': { type: 'curve', options: { direction: 'right' } },
    'L': { type: 'curve', options: { direction: 'left' } },
    'H': { type: 'halfStraight' },
    
    // S字レール
    'Zr': { type: 'slide', options: { reversed: false } },
    'Zl': { type: 'slide', options: { reversed: true } },
    
    // 外カーブ
    'Or': { type: 'outerCurve', options: { direction: 'right' } },
    'Ol': { type: 'outerCurve', options: { direction: 'left' } },
    
    // 倍長レール
    'BS': { type: 'doubleStraight' },
    'Br': { type: 'doubleLengthCurve', options: { direction: 'right' } },
    'Bl': { type: 'doubleLengthCurve', options: { direction: 'left' } },
    
    // 1/4レール（凸凸と凹凹を区別）
    'Qv': { type: 'quarterConvex' },
    'Qc': { type: 'quarterConcave' },
    
    // ジョイント（ユーザー入力はJのみ、Jv/Jcは保存データ読込用）
    'J': { type: 'joint' }, // 入力時に自動判定
    'Jv': { type: 'jointConvex' },  // 保存データ読込専用
    'Jc': { type: 'jointConcave' }, // 保存データ読込専用
    
    // 複線系
    'DS': { type: 'doubleTrack' },
    'Dr': { type: 'doubleCurve', options: { direction: 'right' } },
    'Dl': { type: 'doubleCurve', options: { direction: 'left' } },
    'DC.': { type: 'doubleCrossover', options: { reversed: false } },
    'DCv': { type: 'doubleCrossover', options: { reversed: true } },
    
    // 複線ターンアウト
    'DOl.': { type: 'doubleTurnout', options: { direction: 'left', reversed: false } },
    'DOlv': { type: 'doubleTurnout', options: { direction: 'left', reversed: true } },
    'DOr.': { type: 'doubleTurnout', options: { direction: 'right', reversed: false } },
    'DOrv': { type: 'doubleTurnout', options: { direction: 'right', reversed: true } },
    
    // ポイント系 - ターンアウト
    'POl.': { type: 'turnout', options: { direction: 'left', type: 'R' } },
    'POlv': { type: 'turnout', options: { direction: 'left', type: 'L' } },
    'POr.': { type: 'turnout', options: { direction: 'right', type: 'R' } },
    'POrv': { type: 'turnout', options: { direction: 'right', type: 'L' } },
    
    // ポイント系 - 8の字
    'PEr.': { type: 'figure8', options: { type: 'R', direction: 'left' } },
    'PErv': { type: 'figure8', options: { type: 'R', direction: 'right'} },
    'PEl.': { type: 'figure8', options: { type: 'L', direction: 'left'} },
    'PElv': { type: 'figure8', options: { type: 'L', direction: 'right' } },
    
    // ポイント系 - 三角・十字・Uターン
    'PT.': { type: 'r30', options: { reversed: false } },
    'PTv': { type: 'r30', options: { reversed: true } },
    'PC.': { type: 'crossPoint', options: { reversed: false } },
    'PCv': { type: 'crossPoint', options: { reversed: true } },
    'PUu': { type: 'uturn', options: { type: 'U' } },
    'PUv': { type: 'uturn', options: { type: 'V' } },
    
    // ポイント系 - R-13単複
    'P3a.': { type: 'r13', options: { type: 'A', direction: 'right' } },
    'P3al': { type: 'r13', options: { type: 'A', direction: 'left' } },
    'P3b.': { type: 'r13', options: { type: 'B', direction: 'right' } },
    'P3bl': { type: 'r13', options: { type: 'B', direction: 'left' } },
    
    // ポイント系 - R-22 Y字
    'P2a.': { type: 'r22', options: { type: 'A', reversed: false } },
    'P2av': { type: 'r22', options: { type: 'A', reversed: true } },
    'P2b.': { type: 'r22', options: { type: 'B', reversed: false } },
    'P2bv': { type: 'r22', options: { type: 'B', reversed: true } },
    
    // ポイント系 - R-15複線幅広
    'P5a.': { type: 'r15', options: { type: 'A', reversed: false } },
    'P5av': { type: 'r15', options: { type: 'A', reversed: true } },
    'P5b.': { type: 'r15', options: { type: 'B', reversed: false } },
    'P5bv': { type: 'r15', options: { type: 'B', reversed: true } },
    
    // ポイント系 - R-17三方向
    'P7al': { type: 'r17', options: { type: 'A', direction: 'left' } },
    'P7ar': { type: 'r17', options: { type: 'A', direction: 'right' } },
    'P7bl': { type: 'r17', options: { type: 'B', direction: 'left' } },
    'P7br': { type: 'r17', options: { type: 'B', direction: 'right' } }
};

// ショートカット入力バッファ
let shortcutBuffer = '';
let shortcutTimeout = null;

// キーボードイベントリスナー
document.addEventListener('keydown', (e) => {
    // 入力フィールドやテキストエリアでは無効化
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }
    
    // Ctrl/Cmd + その他のキーは無視
    if (e.ctrlKey || e.metaKey) {
        return;
    }
    
    // Enterキー: バッファを実行
    if (e.key === 'Enter') {
        e.preventDefault();
        if (shortcutBuffer.length > 0) {
            executeShortcutBuffer(shortcutBuffer);
            shortcutBuffer = '';
            updateShortcutDisplay();
        }
        return;
    }
    
    // Escapeキー: バッファをクリア
    if (e.key === 'Escape') {
        e.preventDefault();
        shortcutBuffer = '';
        updateShortcutDisplay();
        return;
    }
    
    // Backspaceキー: 最後の文字を削除
    if (e.key === 'Backspace') {
        e.preventDefault();
        shortcutBuffer = shortcutBuffer.slice(0, -1);
        updateShortcutDisplay();
        return;
    }
    
    // 通常の文字入力
    if (e.key.length === 1) {
        e.preventDefault();
        shortcutBuffer += e.key;
        updateShortcutDisplay();
        
        // タイムアウトをリセット（3秒後に自動クリア）
        clearTimeout(shortcutTimeout);
        shortcutTimeout = setTimeout(() => {
            if (shortcutBuffer.length > 0) {
                shortcutBuffer = '';
                updateShortcutDisplay();
            }
        }, 3000);
    }
});

// ショートカット実行
function executeShortcutBuffer(input) {
    let i = 0;
    
    while (i < input.length) {
        // 座標指定モード: @x,y,angle: または @x,y,anglev:
        if (input[i] === '@') {
            i++; // @をスキップ
            
            const colonIndex = input.indexOf(':', i);
            if (colonIndex === -1) {
                console.error('座標指定エラー: ":" が見つかりません');
                break;
            }
            
            const coordStr = input.substring(i, colonIndex);
            
            // 末尾の 'v' は凹進行フラグ
            const isReversed = coordStr.endsWith('v');
            const cleanCoord = isReversed ? coordStr.slice(0, -1) : coordStr;
            const coords = cleanCoord.split(',');
            
            if (coords.length < 3) {
                console.error('座標指定エラー: x,y,angle が必要です');
                break;
            }
            
            const x = parseFloat(coords[0]);
            const y = parseFloat(coords[1]);
            const angle = parseFloat(coords[2]);
            
            i = colonIndex + 1;
            
            // 最初のショートカットのみ座標指定で配置
            let firstInGroup = true;
            
            while (i < input.length && input[i] !== '@') {
                // 分岐記号 [n] の検出
                let epsIndex = 1; // デフォルトはeps1
                if (input[i] === '[') {
                    const closeBracket = input.indexOf(']', i);
                    if (closeBracket !== -1) {
                        epsIndex = parseInt(input.substring(i + 1, closeBracket));
                        i = closeBracket + 1;
                    }
                }
                
                let matched = false;
                for (let len = Math.min(5, input.length - i); len >= 1; len--) {
                    const candidate = input.substring(i, i + len);
                    if (railShortcuts[candidate]) {
                        const sc = railShortcuts[candidate];
                        if (firstInGroup) {
                            // 座標指定でレール配置
                            const railOptions = {
                                ...sc.options,
                                x: x,
                                y: y,
                                angle: angle,
                                isReversed: isReversed
                            };
                            addRailByType(sc.type, railOptions);
                            firstInGroup = false;
                        } else {
                            placeRailWithEps(candidate, sc, epsIndex);
                        }
                        i += len;
                        matched = true;
                        break;
                    }
                }
                if (!matched) {
                    console.warn(`未知のショートカット: ${input[i]}`);
                    i++;
                }
            }
        } else {
            // 通常の連続配置モード
            // 分岐記号 [n] の検出
            let epsIndex = 1;
            if (input[i] === '[') {
                const closeBracket = input.indexOf(']', i);
                if (closeBracket !== -1) {
                    epsIndex = parseInt(input.substring(i + 1, closeBracket));
                    i = closeBracket + 1;
                }
            }
            
            let matched = false;
            for (let len = Math.min(5, input.length - i); len >= 1; len--) {
                const candidate = input.substring(i, i + len);
                if (railShortcuts[candidate]) {
                    const sc = railShortcuts[candidate];
                    placeRailWithEps(candidate, sc, epsIndex);
                    i += len;
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                console.warn(`未知のショートカット: ${input[i]}`);
                i++;
            }
        }
    }
    
    drawAll();
}

// epsIndexを指定してレールを配置（eps1以外の分岐先対応）
function placeRailWithEps(candidate, sc, epsIndex) {
    if (epsIndex !== 1) {
        // eps1以外への接続：railProgressionのendpointIndexを変更
        const savedIndex = railProgression.endpointIndex;
        railProgression.endpointIndex = epsIndex;
        
        if (candidate === 'J') {
            addJointRail(railProgression.isReversed);
        } else if (candidate === 'Jv') {
            addJointRail(true);  // Jv → 凸凸
        } else if (candidate === 'Jc') {
            addJointRail(false); // Jc → 凹凹
        } else {
            addRailByType(sc.type, sc.options || {});
        }
        
        railProgression.endpointIndex = savedIndex;
    } else {
        if (candidate === 'J') {
            addJointRail(railProgression.isReversed);
        } else if (candidate === 'Jv') {
            addJointRail(true);  // Jv → 凸凸
        } else if (candidate === 'Jc') {
            addJointRail(false); // Jc → 凹凹
        } else {
            addRailByType(sc.type, sc.options || {});
        }
    }
}

// 座標指定でレールを配置（全レールタイプ対応）
function addRailByTypeSimple(railType, options = {}) {
    // 既存のボタンと同じロジックを使用
    switch(railType) {
        case 'straight':
            document.getElementById('addStraight').click();
            break;
        case 'curve':
            if (options.direction === 'right') {
                document.getElementById('addRightCurve').click();
            } else {
                document.getElementById('addLeftCurve').click();
            }
            break;
        case 'halfStraight':
            document.getElementById('addHalfStraight').click();
            break;
        case 'doubleStraight':
            document.getElementById('addDoubleStraight').click();
            break;
        case 'slide':
            addRailByType('slide', { reversed: !!options.reversed });
            break;
        case 'outerCurve':
            if (options.direction === 'right') {
                document.getElementById('addRightOuterCurve').click();
            } else {
                document.getElementById('addLeftOuterCurve').click();
            }
            break;
        case 'doubleLengthCurve':
            if (options.direction === 'right') {
                document.getElementById('addDoubleLengthCurveRight').click();
            } else {
                document.getElementById('addDoubleLengthCurveLeft').click();
            }
            break;
        case 'quarterConvex':
            document.getElementById('addQuarterV').click();
            break;
        case 'quarterConcave':
            document.getElementById('addQuarterC').click();
            break;
        case 'jointConvex':
            // Jv: 凸凸ジョイント（凹進行を停止）
            addJointRail(true); // isConcaveProgression=true → 凸凸を配置
            break;
        case 'jointConcave':
            // Jc: 凹凹ジョイント（凹進行を開始）
            addJointRail(false); // isConcaveProgression=false → 凹凹を配置
            break;
        case 'doubleTrack':
            document.getElementById('addDoubleTrack').click();
            break;
        case 'doubleCurve':
            if (options.direction === 'right') {
                document.getElementById('addDoubleCurveRight').click();
            } else {
                document.getElementById('addDoubleCurveLeft').click();
            }
            break;
        case 'doubleCrossover':
            if (options.reversed) {
                document.getElementById('addDoubleTrackCrossoverRev').click();
            } else {
                document.getElementById('addDoubleTrackCrossover').click();
            }
            break;
        case 'doubleTurnout':
            const dtId = `addDoubleTrackTurnout${options.direction === 'left' ? 'Left' : 'Right'}${options.reversed ? 'Rev' : ''}`;
            document.getElementById(dtId).click();
            break;
        case 'turnout':
            let toId;
            if (options.type === 'L') {
                // L型
                toId = `addTurnout${options.direction === 'left' ? 'Left' : 'Right'}L`;
            } else {
                // R型
                toId = `addTurnout${options.direction === 'left' ? 'Left' : 'Right'}`;
            }
            console.log('Turnout:', options, '→ Button ID:', toId);
            const toButton = document.getElementById(toId);
            if (!toButton) {
                console.error('ボタンが見つかりません:', toId);
                return;
            }
            toButton.click();
            break;
        case 'figure8':
            // ボタンID対応:
            // PEr.(type:R, reversed:false) → addFigure8Point
            // PErv(type:R, reversed:true)  → addFigure8PointRRev
            // PEl.(type:L, reversed:false) → addFigure8PointL
            // PElv(type:L, reversed:true)  → addFigure8PointLRev
            let f8Id;
            if (options.type === 'R') {
                f8Id = options.reversed ? 'addFigure8PointRRev' : 'addFigure8Point';
            } else {
                f8Id = options.reversed ? 'addFigure8PointLRev' : 'addFigure8PointL';
            }
            document.getElementById(f8Id).click();
            break;
        case 'r30':
            if (options.reversed) {
                document.getElementById('addR30TrianglePointRev').click();
            } else {
                document.getElementById('addR30TrianglePoint').click();
            }
            break;
        case 'crossPoint':
            if (options.reversed) {
                document.getElementById('addCrossPointRev').click();
            } else {
                document.getElementById('addCrossPoint').click();
            }
            break;
        case 'uturn':
            if (options.type === 'U') {
                document.getElementById('addUTurnRailU').click();
            } else {
                document.getElementById('addUTurnRailV').click();
            }
            break;
        case 'r13':
            // addR13PointBRight, addR13PointBLeft, addR13PointARight, addR13PointALeft
            const r13Id = `addR13Point${options.type}${options.direction === 'left' ? 'Left' : 'Right'}`;
            document.getElementById(r13Id).click();
            break;
        case 'r22':
            // addR22YPointA, addR22YPointARev, addR22YPointB, addR22YPointBRev
            const r22Id = `addR22YPoint${options.type}${options.reversed ? 'Rev' : ''}`;
            document.getElementById(r22Id).click();
            break;
        case 'r15':
            const r15Id = `addR15Wide${options.type}${options.reversed ? 'Rev' : ''}`;
            document.getElementById(r15Id).click();
            break;
        case 'r17':
            const r17Id = `addR17ThreewayPoint${options.type}${options.direction === 'left' ? 'Left' : 'Right'}`;
            document.getElementById(r17Id).click();
            break;
        default:
            console.warn('Unknown rail type:', railType);
    }
}

// ショートカット表示エリアの更新
function updateShortcutDisplay() {
    let display = document.getElementById('shortcutDisplay');
    if (!display) {
        // 表示エリアを作成
        display = document.createElement('div');
        display.id = 'shortcutDisplay';
        display.style.position = 'fixed';
        display.style.bottom = '10px';
        display.style.right = '10px';
        display.style.background = 'rgba(0, 0, 0, 0.8)';
        display.style.color = 'white';
        display.style.padding = '10px 15px';
        display.style.borderRadius = '5px';
        display.style.fontFamily = 'monospace';
        display.style.fontSize = '16px';
        display.style.zIndex = '10000';
        display.style.display = 'none';
        document.body.appendChild(display);
    }
    
    if (shortcutBuffer.length > 0) {
        display.textContent = `入力: ${shortcutBuffer}_ (Enter: 実行 / Esc: クリア)`;
        display.style.display = 'block';
    } else {
        display.style.display = 'none';
    }
}

console.log('キーボードショートカットシステム初期化完了');
console.log('使い方: S, R, L などを入力してEnterキーで配置');

// ========================================
// ショートカット形式の保存/読込
// ========================================

// レールをショートカットに変換
function railToShortcut(rail) {
    const className = rail.constructor.name;
    const dir = rail.direction;
    const rev = rail.isReversed;
    const type = rail.pointType || rail.ThreewayType || rail.type; // UTurnRail対応
    const turnoutType = rail.turnoutType;
    
    switch(className) {
        case 'StraightRail':
            if (rail.length === RAIL_LENGTH * 2) return 'BS';
            if (rail.length === RAIL_LENGTH * 0.5) return 'H';
            if (rail.length === RAIL_LENGTH * 0.25) {
                // railTypeプロパティを優先
                if (rail.railType === 'QuarterVV') return 'Qv';
                if (rail.railType === 'QuarterCC') return 'Qc';
                // startType/endTypeで判定
                if (rail.startType === 'convex' && rail.endType === 'convex') return 'Qv';
                if (rail.startType === 'concave' && rail.endType === 'concave') return 'Qc';
                // 通常は凹→凸なのでQvをフォールバック
                return 'Qv';
            }
            if (rail.length === RAIL_LENGTH / 6) {
                // railTypeプロパティを優先
                if (rail.railType === 'SixthVV') return 'Jv';
                if (rail.railType === 'SixthCC') return 'Jc';
                // startType/endTypeで判定
                if (rail.startType === 'convex' && rail.endType === 'convex') return 'Jv';
                if (rail.startType === 'concave' && rail.endType === 'concave') return 'Jc';
                // フォールバック
                return 'Jv';
            }
            return 'S';
            
        case 'Curve':
            if (rail.radius > RAIL_LENGTH + 10) {
                return dir === 'right' ? 'Or' : 'Ol';
            }
            return dir === 'right' ? 'R' : 'L';
            
        case 'DoubleLengthCurve':
            return dir === 'right' ? 'Br' : 'Bl';
            
        case 'Slide':
            return rail.slide > 0 ? 'Zr' : 'Zl';
            
        case 'DoubleTrackRail':
            return 'DS';
            
        case 'DoubleCurveRail':
            return dir === 'right' ? 'Dr' : 'Dl';
            
        case 'DoubleTrackCrossoverRail':
            return rev ? 'DCv' : 'DC.';
            
        case 'DoubleTrackTurnoutRail':
            if (dir === 'left') return rev ? 'DOlv' : 'DOl.';
            return rev ? 'DOrv' : 'DOr.';
            
        case 'TurnoutRail':
            if (dir === 'left') return turnoutType === 'L' ? 'POlv' : 'POl.';
            return turnoutType === 'L' ? 'POrv' : 'POr.';
            
        case 'Figure8PointRail':
            // pointType: 'R' or 'L', direction: 'left' or 'right'
            const isRType = type === 'R';
            const isReversed = dir === 'right';
            
            if (isRType) {
                return isReversed ? 'PErv' : 'PEr.';
            } else {
                return isReversed ? 'PElv' : 'PEl.';
            }
            
        case 'R30TrianglePointRail':
            return rev ? 'PTv' : 'PT.';
            
        case 'CrossPointRail':
            return rev ? 'PCv' : 'PC.';
            
        case 'UTurnRail':
            return type === 'U' ? 'PUu' : 'PUv';
            
        case 'R13PointRail':
            if (type === 'A') return dir === 'left' ? 'P3al' : 'P3a.';
            return dir === 'left' ? 'P3bl' : 'P3b.';
            
        case 'R22YPointRail':
            if (type === 'A') return rev ? 'P2av' : 'P2a.';
            return rev ? 'P2bv' : 'P2b.';
            
        case 'R15WidePointRail':
            if (type === 'A') return rev ? 'P5av' : 'P5a.';
            return rev ? 'P5bv' : 'P5b.';
            
        case 'R17ThreewayRail':
            if (type === 'A') return dir === 'left' ? 'P7al' : 'P7ar';
            return dir === 'left' ? 'P7bl' : 'P7br';
            
        default:
            return '?';
    }
}

// 連続判定（シンプル版）
function isConnectedToAnyEndpoint(prevRail, currRail) {
    if (!prevRail || !currRail) return false;
    
    try {
        const prevEps = prevRail.getEndpoints();
        const currEps = currRail.getEndpoints();
        
        const tolerance = 0.5;
        
        for (let prevEp of prevEps) {
            for (let currEp of currEps) {
                const dx = Math.abs(prevEp.x - currEp.x);
                const dy = Math.abs(prevEp.y - currEp.y);
                let da = Math.abs(prevEp.angle - currEp.angle);
                da = Math.min(da, 360 - da); // 角度差の最小値
                
                if (dx < tolerance && dy < tolerance && da < 5) {
                    return true;
                }
            }
        }
        
        return false;
    } catch (error) {
        console.warn('連続判定エラー:', error);
        return false;
    }
}

// ショートカット形式で保存
// ショートカット形式で保存（接続状態ベース）
// ========================================
// メイン保存関数
// ========================================
function saveLayoutAsShortcut() {
    if (rails.length === 0) return '';
    
    console.log('=== saveLayoutAsShortcut 開始 ===');
    console.log('総レール数:', rails.length);
    
    const clusters = buildAllClusters();
    console.log('クラスタ数:', clusters.length);
    
    let result = '';
    
    for (let clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
        const cluster = clusters[clusterIndex];
        console.log(`\n--- クラスタ ${clusterIndex + 1} (${cluster.length}レール) ---`);
        console.log('レールID:', cluster.map(r => r.id).join(', '));
        
        let segmentCount = 0;
        while (cluster.length > 0) {
            segmentCount++;
            console.log(`  セグメント ${segmentCount} 開始 (残り${cluster.length}レール)`);
            
            const segment = serializeOneSegment(cluster);
            console.log(`  セグメント ${segmentCount} 完了: ${segment}`);
            console.log(`  残りレール:`, cluster.map(r => r.id).join(', ') || 'なし');
            
            result += segment;
        }
    }
    
    console.log('\n=== 最終結果 ===');
    console.log(result);
    console.log('=== saveLayoutAsShortcut 終了 ===\n');
    
    return result;
}

// ========================================
// フェーズ1: クラスタ構築
// ========================================

// 全レールをクラスタに分割
function buildAllClusters() {
    const remainingRails = [...rails];
    const clusters = [];
    
    console.log('クラスタ構築開始');
    
    while (remainingRails.length > 0) {
        const startRail = remainingRails[0];
        console.log(`  起点レール: ${startRail.id} (残り${remainingRails.length})`);
        
        const cluster = buildSingleCluster(startRail, remainingRails);
        console.log(`  → クラスタ完成 (${cluster.length}レール):`, cluster.map(r => r.id).join(', '));
        
        clusters.push(cluster);
    }
    
    return clusters;
}

// 1つのクラスタを構築（幅優先探索）
function buildSingleCluster(startRail, remainingRails) {
    const cluster = [startRail];
    const visited = new Set([startRail.id]);
    const queue = [startRail];
    
    const index = remainingRails.findIndex(r => r.id === startRail.id);
    if (index !== -1) remainingRails.splice(index, 1);
    
    while (queue.length > 0) {
        const rail = queue.shift();
        const eps = rail.getEndpoints();
        
        // eps[0]とeps[1]のみを探索（eps[2]以降は別クラスタ）
        const maxEpsIndex = Math.min(eps.length, 2);
        
        for (let epIndex = 0; epIndex < maxEpsIndex; epIndex++) {
            const ep = eps[epIndex];
            
            for (let i = remainingRails.length - 1; i >= 0; i--) {
                const otherRail = remainingRails[i];
                if (visited.has(otherRail.id)) continue;
                
                const otherEps = otherRail.getEndpoints();
                for (let j = 0; j < otherEps.length; j++) {
                    // ★重要: 接続先もeps[0]またはeps[1]のみ
                    if (j >= 2) continue;
                    
                    if (isEndpointsConnected(ep, otherEps[j], rail, otherRail, cluster)) {
                        cluster.push(otherRail);
                        visited.add(otherRail.id);
                        queue.push(otherRail);
                        remainingRails.splice(i, 1);
                        break;
                    }
                }
                if (visited.has(otherRail.id)) break;
            }
        }
    }
    
    // ★重要: rails配列の順序でソート
    cluster.sort((a, b) => {
        const idxA = rails.findIndex(r => r.id === a.id);
        const idxB = rails.findIndex(r => r.id === b.id);
        return idxA - idxB;
    });
    
    return cluster;
}

// 2つの端点が接続しているか判定（競合チェック付き）
function isEndpointsConnected(ep1, ep2, rail1, rail2, cluster) {
    const dx = Math.abs(ep1.x - ep2.x);
    const dy = Math.abs(ep1.y - ep2.y);
    let da = Math.abs(ep1.angle - ep2.angle);
    da = Math.min(da, 360 - da);
    
    const tolerance = 0.5;
    const angleTolerance = 5;
    
    if (dx >= tolerance || dy >= tolerance || da >= angleTolerance) {
        return false;
    }
    
    // ★重要: 凸と凹は必ず対になる
    // 凸→凸、凹→凹の接続は不可
    if (ep1.type === ep2.type) {
        return false; // 同じタイプ同士は接続できない
    }
    
    if (!cluster) {
        return true;
    }
    
    // ep1の位置に他の競合端点があるか
    const competitorsAtEp1 = findCompetingRails(ep1, rail1, cluster, tolerance, angleTolerance);
    if (competitorsAtEp1.length > 0) {
        if (!isClosestNeighbor(rail1, rail2, competitorsAtEp1, cluster)) {
            return false;
        }
    }
    
    // ep2の位置に他の競合端点があるか
    const competitorsAtEp2 = findCompetingRails(ep2, rail2, cluster, tolerance, angleTolerance);
    if (competitorsAtEp2.length > 0) {
        if (!isClosestNeighbor(rail2, rail1, competitorsAtEp2, cluster)) {
            return false;
        }
    }
    
    return true;
}

// 指定位置に接続可能な端点を持つ競合レールを探す
function findCompetingRails(targetEp, excludeRail, cluster, tolerance, angleTolerance) {
    const competitors = [];
    
    for (let rail of cluster) {
        if (rail.id === excludeRail.id) continue;
        
        const eps = rail.getEndpoints();
        for (let ep of eps) {
            const dx = Math.abs(ep.x - targetEp.x);
            const dy = Math.abs(ep.y - targetEp.y);
            let da = Math.abs(ep.angle - targetEp.angle);
            da = Math.min(da, 360 - da);
            
            // 座標が一致 かつ 凸凹が対応（異なる）
            if (dx < tolerance && dy < tolerance && da < angleTolerance && ep.type !== targetEp.type) {
                competitors.push(rail);
                break;
            }
        }
    }
    
    return competitors;
}

// baseRailにとって、targetRailがcompetitorsの中で最も近い隣接レールか判定
function isClosestNeighbor(baseRail, targetRail, competitors, cluster) {
    // 元のrails配列でのインデックスを使用
    const baseIdx = rails.findIndex(r => r.id === baseRail.id);
    const targetIdx = rails.findIndex(r => r.id === targetRail.id);
    
    if (baseIdx === -1 || targetIdx === -1) {
        return true;
    }
    
    const targetDist = Math.abs(baseIdx - targetIdx);
    
    for (let competitor of competitors) {
        const competitorIdx = rails.findIndex(r => r.id === competitor.id);
        if (competitorIdx === -1) continue;
        
        const competitorDist = Math.abs(baseIdx - competitorIdx);
        
        if (competitorDist < targetDist) {
            return false;
        }
    }
    
    return true;
}

// ========================================
// フェーズ2: クラスタ内の開始点決定
// ========================================

// クラスタ内の未接続端点を探す
function findUnconnectedEndpoints(cluster) {
    const unconnectedConcave = [];
    const unconnectedConvex = [];
    
    for (let rail of cluster) {
        const eps = rail.getEndpoints();
        
        for (let i = 0; i < eps.length; i++) {
            const ep = eps[i];
            
            // この端点に接続可能な全てのレールを見つける
            const candidates = [];
            
            for (let otherRail of cluster) {
                if (otherRail.id === rail.id) continue;
                
                const otherEps = otherRail.getEndpoints();
                for (let j = 0; j < otherEps.length; j++) {
                    // 座標・角度・凸凹のチェックのみ（競合チェックなし）
                    const dx = Math.abs(ep.x - otherEps[j].x);
                    const dy = Math.abs(ep.y - otherEps[j].y);
                    let da = Math.abs(ep.angle - otherEps[j].angle);
                    da = Math.min(da, 360 - da);
                    
                    if (dx < 0.5 && dy < 0.5 && da < 5 && ep.type !== otherEps[j].type) {
                        candidates.push(otherRail);
                        break; // 同じレールの複数端点は1回だけ
                    }
                }
            }
            
            // 候補がある場合、最も配列順序が近いレールとのみ接続していると判定
            if (candidates.length > 0) {
                const railIdx = rails.findIndex(r => r.id === rail.id);
                let minDist = Infinity;
                let closestRail = null;
                
                for (let candidate of candidates) {
                    const candidateIdx = rails.findIndex(r => r.id === candidate.id);
                    const dist = Math.abs(railIdx - candidateIdx);
                    if (dist < minDist) {
                        minDist = dist;
                        closestRail = candidate;
                    }
                }
                
                // 最も近いレール以外の候補は無視 = その端点は未接続扱い
                if (candidates.length > 1) {
                    // 複数候補がある = 最も近いもの以外は接続していない
                    // → この端点は未接続として扱う
                    const point = { rail, epsIndex: i };
                    if (ep.type === 'concave') {
                        unconnectedConcave.push(point);
                    } else {
                        unconnectedConvex.push(point);
                    }
                }
                // 候補が1つだけ = 確実に接続している（未接続ではない）
            } else {
                // 候補が0 = 確実に未接続
                const point = { rail, epsIndex: i };
                if (ep.type === 'concave') {
                    unconnectedConcave.push(point);
                } else {
                    unconnectedConvex.push(point);
                }
            }
        }
    }
    
    return { unconnectedConcave, unconnectedConvex };
}

// クラスタの開始点を決定
function determineStartPoint(cluster) {
    const { unconnectedConcave, unconnectedConvex } = findUnconnectedEndpoints(cluster);
    
    console.log(`    未接続凹: ${unconnectedConcave.length}個`, 
                unconnectedConcave.map(p => `${p.rail.id}[${p.epsIndex}]`).join(', '));
    console.log(`    未接続凸: ${unconnectedConvex.length}個`,
                unconnectedConvex.map(p => `${p.rail.id}[${p.epsIndex}]`).join(', '));
    
    if (unconnectedConcave.length > 0) {
        // ケースA: 凹端点あり → そこから通常進行で開始（vフラグなし）
        const start = { ...unconnectedConcave[0], isReversed: false };
        console.log(`    → ケースA: 凹端点 ${start.rail.id}[${start.epsIndex}] (通常進行)`);
        return start;
        
    } else if (unconnectedConvex.length > 0) {
        // ケースB: 凸端点のみ → そこから凹進行で開始（vフラグ付き）
        const start = { ...unconnectedConvex[0], isReversed: true };
        console.log(`    → ケースB: 凸端点 ${start.rail.id}[${start.epsIndex}] (凹進行・vフラグ)`);
        return start;
        
    } else {
        // ケースC: ループ → 先頭レールの凹端点から通常進行
        const firstRail = cluster[0];
        const eps = firstRail.getEndpoints();
        
        for (let i = 0; i < eps.length; i++) {
            if (eps[i].type === 'concave') {
                console.log(`    → ケースC: ループ ${firstRail.id}[${i}] (凹・通常進行)`);
                return { rail: firstRail, epsIndex: i, isReversed: false };
            }
        }
        
        console.log(`    → ケースC: ループ ${firstRail.id}[0] (通常進行)`);
        return { rail: firstRail, epsIndex: 0, isReversed: false };
    }
}

// ========================================
// フェーズ3: 1セグメントの文字列化（DFS）
// ========================================

// 1つのセグメントをシリアライズ（clusterを破壊的に消費）
function serializeOneSegment(cluster) {
    const startPoint = determineStartPoint(cluster);
    const { rail: startRail, epsIndex: startEpsIndex, isReversed } = startPoint;
    
    const x = startRail.x.toFixed(1);
    const y = startRail.y.toFixed(1);
    const angle = startRail.angle.toFixed(0);
    const vFlag = isReversed ? 'v' : '';
    const shortcut = railToShortcut(startRail);
    
    let result = `@${x},${y},${angle}${vFlag}:${shortcut}`;
    console.log(`    開始: ${startRail.id}[${startEpsIndex}から] → ${result}`);
    
    const startIndex = cluster.findIndex(r => r.id === startRail.id);
    if (startIndex !== -1) cluster.splice(startIndex, 1);
    
    const visited = new Set([startRail.id]);
    
    // 開始レールから最初の接続を探す（開始epsIndexは除外）
    let currentRail = startRail;
    let stepCount = 0;
    
    // 最初の接続を探す（開始端点を除外）
    const firstConnection = findNextConnectionExcluding(currentRail, cluster, visited, startEpsIndex);
    
    if (!firstConnection) {
        // 開始レールだけで終了（孤立レール）
        return result;
    }
    
    // DFSで辿る（最初の接続から開始）
    const { rail: firstRail, epsIndex: firstEpsIndex } = firstConnection;
    
    if (firstEpsIndex >= 2) {
        // 分岐への接続 → このセグメントは開始レールだけ
        return result;
    }
    
    // 最初のレールを追加
    const firstShortcut = railToShortcut(firstRail);
    const firstText = firstEpsIndex === 0 ? firstShortcut : `[${firstEpsIndex}]${firstShortcut}`;
    result += firstText;
    console.log(`      [${++stepCount}] ${currentRail.id} → ${firstRail.id}[${firstEpsIndex}] : ${firstText}`);
    
    const firstIndex = cluster.findIndex(r => r.id === firstRail.id);
    if (firstIndex !== -1) cluster.splice(firstIndex, 1);
    
    visited.add(firstRail.id);
    const stack = [{ rail: firstRail, enteredFrom: firstEpsIndex }];
    
    while (stack.length > 0) {
        const { rail: currentRail, enteredFrom } = stack[stack.length - 1];
        
        const nextConnection = findNextConnectionExcluding(currentRail, cluster, visited, enteredFrom);
        
        if (!nextConnection) {
            console.log(`      [${++stepCount}] ${currentRail.id} から接続なし → pop`);
            stack.pop();
            continue;
        }
        
        const { rail: nextRail, epsIndex: nextEpsIndex } = nextConnection;
        
        if (nextEpsIndex >= 2) {
            console.log(`      [${++stepCount}] ${currentRail.id} → ${nextRail.id}[${nextEpsIndex}] (分岐) → 中断`);
            stack.pop();
            continue;
        }
        
        const nextShortcut = railToShortcut(nextRail);
        // 通常接続: eps[0]（凹）から入る場合
        // 分岐接続: eps[1]以降から入る場合
        const addText = nextEpsIndex === 0 ? nextShortcut : `[${nextEpsIndex}]${nextShortcut}`;
        result += addText;
        console.log(`      [${++stepCount}] ${currentRail.id} → ${nextRail.id}[${nextEpsIndex}] : ${addText}`);
        
        const nextIndex = cluster.findIndex(r => r.id === nextRail.id);
        if (nextIndex !== -1) cluster.splice(nextIndex, 1);
        
        visited.add(nextRail.id);
        stack.push({ rail: nextRail, enteredFrom: nextEpsIndex });
    }
    
    return result;
}

// 現在のレールから次の接続を探す（特定の端点を除外）
function findNextConnectionExcluding(currentRail, cluster, visited, excludeEpsIndex) {
    const eps = currentRail.getEndpoints();
    
    for (let i = 0; i < eps.length; i++) {
        // 入口端点はスキップ
        if (i === excludeEpsIndex) continue;
        
        const ep = eps[i];
        
        for (let otherRail of cluster) {
            if (visited.has(otherRail.id)) continue;
            
            const otherEps = otherRail.getEndpoints();
            for (let j = 0; j < otherEps.length; j++) {
                if (isEndpointsConnected(ep, otherEps[j], currentRail, otherRail, cluster)) {
                    return { rail: otherRail, epsIndex: j };
                }
            }
        }
    }
    
    return null;
}

// 現在のレールから次の接続を探す（旧版・互換性のため残す）
function findNextConnection(currentRail, cluster, visited) {
    const eps = currentRail.getEndpoints();
    
    for (let i = 0; i < eps.length; i++) {
        const ep = eps[i];
        
        for (let otherRail of cluster) {
            if (visited.has(otherRail.id)) continue;
            
            const otherEps = otherRail.getEndpoints();
            for (let j = 0; j < otherEps.length; j++) {
                if (isEndpointsConnected(ep, otherEps[j], currentRail, otherRail, cluster)) {
                    return { rail: otherRail, epsIndex: j };
                }
            }
        }
    }
    
    return null;
}
function buildCluster(startRail, excludeSet) {
    const cluster = [startRail];
    const visited = new Set([startRail.id]);
    const queue = [startRail];
    
    while (queue.length > 0) {
        const rail = queue.shift();
        const eps = rail.getEndpoints();
        
        // 各端点から接続されているレールを探す
        for (let ep of eps) {
            for (let otherRail of rails) {
                if (visited.has(otherRail.id) || excludeSet.has(otherRail.id)) continue;
                
                const otherEps = otherRail.getEndpoints();
                for (let otherEp of otherEps) {
                    if (isEndpointsConnected(ep, otherEp)) {
                        cluster.push(otherRail);
                        visited.add(otherRail.id);
                        queue.push(otherRail);
                        break;
                    }
                }
            }
        }
    }
    
    return cluster;
}

// 2つの端点が接続しているか
function isEndpointsConnected(ep1, ep2) {
    const dx = Math.abs(ep1.x - ep2.x);
    const dy = Math.abs(ep1.y - ep2.y);
    let da = Math.abs(ep1.angle - ep2.angle);
    da = Math.min(da, 360 - da);
    
    return dx < 0.5 && dy < 0.5 && da < 5;
}

// クラスタの開始点を探す
function findClusterStart(cluster) {
    // 凹端点（未接続）を探す
    for (let rail of cluster) {
        const eps = rail.getEndpoints();
        for (let i = 0; i < eps.length; i++) {
            const ep = eps[i];
            if (ep.type !== 'concave') continue;
            
            // この端点が他のレールと接続していないか確認
            let isConnected = false;
            for (let otherRail of cluster) {
                if (otherRail.id === rail.id) continue;
                const otherEps = otherRail.getEndpoints();
                for (let otherEp of otherEps) {
                    if (isEndpointsConnected(ep, otherEp)) {
                        isConnected = true;
                        break;
                    }
                }
                if (isConnected) break;
            }
            
            if (!isConnected) {
                return { rail, epsIndex: i, isReversed: true };
            }
        }
    }
    
    // 凸端点（未接続）を探す
    for (let rail of cluster) {
        const eps = rail.getEndpoints();
        for (let i = 0; i < eps.length; i++) {
            const ep = eps[i];
            if (ep.type !== 'convex') continue;
            
            let isConnected = false;
            for (let otherRail of cluster) {
                if (otherRail.id === rail.id) continue;
                const otherEps = otherRail.getEndpoints();
                for (let otherEp of otherEps) {
                    if (isEndpointsConnected(ep, otherEp)) {
                        isConnected = true;
                        break;
                    }
                }
                if (isConnected) break;
            }
            
            if (!isConnected) {
                return { rail, epsIndex: i, isReversed: false };
            }
        }
    }
    
    // 全て接続済み（ループ）の場合、最初のレールから
    return { rail: cluster[0], epsIndex: 1, isReversed: false };
}

// クラスタを文字列化
function serializeCluster(startPoint, savedSet) {
    let result = '';
    let currentRail = startPoint.rail;
    let currentEpsIndex = startPoint.epsIndex;
    
    // 座標指定で開始
    const x = currentRail.x.toFixed(1);
    const y = currentRail.y.toFixed(1);
    const angle = currentRail.angle.toFixed(0);
    const revFlag = startPoint.isReversed ? 'v' : '';
    const shortcut = railToShortcut(currentRail);
    result += `@${x},${y},${angle}${revFlag}:${shortcut}`;
    savedSet.add(currentRail.id);
    
    // 連続配置を辿る
    const visited = new Set([currentRail.id]);
    
    while (true) {
        const eps = currentRail.getEndpoints();
        
        // 現在のレールの各端点から、未訪問の接続レールを探す
        let nextRail = null;
        let nextEpsIndex = -1;
        let usedCurrentEpsIndex = -1;
        
        for (let i = 0; i < eps.length; i++) {
            const currentEp = eps[i];
            
            for (let otherRail of rails) {
                if (visited.has(otherRail.id)) continue;
                
                const otherEps = otherRail.getEndpoints();
                for (let j = 0; j < otherEps.length; j++) {
                    if (isEndpointsConnected(currentEp, otherEps[j])) {
                        nextRail = otherRail;
                        nextEpsIndex = j;
                        usedCurrentEpsIndex = i;
                        break;
                    }
                }
                if (nextRail) break;
            }
            if (nextRail) break;
        }
        
        if (!nextRail) break;
        
        // 次のレールを追加
        const nextShortcut = railToShortcut(nextRail);
        if (nextEpsIndex === 1) {
            result += nextShortcut; // 通常接続
        } else {
            result += `[${nextEpsIndex}]${nextShortcut}`; // 分岐接続
        }
        
        savedSet.add(nextRail.id);
        visited.add(nextRail.id);
        
        currentRail = nextRail;
    }
    
    return result;
}

// テキストボックスからのショートカット実行
document.getElementById('executeShortcut').addEventListener('click', () => {
    const input = document.getElementById('shortcutInput').value.trim();
    if (input) {
        executeShortcutBuffer(input);
    }
});

// テキストボックスのクリア
document.getElementById('clearShortcut').addEventListener('click', () => {
    document.getElementById('shortcutInput').value = '';
});

// テキストボックスでEnterキーを押したら実行
document.getElementById('shortcutInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('executeShortcut').click();
    }
});

    </script>
</body>

</html>
