<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>プラレールレイアウトシミュレータ</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* 動的なビューポート高さ（iOS対応） */
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 300px;
            max-height: calc(100vh - 200px);
            max-height: calc(100dvh - 200px);
            border-bottom: 2px solid #333;
            background: #f0f0f0;
            touch-action: none;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            touch-action: none;
        }
        
        .controls {
            flex-shrink: 0;
            height: 200px;
            min-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            background: #fafafa;
        }
        
        @media (min-height: 800px) {
            .controls {
                height: 300px;
                min-height: 300px;
            }
            #canvas-container {
                max-height: calc(100vh - 300px);
                max-height: calc(100dvh - 300px);
            }
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        button {
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #666;
            background: #fff;
            border-radius: 5px;
            cursor: pointer;
            flex: 1;
            min-width: 80px;
            touch-action: manipulation;
        }
        
        button:active {
            background: #ddd;
        }
        
        .rail-buttons button {
            min-width: 100px;
        }
        
        .slot-btn {
            font-size: 12px !important;
            padding: 8px 5px !important;
            min-width: 0 !important;
        }
        
        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 1px solid #666;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        textarea {
            min-height: 80px;
            font-family: monospace;
        }
        
        .context-menu {
            position: fixed;
            background-color: white;
            border: 2px solid black;
            border-radius: 5px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .context-menu div {
            padding: 15px 20px;
            cursor: pointer;
            font-size: 16px;
            border-bottom: 1px solid #ddd;
        }
        
        .context-menu div:last-child {
            border-bottom: none;
        }
        
        .context-menu div:active {
            background-color: #ddd;
        }
        
        .section-title {
            font-weight: bold;
            margin: 10px 0 5px 0;
            color: #333;
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        
        @media (max-width: 600px) {
            button {
                font-size: 12px;
                padding: 10px 12px;
            }
            
            .color-legend {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <div class="color-legend">
        <div class="color-item">
            <div class="color-box" style="background: deepskyblue;"></div>
            <span>直線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: pink;"></div>
            <span>カーブ</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: lawngreen;"></div>
            <span>ターンアウト</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: plum;"></div>
            <span>8の字</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: violet;"></div>
            <span>倍曲線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: red;"></div>
            <span>R-10 Uターン</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: purple;"></div>
            <span>外カーブ</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: cyan;"></div>
            <span>複線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: lightcyan;"></div>
            <span>複曲線</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: turquoise;"></div>
            <span>複線渡り</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: lightseagreen;"></div>
            <span>複線T.O.</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: coral;"></div>
            <span>十字</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: orange;"></div>
            <span>単複</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: yellowgreen;"></div>
            <span>Y字</span>
        </div>
        <div class="color-item">
            <div class="color-box" style="background: mediumseagreen;"></div>
            <span>幅広</span>
        </div>
    </div>

    <div class="controls">
        <div class="section-title">基本レール</div>
        <div class="button-group rail-buttons">
            <button id="addStraight">直線</button>
            <button id="addRightCurve">右カーブ</button>
            <button id="addLeftCurve">左カーブ</button>
        </div>
        
        <div class="button-group">
            <button id="addHalfStraight">1/2直線</button>
            <button id="addDoubleStraight">2倍直線</button>
            <button id="addDoubleLengthCurveRight">倍曲線(右)</button>
            <button id="addDoubleLengthCurveLeft">倍曲線(左)</button>
        </div>
         <div class="button-group">
            <button id="addQuarterStraight">1/4 (凹凸)</button>
            <button id="addQuarterCC">1/4 (凹凹)</button>
            <button id="addQuarterVV">1/4 (凸凸)</button>
            <button id="addJointCC">1/6 (凹凹)</button>
            <button id="addJointVV">1/6 (凸凸)</button>
        </div>
      

        <div class="section-title">ポイント</div>
        <div class="button-group">
            <button id="addTurnoutLeft">ターンアウト (R)</button>
            <button id="addTurnoutRight">(R裏)</button>
            <button id="addTurnoutLeftL">(L)</button>
            <button id="addTurnoutRightL">(L裏)</button>
        </div>
        
        <div class="button-group">
            <button id="addFigure8Point">8の字 (R)</button>
            <button id="addFigure8PointRRev">(R裏)</button>
            <button id="addFigure8PointL">(L)</button>
            <button id="addFigure8PointLRev">(L裏)</button>
        </div>
<div class="button-group">
            <button id="addCrossPoint">十字ポイント</button>
        </div>

        

        <div class="section-title">複線・複曲線レール</div>
        <div class="button-group">
            <button id="addDoubleTrack">複線直線</button>
            <button id="addDoubleCurveLeft">複曲線(左)</button>
            <button id="addDoubleCurveRight">複曲線(右)</button>
        </div>
        <div class="button-group">
            <button id="addRightOuterCurve">右外側</button>
            <button id="addLeftOuterCurve">左外側</button>
        </div>


         <div class="button-group">
            <button id="addUTurnRailU">Uターン(U)</button>
            <button id="addUTurnRailV">Uターン(V)</button>
            <button id="addDoubleTrackCrossover">複線渡り(表)</button>
            <button id="addDoubleTrackCrossoverRev">複線渡り(裏)</button>
        </div>
          <div class="button-group">
            <button id="addDoubleTrackTurnoutLeft">複T.O.(左)</button>
            <button id="addDoubleTrackTurnoutLeftRev">(左裏)</button>
            <button id="addDoubleTrackTurnoutRight">(右)</button>
            <button id="addDoubleTrackTurnoutRightRev">(右裏)</button>
        </div>         

        



        <div class="button-group">
            <button id="addR13PointBRight">単複P (B右)</button>
            <button id="addR13PointBLeft">(B左)</button>
            <button id="addR13PointARight">(A右)</button>
            <button id="addR13PointALeft">(A左)</button>
        </div>
        
        <div class="section-title">R-22 Y字ポイント</div>
        <div class="button-group">
            <button id="addR22YPointA">R-22 (A)</button>
            <button id="addR22YPointARev">(A裏)</button>
            <button id="addR22YPointB">(B)</button>
            <button id="addR22YPointBRev">(B裏)</button>
        </div>
        
        <div class="section-title">R-15複線幅広ポイント</div>
        <div class="button-group">
            <button id="addR15WideA">R-15 (A)</button>
            <button id="addR15WideARev">(A裏)</button>
            <button id="addR15WideB">(B)</button>
            <button id="addR15WideBRev">(B裏)</button>
        </div>
        
        <div class="section-title">S字レール</div>
        <div class="button-group">
            <button id="addSlide">S字</button>
            <button id="addRSlide">S字(R)</button>
        </div>

        <div class="section-title">一括追加 (S/R/L)</div>
        <div class="button-group">
            <input type="text" id="railInput" placeholder="例: SSRLLS">
            <button id="addRails">追加</button>
        </div>

        <div class="section-title">表示操作</div>
        <div class="button-group">
            <button id="canvasreset">表示リセット</button>
            <button id="allclear">全クリア</button>
        </div>

        <div class="section-title">レイアウト保存/読込</div>
        
        <!-- テキスト保存 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">テキスト形式:</label>
            <textarea id="layoutData" placeholder="レイアウトデータ" style="height: 60px;"></textarea>
            <div class="button-group">
                <button id="saveLayout">テキスト生成</button>
                <button id="loadLayout">テキスト読込</button>
            </div>
        </div>
        
        <!-- LocalStorage保存 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">スロット保存:</label>
            <div class="button-group" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px;">
                <button id="saveSlot1" class="slot-btn" title="スロット1に保存">保存1</button>
                <button id="saveSlot2" class="slot-btn" title="スロット2に保存">保存2</button>
                <button id="saveSlot3" class="slot-btn" title="スロット3に保存">保存3</button>
                <button id="saveSlot4" class="slot-btn" title="スロット4に保存">保存4</button>
                <button id="saveSlot5" class="slot-btn" title="スロット5に保存">保存5</button>
            </div>
            <div class="button-group" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 5px;">
                <button id="loadSlot1" class="slot-btn" title="スロット1から読込">読込1</button>
                <button id="loadSlot2" class="slot-btn" title="スロット2から読込">読込2</button>
                <button id="loadSlot3" class="slot-btn" title="スロット3から読込">読込3</button>
                <button id="loadSlot4" class="slot-btn" title="スロット4から読込">読込4</button>
                <button id="loadSlot5" class="slot-btn" title="スロット5から読込">読込5</button>
            </div>
        </div>
        
        <!-- URL共有 -->
        <div style="margin-bottom: 10px;">
            <label style="font-size: 12px; color: #666;">URL共有:</label>
            <div class="button-group">
                <button id="copyURL">URLコピー</button>
                <button id="shareTwitter">X(Twitter)で共有</button>
            </div>
            <div id="urlStatus" style="font-size: 11px; color: #666; margin-top: 5px; min-height: 16px;"></div>
        </div>
    </div>

    <div id="contextMenu" class="context-menu">
        <div id="rotateRight">右回転 (45°)</div>
        <div id="rotateLeft">左回転 (45°)</div>
        <div id="toggleType">タイプ切替 (R/L, A/B)</div>
        <div id="toggleDirection">方向反転 (裏/表)</div>
        <div id="toggleEndpoints">端点切替</div>
        <div id="duplicate">複製</div>
        <div id="delete">削除</div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
	let canvH = canvas.height;
	let canvW = canvas.width;
	const rails =[];
        let dragging = null;
        let offsetX, offsetY;
        let selectedShape = null;
	let LastselectedShape = null;

let scale = 1;
const scaleFactor = 1.1;

    let canvasOffsetX = canvW/2;
    let canvasOffsetY = canvH/2;
    let isPanning = false;
    let startX, startY;

        // ========================================
        // レスポンシブキャンバスサイズ調整
        // ========================================
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // キャンバスの内部解像度は固定 (800x600)
            // 表示サイズのみCSSで調整
            const aspectRatio = 800 / 600; // 4:3
            
            let displayWidth = containerWidth;
            let displayHeight = displayWidth / aspectRatio;
            
            // コンテナの高さに収まらない場合は高さ基準
            if (displayHeight > containerHeight) {
                displayHeight = containerHeight;
                displayWidth = displayHeight * aspectRatio;
            }
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            drawAll();
        }
        
        // 初回とリサイズ時にキャンバスサイズを調整
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);


        const DIRECTION_LEFT = 'left';
        const DIRECTION_RIGHT = 'right';
        const RAIL_LENGTH = 80;
        const RAIL_WIDTH = 14;
        const D_TRACK_WIDTH = 22;

        // ========================================
        // レール色の定義
        // ========================================
        // 直線レール(StraightRail): 'deepskyblue' (水色)
        // カーブレール(Curve): 'pink' (ピンク)
        // 外カーブレール: 'purple' (紫)
        // S字レール(Slide): 'pink' (ピンク)
        // ターンアウト(TurnoutRail): 'lawngreen' (黄緑)
        // R-13ポイント(R13PointRail): 'orange' (オレンジ)
        // 8の字ポイント(Figure8PointRail): 'plum' (梅色)
        // Uターンレール(UturnRail): 'red' (赤)
        // ========================================

        // ========================================
        // 統一座標変換関数
        // ========================================
        
        /**
         * スクリーン座標（canvas上のピクセル座標）をワールド座標に変換
         * @param {number} screenX - canvas上のX座標 (e.offsetX)
         * @param {number} screenY - canvas上のY座標 (e.offsetY)
         * @returns {{x: number, y: number}} ワールド座標
         */
        /**
         * スクリーン座標（canvas上のピクセル座標）をワールド座標に変換
         * @param {number} screenX - canvas上のX座標 (e.offsetX)
         * @param {number} screenY - canvas上のY座標 (e.offsetY)
         * @returns {{x: number, y: number}} ワールド座標
         */
        function screenToWorld(screenX, screenY) {
            // キャンバスの表示サイズと内部解像度の比率を計算
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // 表示座標を内部座標に変換
            const canvasX = screenX * scaleX;
            const canvasY = screenY * scaleY;
            
            // スクリーン座標系: 左上が原点、Y軸下向き
            // ワールド座標系: 中央が原点、Y軸上向き
            const worldX = (canvasX - canvasOffsetX) / scale;
            const worldY = (canvH - canvasY - canvasOffsetY) / scale;
            return { x: worldX, y: worldY };
        }

        /**
         * ワールド座標をスクリーン座標に変換（将来の拡張用）
         * @param {number} worldX - ワールドX座標
         * @param {number} worldY - ワールドY座標
         * @returns {{x: number, y: number}} スクリーン座標
         */
        function worldToScreen(worldX, worldY) {
            const screenX = worldX * scale + canvasOffsetX;
            const screenY = canvH - (worldY * scale + canvasOffsetY);
            return { x: screenX, y: screenY };
        } 
		//(x,y)をangle(rad)回転させた座標
		function rotatePoint(x, y, angle){
			const SinA = Math.sin(angle);
			const CosA = Math.cos(angle);
			const x1 = x * CosA - y * SinA; 
			const y1 = x * SinA + y * CosA; 
		return { x: x1, y: y1 };
		}
// 角度を -π から π の範囲に正規化する関数
		function normalizeAngle(angle) {
			while (angle > Math.PI) angle -= 2 * Math.PI;
			while (angle < -Math.PI) angle += 2 * Math.PI;
		return angle;
		}

		function normalizedegAngle(deg) {
			let a = deg % 360;
			if (a > 180) a -= 360;
			if (a <= -180) a += 360;
		return a;
		}
		
		function reversedegAngle(deg) {
		return normalizedegAngle(deg + 180);
		}
		function rotatedegAngle(deg, delta) {
		return normalizedegAngle(deg + delta);
		}


        class StraightRail {
            constructor(x, y, id, length = RAIL_LENGTH, options = {}) {
                this.x = x;
                this.y = y;
                this.width = RAIL_WIDTH;
                this.height = length;
                this.id = id;
                this.angle = 0;
		this.color = 'deepskyblue';
         	this.endpointIdCounter = 0;
                
                // 端点タイプ（デフォルトは凹凸）
                this.startType = options.startType || 'concave';
                this.endType = options.endType || 'convex';
           }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
                ctx.fillStyle = this.color;




                ctx.fillRect(-this.width / 2, 0, this.width, this.height);
               // ctx.fillStyle = 'white';
               // ctx.fillText(this.id, -this.width , this.height / 2 );
                ctx.restore();
            }

            contains(mx, my) {
 

        const scaledX = (mx ) ;
        const scaledY = (my ) ;

               const angleRad = -this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const localX = cos * (scaledX - this.x) - sin * (scaledY - this.y) + this.x;
                const localY = sin * (scaledX - this.x) + cos * (scaledY - this.y) + this.y;
                return (localX >= this.x - this.width / 2 && localX <= this.x + this.width / 2 &&
                        localY >= this.y  && localY <= this.y + this.height);
            }

            getEndpoints() {
                const angleRad = this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const x1 = this.x;
                const y1 = this.y;
                const x2 = this.x - (this.height) * sin;
                const y2 = this.y + (this.height) * cos;
                
                // 端点の角度調整
                // 通常（起点:凹、終点:凸）: そのまま
                // 起点が凸の場合のみ: 起点の角度を180度反転
                // 終点が凹の場合のみ: 終点の角度を180度反転
                const angle1 = this.startType === 'convex' ? reversedegAngle(this.angle) : this.angle;
                const angle2 = this.endType === 'concave' ? reversedegAngle(this.angle) : this.angle;
                
                return [
            	   { x: x1, y: y1, angle: angle1, id: `${this.id}-1`, type: this.startType },
            	   { x: x2, y: y2, angle: angle2, id: `${this.id}-2`, type: this.endType }
		];
            }
        }


        class Slide {
            constructor(x, y, id, slide, length = RAIL_LENGTH) {
                this.x = x;
                this.y = y;
                this.width = RAIL_WIDTH;
                this.height = length;  // heightとして保存（StraightRailと統一）
                this.length = length;  // 後方互換性のため残す
                this.id = id;
                this.angle = 0;
				this.color = 'pink';
                this.slide = slide;
           }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle * Math.PI / 180);
                ctx.fillStyle = 'deepskyblue';
      		ctx.strokeStyle =this.color;

	        ctx.lineWidth = this.width;


		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.bezierCurveTo(0, this.length * 0.5   , this.slide ,this.length * 0.5, this.slide, this.length);
		ctx.stroke();


                //ctx.fillStyle = 'white';
                //ctx.fillText(this.id, -this.width / 4, this.length / 2 );
                ctx.restore();
            }

            contains(mx, my) {
                const angleRad = -this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const localY = sin * (mx - this.x) + cos * (my - this.y) + this.y;
                const localX = cos * (mx - this.x) - sin * (my - this.y) + this.x - (localY- this.y)/this.length * this.slide ;



                return (localX >= this.x - this.width / 2 && localX <= this.x + this.width / 2 &&
                        localY >= this.y  && localY <= this.y + this.length);
            }

            getEndpoints() {
                const angleRad = this.angle * Math.PI / 180;
                const cos = Math.cos(angleRad);
                const sin = Math.sin(angleRad);
                const x1 = this.x;
                const y1 = this.y;
                const x2 = this.x - (this.length) * sin + this.slide * cos ;
                const y2 = this.y + (this.length) * cos + this.slide * sin ; 
                return [
            	   { x: x1, y: y1, angle: this.angle, id: `${this.id}-1`, type: 'concave' },
            	   { x: x2, y: y2, angle: this.angle, id: `${this.id}-2`, type: 'convex' }
		];
            }
        }




class Curve {
    constructor(x, y, id, direction = DIRECTION_LEFT, radius = RAIL_LENGTH) {
        this.x = x;
        this.y = y;
        this.width = RAIL_WIDTH;
        this.radius = radius;
        this.id = id;
        this.angle = 0;
		this.color =  'pink';
        this.direction = direction; // 'left' or 'right'
		this.turnAngle = 45;
    }

     draw() {
		const turnRad = this.turnAngle/180 * Math.PI;
	 
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle * Math.PI / 180);

        ctx.strokeStyle = this.color;

        ctx.lineWidth = this.width;
        ctx.beginPath();
        if (this.direction === DIRECTION_LEFT) {
            ctx.arc(-this.radius, 0, this.radius, 0, turnRad);
        } else if (this.direction === DIRECTION_RIGHT) {
            ctx.arc(this.radius, 0, this.radius, Math.PI -turnRad, Math.PI);
        } else {
            throw new Error(`Invalid direction: ${this.direction}`);
        }
        ctx.stroke();
        ctx.restore();
    }

    contains(mx, my) {
        const angleRad = this.angle * Math.PI / 180;
		const turnRad = this.turnAngle/180 * Math.PI;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);

        const x1 = this.direction === DIRECTION_LEFT 
		? this.x - this.radius * cos
		: this.x + this.radius * cos;
        const y1 = this.direction === DIRECTION_LEFT 
		? this.y - this.radius * sin 
		: this.y + this.radius * sin;

        const dx = mx - x1;
        const dy = my - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let angle = Math.atan2(dy, dx) - this.angle * Math.PI / 180;
        angle = normalizeAngle(angle);

        // 左カーブ: 0 → turnRad
        // turnRad > πの場合、normalizeAngle後は一部が負の値になる
        // 例: 270度 = 3π/2 → 正規化後 0~π と -π~-π/2 の範囲
        let withinArc;
        if (this.direction === DIRECTION_LEFT) {
            if (turnRad <= Math.PI) {
                // 180度以下: 通常通り
                withinArc = (angle >= 0 && angle <= turnRad);
            } else {
                // 180度超: 0~π または -(2π-turnRad)~0 の範囲
                const negativeEnd = turnRad - Math.PI * 2;
                withinArc = (angle >= 0 && angle <= Math.PI) || (angle <= negativeEnd && angle > -Math.PI);
            }
        } else {
                withinArc = (angle >= (Math.PI - turnRad) && angle <= Math.PI);
        }
        
        return distance >= this.radius - this.width / 2 && 
               distance <= this.radius + this.width / 2 && 
               withinArc;
    }


    getEndpoints() {
        const angleRad = this.angle * Math.PI / 180;
		const turnRad = this.turnAngle/180 * Math.PI;
		
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        const x1 = this.x ;
        const y1 = this.y ;
        const x2 = this.direction === DIRECTION_LEFT ? this.x  - this.radius * cos + this.radius * Math.cos(angleRad + turnRad) : this.x  + this.radius * cos + this.radius * Math.cos(angleRad + Math.PI-turnRad);
        const y2 = this.direction === DIRECTION_LEFT ? this.y  - this.radius * sin + this.radius * Math.sin(angleRad + turnRad) : this.y  + this.radius * sin + this.radius * Math.sin(angleRad + Math.PI-turnRad);
        return [
            { x: x1, y: y1, angle:  this.angle  , id: `${this.id}-1`, type: 'concave' },
            { x: x2, y: y2, angle: this.direction === DIRECTION_LEFT ? this.angle + this.turnAngle : this.angle -this.turnAngle, id: `${this.id}-2`, type: 'convex' }
        ];
    }
}



class TurnoutRail {
    constructor(x, y, id, turnoutType = 'R', direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.turnoutType = turnoutType;   // 'R' or 'L'
        this.direction = direction;       // 'left' or 'right'
        this.components = [];
        this.color = 'lawngreen';  // ターンアウト専用の色
        
        // 端点構造の説明（実在製品に準拠）:
        // R型: 起点(凹) → 直線終点(凸) + 曲線終点(凸)
        //      起点から直線と曲線が分岐。両方とも接続元
        // L型: 起点(凹) → 直線終点(凸) → 曲線終点(凹)
        //      直線終点から180度反転した曲線。直線は凸、曲線は凹
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;

        const base = this.angle;
        const dir = this.direction;

        /* ===== R型：起点共有・直線と曲線が分岐 ===== */
        if (this.turnoutType === 'R') {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;

            // 曲線部（起点共有）
            const curve = new Curve(this.x, this.y, this.id + '-C', dir);
            curve.angle = base;
            curve.color = this.color;

            this.components.push(straight, curve);
        }

        /* ===== L型：直線終点から180度反転した曲線 ===== */
        else {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;

            // 曲線部（直線終点から180度反転）
            const straightEp = straight.getEndpoints()[1];
            const curve = new Curve(straightEp.x, straightEp.y, this.id + '-C', dir);
            curve.angle = reversedegAngle(straightEp.angle);
            curve.color = this.color;

            this.components.push(straight, curve);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // R型の場合：起点共有・直線と曲線が分岐
        if (this.turnoutType === 'R') {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 曲線終点（凸）
            eps.push({
                ...this.components[1].getEndpoints()[1],
                id: this.id + '-3',
                type: 'convex'
            });
        }
        // L型の場合：直線終点から180度反転した曲線
        else {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 曲線終点（凹）- L型は曲線が凹（接続を受ける側）
            const curveEp = this.components[1].getEndpoints()[1];
            eps.push({
                x: curveEp.x,
                y: curveEp.y,
                angle: reversedegAngle(curveEp.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        }

        return eps;
    }
}

class R13PointRail {
    constructor(x, y, id, pointType = 'B', direction = 'right') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'B' or 'A'
        this.direction = direction;   // 'right' or 'left' (スライドの方向)
        this.components = [];
        this.color = 'orange';  // R-13ポイント専用の色
        
        // 端点構造の説明（R-13単線・複線ポイント）:
        // Bタイプ: 起点(凹) → 直線終点(凸) + スライド終点(凸)
        //          起点から直線とスライドが分岐。両方とも接続元
        // Aタイプ: 起点(凹) → 直線終点(凸) → スライド終点(凹)
        //          直線終点から180度反転したスライド。直線は凸、スライドは凹
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;

        const base = this.angle;
        const slideAmount = this.direction === 'right' ? D_TRACK_WIDTH : -D_TRACK_WIDTH;

        /* ===== Bタイプ：起点共有・直線とスライドが分岐 ===== */
        if (this.pointType === 'B') {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;

            // スライド部（起点共有）
            const slide = new Slide(this.x, this.y, this.id + '-SL', slideAmount);
            slide.angle = base;
            slide.color = this.color;

            this.components.push(straight, slide);
        }

        /* ===== Aタイプ：直線終点から180度反転したスライド ===== */
        else {
            // 直線部
            const straight = new StraightRail(this.x, this.y, this.id + '-S');
            straight.angle = base;
            straight.color = this.color;

            // スライド部（直線終点から180度反転）
            const straightEp = straight.getEndpoints()[1];
            const slide = new Slide(straightEp.x, straightEp.y, this.id + '-SL', slideAmount);
            slide.angle = reversedegAngle(straightEp.angle);
            slide.color = this.color;

            this.components.push(straight, slide);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // Bタイプの場合：起点共有・直線とスライドが分岐
        if (this.pointType === 'B') {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // スライド終点（凸）
            eps.push({
                ...this.components[1].getEndpoints()[1],
                id: this.id + '-3',
                type: 'convex'
            });
        }
        // Aタイプの場合：直線終点から180度反転したスライド
        else {
            // 直線終点（凸）
            eps.push({
                ...this.components[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // スライド終点（凹）- Aタイプはスライドが凹（接続を受ける側）
            const slideEp = this.components[1].getEndpoints()[1];
            eps.push({
                x: slideEp.x,
                y: slideEp.y,
                angle: reversedegAngle(slideEp.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        }

        return eps;
    }
}

class R22YPointRail {
    constructor(x, y, id, pointType = 'A', isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'A' or 'B'
        this.isReversed = isReversed; // 裏タイプ
        this.slides = [];
        this.color = 'yellowgreen';  // R-22 Y字ポイント専用の色
        
        // 端点構造の説明（R-22 Y字ポイント）:
        // Aタイプ: 起点(凹) → 1本目(右20スライド)終点(凸) → 2本目(左20スライド)終点(凸)
        //          1本目の終点から反転して2本目が分岐
        // Bタイプ: 起点(凹) → 1本目(左20スライド)終点(凸) + 2本目(右20スライド)終点(凹)
        //          起点共有、左右に分岐（8の字に類似）
        // 裏タイプ: 左右反転
    }

    /* =========================
       内部構築
    ========================= */
    _buildSlides() {
        this.slides.length = 0;
        const base = this.angle;

        /* ===== Aタイプ：1本目終点から2本目が反転 ===== */
        if (this.pointType === 'A') {
            const direction = this.isReversed ? -1 : 1;
            
            // 1本目: 右に20スライド (or 左に20)
            const slide1 = new Slide(this.x, this.y, this.id + '-A', 20 * direction);
            slide1.angle = base;
            slide1.color = this.color;

            // 2本目: 1本目の終点から反転して左に20スライド (or 右に20)
            const ep1 = slide1.getEndpoints()[1];
            const slide2 = new Slide(ep1.x, ep1.y, this.id + '-B', -20 * direction);
            slide2.angle = reversedegAngle(ep1.angle);
            slide2.color = this.color;

            this.slides.push(slide1, slide2);
        }

        /* ===== Bタイプ：起点共有、左右に分岐 ===== */
        else {
            const direction = this.isReversed ? 1 : -1;
            
            // 1本目: 左に20スライド (or 右に20)
            const slide1 = new Slide(this.x, this.y, this.id + '-A', 20 * direction);
            slide1.angle = base;
            slide1.color = this.color;

            // 2本目: 起点共有、右に20スライド (or 左に20)
            const slide2 = new Slide(this.x, this.y, this.id + '-B', -20 * direction);
            slide2.angle = base;
            slide2.color = this.color;

            this.slides.push(slide1, slide2);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildSlides();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.slides.forEach(s => s.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.slides.some(s => s.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // Aタイプの場合：1本目終点から2本目が反転
        if (this.pointType === 'A') {
            // 1本目終点（凸）
            const ep1 = this.slides[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凸）
            const ep2 = this.slides[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: ep2.angle,
                id: this.id + '-3',
                type: 'convex'
            });
        }
        // Bタイプの場合：起点共有、左右に分岐
        else {
            // 1本目終点（凸）
            const ep1 = this.slides[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凹）- Bタイプは凹（接続を受ける側）
            const ep2 = this.slides[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: reversedegAngle(ep2.angle),
                id: this.id + '-3',
                type: 'concave'
            });
        }

        return eps;
    }
}

class R15WidePointRail {
    constructor(x, y, id, pointType = 'A', isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'A' or 'B'
        this.isReversed = isReversed; // 裏タイプ
        this.components = [];
        this.color = 'mediumseagreen';  // R-15複線幅広ポイント専用の色
        
        // 端点構造の説明（R-15複線幅広ポイント）:
        // Aタイプ: 起点(凹) → 1本目S字(右40)終点(凸) + 2本目直線終点(凹) + 3本目S字(右18)終点(1本目と共通)
        // Bタイプ: 起点(凹) → 1本目S字(左40)終点(凸) + 2本目S字(左18)終点(凸) + 3本目直線(起点凸)終点(凸)
        // 裏タイプ: 左右反転
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;

        /* ===== Aタイプ ===== */
        if (this.pointType === 'A') {
            const direction = this.isReversed ? -1 : 1;
            
            // 1本目: S字(右40 or 左40) 長さ100
            const slide1 = new Slide(this.x, this.y, this.id + '-1', 40 * direction, 100);
            slide1.angle = base;
            slide1.color = this.color;
            
            // 2本目: 直線 長さ100
            const straight = new StraightRail(this.x, this.y, this.id + '-2', 100);
            straight.angle = base;
            straight.color = this.color;
            
            // 3本目: 起点から右22(or左22)の位置、S字(右18 or 左18) 長さ100
            const offsetX = 22 * direction * Math.sin(angleRad + Math.PI * 0.5);
            const offsetY = -22 * direction * Math.cos(angleRad + Math.PI * 0.5);
            const slide3 = new Slide(this.x + offsetX, this.y + offsetY, this.id + '-3', 18 * direction, 100);
            slide3.angle = base;
            slide3.color = this.color;
            
            this.components.push(slide1, straight, slide3);
        }
        
        /* ===== Bタイプ ===== */
        else {
            const direction = this.isReversed ? 1 : -1;  // Bタイプは左が基本
            
            // 1本目: S字(左40 or 右40) 長さ100
            const slide1 = new Slide(this.x, this.y, this.id + '-1', 40 * direction, 100);
            slide1.angle = base;
            slide1.color = this.color;
            
            // 2本目: S字(左18 or 右18) 長さ100
            const slide2 = new Slide(this.x, this.y, this.id + '-2', 18 * direction, 100);
            slide2.angle = base;
            slide2.color = this.color;
            
            // 3本目: 起点から左40(or右40)の位置から直線 長さ100
            const offsetX = 40 * direction * Math.sin(angleRad + Math.PI * 0.5);
            const offsetY = -40 * direction * Math.cos(angleRad + Math.PI * 0.5);
            const straight = new StraightRail(this.x + offsetX, this.y + offsetY, this.id + '-3', 100);
            straight.angle = base;
            straight.color = this.color;
            // 3本目の起点は凸
            straight.startType = 'convex';
            straight.endType = 'convex';
            
            this.components.push(slide1, slide2, straight);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        /* ===== Aタイプ ===== */
        if (this.pointType === 'A') {
            // 起点（凹）- 1本目と2本目と3本目の共通起点
            eps.push({
                x: this.x,
                y: this.y,
                angle: this.angle,
                id: this.id + '-1',
                type: 'concave'
            });
            
            // 1本目終点（凸）- 次レール接続点
            const ep1 = this.components[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });
            
            // 2本目終点（凹）
            const ep2 = this.components[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: reversedegAngle(ep2.angle),
                id: this.id + '-3',
                type: 'concave'
            });
            
            // 3本目起点（凹）
            const ep3start = this.components[2].getEndpoints()[0];
            eps.push({
                x: ep3start.x,
                y: ep3start.y,
                angle: ep3start.angle,
                id: this.id + '-4',
                type: 'concave'
            });
            
            // 注: 3本目終点は1本目終点と共通なので追加しない
        }
        
        /* ===== Bタイプ ===== */
        else {
            // 起点（凹）- 1本目と2本目の共通起点
            eps.push({
                x: this.x,
                y: this.y,
                angle: this.angle,
                id: this.id + '-1',
                type: 'concave'
            });
            
            // 1本目終点（凸）- 次レール接続点
            const ep1 = this.components[0].getEndpoints()[1];
            eps.push({
                x: ep1.x,
                y: ep1.y,
                angle: ep1.angle,
                id: this.id + '-2',
                type: 'convex'
            });
            
            // 2本目終点（凸）
            const ep2 = this.components[1].getEndpoints()[1];
            eps.push({
                x: ep2.x,
                y: ep2.y,
                angle: ep2.angle,
                id: this.id + '-3',
                type: 'convex'
            });
            
            // 3本目起点（凸）
            const ep3start = this.components[2].getEndpoints()[0];
            eps.push({
                x: ep3start.x,
                y: ep3start.y,
                angle: reversedegAngle(ep3start.angle),
                id: this.id + '-4',
                type: 'convex'
            });
            
            // 3本目終点（凸）
            const ep3end = this.components[2].getEndpoints()[1];
            eps.push({
                x: ep3end.x,
                y: ep3end.y,
                angle: ep3end.angle,
                id: this.id + '-5',
                type: 'convex'
            });
        }

        return eps;
    }
}

class CrossPointRail {
    constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.components = [];
        this.color = 'coral';  // 十字ポイント専用の色
        
        // 端点構造の説明（十字ポイント・実際の仕様）:
        // 1本目: 横方向直線 起点(凹) → 終点(凸)
        // 2本目: 縦方向直線 起点(左・凸) → 終点(右・凹)、中央で交差
        // カーブ1: 1本目起点 → 2本目終点へ90度カーブ（半径40、中心は起点から左40）
        // カーブ2: 2本目起点 → 1本目終点へ90度カーブ（半径40）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        
        // 1本目: 横方向直線（起点凹→終点凸）
        const straight1 = new StraightRail(this.x, this.y, this.id + '-1');
        straight1.angle = base;
        straight1.color = this.color;
        
        // 2本目: 縦方向直線（左→右）
        // 起点は1本目起点から左に40
		const { x: offset2X, y: offset2Y } = rotatePoint(RAIL_LENGTH/2, RAIL_LENGTH/2, angleRad);
        const straight2 = new StraightRail(this.x + offset2X, this.y + offset2Y, this.id + '-2');
        straight2.angle = base + 90;
        straight2.color = this.color;
        straight2.startType = 'convex';  // 左側は凸
        straight2.endType = 'concave';   // 右側は凹
        
        // カーブ1: 1本目起点 → 2本目終点へ（半径40、90度左カーブ）
        const curve1 = new DoubleLengthCurve(this.x, this.y, this.id + '-C1', 'left');
        curve1.angle = base;
		curve1.radius = RAIL_LENGTH/2;
		curve1.color = this.color;
        
        // カーブ2: 2本目起点 → 1本目終点へ（半径40、90度右カーブ）
        const curve2 = new DoubleLengthCurve(this.x + offset2X, this.y + offset2Y, this.id + '-C2', 'right');
        curve2.angle = base + 90 ;
		curve2.radius = RAIL_LENGTH/2;
        curve2.color = this.color;
		
        // カーブ3: 3本目起点 → 2本目終点へ（半径40、90度左カーブ）
        const curve3 = new DoubleLengthCurve(this.x, this.y, this.id + '-C3', 'right', RAIL_LENGTH/2);
        curve3.angle = base;
		curve3.radius = RAIL_LENGTH/2;
		curve3.color = this.color;
		curve3.structure = 'true';
		
		const { x: offset3X, y: offset3Y } = rotatePoint(0, RAIL_LENGTH, angleRad);
        
        // カーブ4: 4本目起点 → 1本目終点へ（半径40、90度右カーブ）
        const curve4 = new DoubleLengthCurve(this.x + offset3X, this.y + offset3Y, this.id + '-C4', 'right');
        curve4.angle = reversedegAngle(base);
		curve4.radius = RAIL_LENGTH/2;
        curve4.color = this.color;
 		curve3.structure = 'true';
       
        this.components.push(straight1, straight2, curve1, curve2,curve3,curve4);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 1本目起点（凹）
        const ep1Start = this.components[0].getEndpoints()[0];
        eps.push({
            x: ep1Start.x,
            y: ep1Start.y,
            angle: ep1Start.angle,
            id: this.id + '-1',
            type: 'concave'
        });
        
        // 1本目終点（凸）
        const ep1End = this.components[0].getEndpoints()[1];
        eps.push({
            x: ep1End.x,
            y: ep1End.y,
            angle: ep1End.angle,
            id: this.id + '-2',
            type: 'convex'
        });
        
        // 2本目起点（左・凹）
        const ep2Start = this.components[1].getEndpoints()[0];
        eps.push({
            x: ep2Start.x,
            y: ep2Start.y,
            angle: reversedegAngle(ep2Start.angle),
            id: this.id + '-3',
            type: 'concave'
        });
        
        // 2本目終点（右・凸）
        const ep2End = this.components[1].getEndpoints()[1];
        eps.push({
            x: ep2End.x,
            y: ep2End.y,
            angle: reversedegAngle(ep2End.angle),
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleTrackCrossoverRail {
    constructor(x, y, id, isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.isReversed = isReversed;  // 表裏
        this.components = [];
        this.color = 'turquoise';  // 複線渡り専用の色
        
        // 端点構造の説明（複線渡り・実際の仕様）:
        // 複線直線2本 + S字2本（交差）
        // 表: 左→右、右→左
        // 裏: 右→左、左→右（逆）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const direction = this.isReversed ? -1 : 1;
        const rev = this.isReversed ? -1 : 1;
        
        // 複線直線2本（DoubleTrackRailと同じ配置）
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH * rev, 0 , angleRad);
        const Straight1 = new StraightRail(this.x, this.y, this.id + '-fS');
        Straight1.angle = base;
        Straight1.color = this.color;
        
        const Straight2 = new StraightRail(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-sS');
        Straight2.angle = base;
        Straight2.color = this.color;
        
        // S字2本（交差）
        const Slide1 = new Slide(this.x, this.y, this.id + '-L', D_TRACK_WIDTH * direction);
        Slide1.angle = base;
        Slide1.color = this.color;
        
        
        this.components.push(Straight1, Straight2, Slide1);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点側（左）
        const leftStart = this.components[0].getEndpoints()[0];
        eps.push({
            x: leftStart.x,
            y: leftStart.y,
            angle: leftStart.angle,
            id: this.id + '-1',
            type: 'concave'
        });
 
		// 終点側（左）- 右レールの終点
        const leftEnd = this.components[1].getEndpoints()[1];
        eps.push({
            x: leftEnd.x,
            y: leftEnd.y,
            angle: leftEnd.angle,
            id: this.id + '-3',
            type: 'convex'
        });

        // 起点側（右）
        const rightStart = this.components[1].getEndpoints()[0];
        eps.push({
            x: rightStart.x,
            y: rightStart.y,
            angle: rightStart.angle,
            id: this.id + '-2',
            type: 'concave'
        });


        // 終点側（右）- 左レールの終点
        const rightEnd = this.components[0].getEndpoints()[1];
        eps.push({
            x: rightEnd.x,
            y: rightEnd.y,
            angle: rightEnd.angle,
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleTrackTurnoutRail {
    constructor(x, y, id, direction = 'right', isReversed = false) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.direction = direction;  // 'right' or 'left'
        this.isReversed = isReversed;  // 裏タイプ
        this.components = [];
        this.color = 'lightseagreen';  // 複線ターンアウト専用の色
        
        // 端点構造の説明（複線ターンアウト・実際の仕様）:
        // 複線幅の直線2本（長さ120）
        // 複曲線カーブ2本（90度、外側カーブ）を重ねる
        // ターンアウトのように4種（左右×表裏）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const dir = this.direction === 'right' ? -1 : 1;
        const rev = this.isReversed ? -1 : 1;
        const curveDir = this.isReversed ? 'right' : 'left';
        
        // 複線幅の計算（表裏で入れ替わる）
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH * rev, 0 , angleRad);
        
        // 直線2本（長さ120）
        const straight1 = new StraightRail(this.x , this.y, this.id + '-S1', 120);
        straight1.angle = base;
        straight1.color = this.color;
        
        const straight2 = new StraightRail(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-S2', 120);
        straight2.angle = base;
        straight2.color = this.color;
        
        // 複曲線カーブ2本（90度、外側カーブ使用）
        // 起点はそれぞれの直線の起点
        const outerRadius = RAIL_LENGTH + D_TRACK_WIDTH;
		let curve1, curve2;
		if(this.direction === 'left'){	
        curve1 = new DoubleLengthCurve(this.x, this.y , this.id + '-C1', curveDir);
        curve1.angle = base;
        
        curve2 = new DoubleLengthCurve(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-C2', curveDir);
        curve2.angle = base;
		curve2.radius = outerRadius
        }else{
		const {x:L_startX,y:L_startY} = straight1.getEndpoints()[1]; 
        curve1 = new DoubleLengthCurve(L_startX + track1OffsetX, L_startY + track1OffsetY , this.id + '-C1', curveDir);
        curve1.angle = reversedegAngle(base);
        
        curve2 = new DoubleLengthCurve(L_startX , L_startY, this.id + '-C2', curveDir);
        curve2.angle = curve1.angle;
		curve2.radius = outerRadius
		} 
        curve1.color = this.color;
        curve2.color = this.color;

        this.components.push(straight1, straight2, curve1, curve2);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点側（内）
        const leftStart = this.components[0].getEndpoints()[0];
        eps.push({
            x: leftStart.x,
            y: leftStart.y,
            angle: leftStart.angle,
            id: this.id + '-1',
            type: 'concave'
        });

         // 終点側（内）
        const leftEnd = this.components[0].getEndpoints()[1];
        eps.push({
            x: leftEnd.x,
            y: leftEnd.y,
            angle: leftStart.angle,
            id: this.id + '-2',
            type: 'convex'
        });

       // 起点側（外）
        const rightStart = this.components[1].getEndpoints()[0];
        eps.push({
            x: rightStart.x,
            y: rightStart.y,
            angle: rightStart.angle,
            id: this.id + '-３',
            type: 'concave'
        });


        // 終点側（右直線）
        const rightEnd = this.components[1].getEndpoints()[1];
        eps.push({
            x: rightEnd.x,
            y: rightEnd.y,
            angle: rightStart.angle,
            id: this.id + '-4',
            type: 'convex'
        });

//Lタイプの場合
		if(this.direction === 'left'){
        // 終点側（分岐カーブ内）
        const branchEnd = this.components[2].getEndpoints()[1];
        eps.push({
            x: branchEnd.x,
            y: branchEnd.y,
            angle: branchEnd.angle,
            id: this.id + '-6',
            type: 'convex'
        });
        // 終点側（分岐カーブ外）
        const branchEnd2 = this.components[3].getEndpoints()[1];
        eps.push({
            x: branchEnd2.x,
            y: branchEnd2.y,
            angle: branchEnd2.angle,
            id: this.id + '-8',
            type: 'convex'
        });
		}
	//Rタイプの場合
		else{
        // 終点側（分岐カーブ内）
        const branchEnd = this.components[2].getEndpoints()[1];
        eps.push({
            x: branchEnd.x,
            y: branchEnd.y,
            angle: reversedegAngle(branchEnd.angle),
            id: this.id + '-5',
            type: 'concave'
        });
        // 終点側（分岐カーブ外）
        const branchEnd2 = this.components[3].getEndpoints()[1];
        eps.push({
            x: branchEnd2.x,
            y: branchEnd2.y,
            angle: reversedegAngle(branchEnd2.angle),
            id: this.id + '-7',
            type: 'concave'
        });
			
		
		}
	
        return eps;
    }
}

class DoubleTrackRail {
    constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.components = [];
        this.color = 'cyan';  // 複線レール専用の色
        
        // 端点構造の説明:
        // 起点側: 2本のレール（凹×2）
        // 終点側: 2本のレール（凸×2）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        
        // 角度のラジアン変換
        const angleRad = base * Math.PI / 180;
        
        // 1本目: 基準位置の直線
        const rail1 = new StraightRail(this.x, this.y, this.id + '-1');
        rail1.angle = base;
        rail1.color = this.color;
        
        // 2本目: D_TRACK_WIDTH分、進行方向に対して右90度方向にオフセット
        // 進行方向がangleRadのとき、右90度方向（時計回りに90度）は:
        // offsetX = D_TRACK_WIDTH * sin(angleRad)
        // offsetY = -D_TRACK_WIDTH * cos(angleRad)
        const offsetX =  D_TRACK_WIDTH * Math.sin(angleRad+Math.PI*0.5);
        const offsetY = -D_TRACK_WIDTH * Math.cos(angleRad+Math.PI*0.5);
        
        const rail2 = new StraightRail(this.x + offsetX, this.y + offsetY, this.id + '-2');
        rail2.angle = base;
        rail2.color = this.color;
        
        this.components.push(rail1, rail2);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 1本目の起点（凹）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[0],
            id: this.id + '-1',
            type: 'concave'
        });
        
        // 1本目の終点（凸）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[1],
            id: this.id + '-2',
            type: 'convex'
        });

        // 2本目の起点（凹）
        eps.push({
            ...this.components[1].getEndpoints()[0],
            id: this.id + '-3',
            type: 'concave'
        });
        
        // 2本目の終点（凸）
        eps.push({
            ...this.components[1].getEndpoints()[1],
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleCurveRail {
    constructor(x, y, id, direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.direction = direction;  // 'left' or 'right'
        this.components = [];
        this.color = 'lightcyan';  // 複曲線レール専用の色
        
        // 端点構造の説明:
        // 起点側: 2本のカーブ（凹×2）
        // 終点側: 2本のカーブ（凸×2）
    }

    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;

        // 角度のラジアン変換
        const angleRad = base * Math.PI / 180;


        const dir = this.direction;
        
        // 1本目: 基準位置から通常の内側カーブ
        const innerCurve = new Curve(this.x, this.y, this.id + '-I', dir, RAIL_LENGTH);
        innerCurve.angle = base;
        innerCurve.color = this.color;
        
        // 2本目: 基準位置からオフセットした外側カーブ
        // 左カーブ: 左方向（X軸負方向）にオフセット
        // 右カーブ: 右方向（X軸正方向）にオフセット
		
        const offsetX =  D_TRACK_WIDTH * Math.sin(angleRad+Math.PI*0.5);
        const offsetY = -D_TRACK_WIDTH * Math.cos(angleRad+Math.PI*0.5);

		
		
        let outerStartX, outerStartY;
        if (dir === 'left') {
            outerStartX = this.x + offsetX;
            outerStartY = this.y + offsetY;
        } else {
            outerStartX = this.x - offsetX;
            outerStartY = this.y - offsetY;
        }
        
        // 外側カーブ（半径 + 複線幅、基準位置からオフセット）
        const outerCurve = new Curve(outerStartX, outerStartY, this.id + '-O', dir, RAIL_LENGTH + D_TRACK_WIDTH);
        outerCurve.angle = base;
        outerCurve.color = this.color;
        
        this.components.push(innerCurve, outerCurve);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.components.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 内側カーブの起点（凹）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[0],
            id: this.id + '-1',
            type: 'concave'
        });
        
        // 内側カーブの終点（凸）- 次のレールの基準点
        eps.push({
            ...this.components[0].getEndpoints()[1],
            id: this.id + '-2',
            type: 'convex'
        });

        // 外側カーブの起点（凹）
        eps.push({
            ...this.components[1].getEndpoints()[0],
            id: this.id + '-3',
            type: 'concave'
        });
        
        // 外側カーブの終点（凸）
        eps.push({
            ...this.components[1].getEndpoints()[1],
            id: this.id + '-4',
            type: 'convex'
        });

        return eps;
    }
}

class DoubleLengthCurve {
    constructor(x, y, id, direction = DIRECTION_LEFT) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
		this.radius = RAIL_LENGTH;  // 通常カーブと同じ半径
        this.direction = direction;  // 'left' or 'right'
        this.color = 'violet';  // 倍曲線専用の色
        
        // 端点構造の説明（倍曲線）:
        // 通常カーブ2本分で90度曲がる
        // 半径: RAIL_LENGTH = 80（通常カーブと同じ）
        // 角度: 90度（通常カーブの2倍）
        // 起点(凹) → 終点(凸)
    }

    /* =========================
       描画
    ========================= */
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle * Math.PI / 180);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = RAIL_WIDTH;
        ctx.beginPath();
        
        const radius = this.radius;
        
        if (this.direction === DIRECTION_LEFT) {
            ctx.arc(-radius, 0, radius, 0, Math.PI / 2);  // 0度から90度
        } else if (this.direction === DIRECTION_RIGHT) {
            ctx.arc(radius, 0, radius, Math.PI / 2, Math.PI);  // 90度から180度
        }
        ctx.stroke();
        ctx.restore();
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        const angleRad = this.angle * Math.PI / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
  //      const radius = this.radius;  // 通常カーブと同じ半径

        const x1 = this.direction === DIRECTION_LEFT ? this.x - this.radius * cos : this.x + this.radius * cos;
        const y1 = this.direction === DIRECTION_LEFT ? this.y - this.radius * sin : this.y + this.radius * sin;

        const dx = mx - x1;
        const dy = my - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let angle = Math.atan2(dy, dx) - this.angle * Math.PI / 180;
        angle = normalizeAngle(angle);

        const withinArc = this.direction === DIRECTION_LEFT ? 
            (angle >= 0 && angle <= Math.PI / 2) : 
            (angle >= Math.PI / 2 && angle <= Math.PI);
        
        return distance >= this.radius - RAIL_WIDTH / 2 && 
               distance <= this.radius + RAIL_WIDTH / 2 && 
               withinArc;
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        const angleRad = this.angle * Math.PI / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
 //       const radius = RAIL_LENGTH;  // 通常カーブと同じ半径
        
        const x1 = this.x;
        const y1 = this.y;
        
        // 90度（π/2）回転後の終点
        const x2 = this.direction === DIRECTION_LEFT ? 
            this.x - this.radius * cos + this.radius * Math.cos(angleRad + Math.PI / 2) : 
            this.x + this.radius * cos + this.radius * Math.cos(angleRad + Math.PI / 2);
        const y2 = this.direction === DIRECTION_LEFT ? 
            this.y - this.radius * sin + this.radius * Math.sin(angleRad + Math.PI / 2) : 
            this.y + this.radius * sin + this.radius * Math.sin(angleRad + Math.PI / 2);
        
        return [
            { x: x1, y: y1, angle: this.angle, id: `${this.id}-1`, type: 'concave' },
            { x: x2, y: y2, angle: this.direction === DIRECTION_LEFT ? this.angle + 90 : this.angle - 90, id: `${this.id}-2`, type: 'convex' }
        ];
    }
}

class UTurnRail {
    constructor(x, y, id, type = 'U') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.type = type;  // 'U' or 'V' (逆U)
        this.components = [];
        this.color = 'red';  // Uターンレール専用の色
        
        // 定数（元のスクリプトから）
        this.DOUBLE_TRACK_DISTANCE_RATIO = 0.278;
        this.URAIL_RADIUS_RATIO = 0.62037;
        this.URAIL_CNCT_R_RATIO = 1.02351;
        
        // 端点構造の説明（Uターンレール）:
        // U字型に180度折り返すレール
        // type='U': 通常、type='V': 逆向き
    }
    /* =========================
       内部構築
    ========================= */
    _buildComponents() {
        this.components.length = 0;
        const base = this.angle;
        const angleRad = base * Math.PI / 180;
        const rev = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const b = (this.type === 'V' || this.type === 'v') ? 0 : 1;
        const c = (this.type === 'V' || this.type === 'v') ? 1 : 0;
        const dir = (this.type === 'V' || this.type === 'v') ? 'right' : 'left';
        const dir2 = (this.type === 'V' || this.type === 'v') ? 'left' : 'right';
 
//起点からの接続レール
		const Curve1 = new Curve(this.x, this.y, this.id + '-U1', dir,RAIL_LENGTH * this.URAIL_CNCT_R_RATIO); 
			Curve1.angle = base;
			Curve1.color = this.color;

//ターン円
		const C1end = Curve1.getEndpoints()[1];
		const UturnMain = new Curve(C1end.x, C1end.y, this.id +'-U2',dir2,RAIL_LENGTH * this.URAIL_RADIUS_RATIO);
		UturnMain.angle = C1end.angle;
		UturnMain.turnAngle = 270;
		UturnMain.color = this.color;

//もう一つの接続レール
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH * rev, 0 , angleRad);
		const Curve2 = new Curve(this.x + track1OffsetX, this.y + track1OffsetY, this.id + '-U3', dir2 ,RAIL_LENGTH * this.URAIL_CNCT_R_RATIO); 
				Curve2.angle = base;
				Curve2.color = this.color;
        
//レールでないパーツ
		const UturnPart1 = new Curve(C1end.x, C1end.y, this.id +'-p1',dir,RAIL_LENGTH * this.URAIL_RADIUS_RATIO);
		UturnPart1.angle =　reversedegAngle(C1end.angle);
		UturnPart1.turnAngle = 90;
		UturnPart1.color = this.color;

        
        this.components.push(Curve1,UturnMain,Curve2,UturnPart1);
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildComponents();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        const a = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const angleRad = this.angle * Math.PI / 180;
        const deg_sin = -Math.sin(angleRad);
        const deg_cos = -Math.cos(angleRad);

        const a1 = RAIL_LENGTH * this.URAIL_CNCT_R_RATIO * 0.5;
        const b1 = RAIL_LENGTH * this.URAIL_CNCT_R_RATIO * 0.2 * a;
        const d1 = RAIL_LENGTH * a * this.DOUBLE_TRACK_DISTANCE_RATIO;
        
        ctx.save();
        
        // 塗りつぶし部分（複線の間）
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + a1 * deg_sin + b1 * deg_cos, this.y - a1 * deg_cos + b1 * deg_sin);
        ctx.lineTo(this.x + a1 * deg_sin - (b1 + d1) * deg_cos, this.y - a1 * deg_cos - (b1 + d1) * deg_sin);
        ctx.lineTo(this.x - d1 * deg_cos, this.y - d1 * deg_sin);
        ctx.closePath();
        ctx.fill();


        this._sync();
        this.components.forEach(c => c.draw());
    }
    draw2() {
        const a = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const b = (this.type === 'V' || this.type === 'v') ? 0 : 1;
        const c = (this.type === 'V' || this.type === 'v') ? 1 : 0;
        
        const angleRad = this.angle * Math.PI / 180;
        const deg_sin = Math.sin(angleRad);
        const deg_cos = Math.cos(angleRad);
        
        // Aパーツ（接続部分の円弧）
        const c1x = this.x + RAIL_LENGTH * (this.URAIL_CNCT_R_RATIO + c * this.DOUBLE_TRACK_DISTANCE_RATIO) * deg_cos;
        const c1y = this.y + RAIL_LENGTH * (this.URAIL_CNCT_R_RATIO + c * this.DOUBLE_TRACK_DISTANCE_RATIO) * deg_sin;
        const s1a = rotatedegAngle(this.angle , 180) * Math.PI / 180;
        const e1a = rotatedegAngle(this.angle , 225) * Math.PI / 180;
        
        // Bパーツ（メインのU字カーブ）
        const c2x = this.x + RAIL_LENGTH * ((this.URAIL_RADIUS_RATIO + this.URAIL_CNCT_R_RATIO) * Math.sqrt(0.5) * deg_sin - a * this.DOUBLE_TRACK_DISTANCE_RATIO / 2 * deg_cos);
        const c2y = this.y - RAIL_LENGTH * ((this.URAIL_RADIUS_RATIO + this.URAIL_CNCT_R_RATIO) * Math.sqrt(0.5) * deg_cos + a * this.DOUBLE_TRACK_DISTANCE_RATIO / 2 * deg_sin);
        const s2a = rotatedegAngle(this.angle ,- 225) * Math.PI / 180;
        const e2a = rotatedegAngle(this.angle , 45) * Math.PI / 180;
        
        // Cパーツ（もう一方の接続部分の円弧）
        const c3x = this.x - RAIL_LENGTH * (this.URAIL_CNCT_R_RATIO + b * this.DOUBLE_TRACK_DISTANCE_RATIO) * deg_cos;
        const c3y = this.y - RAIL_LENGTH * (this.URAIL_CNCT_R_RATIO + b * this.DOUBLE_TRACK_DISTANCE_RATIO) * deg_sin;
        const s3a = this.angle * Math.PI / 180;
        const e3a = rotatedegAngle(this.angle ,- 45) * Math.PI / 180;
        
        const a1 = RAIL_LENGTH * this.URAIL_CNCT_R_RATIO * 0.5;
        const b1 = RAIL_LENGTH * this.URAIL_CNCT_R_RATIO * 0.2 * a;
        const d1 = RAIL_LENGTH * a * this.DOUBLE_TRACK_DISTANCE_RATIO;
        
        ctx.save();
        
        // 塗りつぶし部分（複線の間）
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + a1 * deg_sin + b1 * deg_cos, this.y - a1 * deg_cos + b1 * deg_sin);
        ctx.lineTo(this.x + a1 * deg_sin - (b1 + d1) * deg_cos, this.y - a1 * deg_cos - (b1 + d1) * deg_sin);
        ctx.lineTo(this.x - d1 * deg_cos, this.y - d1 * deg_sin);
        ctx.closePath();
        ctx.fill();
        
        // レール描画
        ctx.strokeStyle = this.color;
        ctx.lineWidth = RAIL_WIDTH;
        
        // Bパーツ（メインカーブ）
        ctx.beginPath();
        ctx.arc(c2x, c2y, RAIL_LENGTH * this.URAIL_RADIUS_RATIO, s2a, e2a, false);
        ctx.stroke();
        
        // Aパーツ
        ctx.beginPath();
        ctx.arc(c1x, c1y, RAIL_LENGTH * this.URAIL_CNCT_R_RATIO, s1a, e1a, false);
        ctx.stroke();
        
        // Cパーツ
        ctx.beginPath();
        ctx.arc(c3x, c3y, RAIL_LENGTH * this.URAIL_CNCT_R_RATIO, e3a, s3a, false);
        ctx.stroke();
        
       
        ctx.restore();
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.components.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        const rev = (this.type === 'V' || this.type === 'v') ? -1 : 1;
        const angleRad = this.angle * Math.PI / 180;
		const { x: track1OffsetX, y: track1OffsetY } = rotatePoint(D_TRACK_WIDTH * rev, 0 , angleRad);
      
        return [
            { x: this.x, y: this.y, angle: this.angle, id: `${this.id}-1`, type: 'concave' },
            { x: this.x + track1OffsetX, y: this.y + track1OffsetY, angle: this.angle , id: `${this.id}-3`, type: 'concave' }
        ];
    }
}



    /* =========================
       endpoint
    ========================= */
 

class Figure8PointRail {
    constructor(x, y, id, pointType = 'R', direction = 'left') {
        this.x = x;
        this.y = y;
        this.id = id;
        this.angle = 0;
        this.pointType = pointType;   // 'R', 'R_REV', 'L', 'L_REV'
        this.direction = direction;   // 'left' or 'right'
        this.curves = [];
        this.color = 'plum';  // 8の字ポイント専用の色
        
        // 端点構造の説明（実在製品に合わせた定義）:
        // L型: 起点(凹) → 1本目終点(凸) + 2本目終点(凹)
        //      起点から左右に分岐。1本目は接続元、2本目は接続先
        // R型: 起点(凹) → 1本目終点(凸) → 2本目終点(凸)
        //      1本目終点から180度反転して2本目。両方とも接続元
    }

    /* =========================
       内部構築
    ========================= */
    _buildCurves() {
        this.curves.length = 0;

        const base = this.angle;
        const dir = this.direction;
		const oppDir = (dir === 'left') ? 'right' : 'left';
        const flip = (this.pointType === 'R_REV' || this.pointType === 'L_REV') ? 1 : -1;

        /* ===== L 系：起点共有・左右分岐（実在製品のL型） ===== */
        if (this.pointType === 'L' || this.pointType === 'L_REV') {

            // 左（または右）カーブ：凸
            const c1 = new Curve(this.x, this.y, this.id + '-A', dir);
            c1.angle = base ;
            c1.color = this.color;  // 8の字ポイントの色を適用

            // 反対側カーブ：凹（direction を反転）
            
            const c2 = new Curve(this.x, this.y, this.id + '-B', oppDir);
            c2.angle = base ;
            c2.color = this.color;  // 8の字ポイントの色を適用

            this.curves.push(c1, c2);
        }

        /* ===== R 系：1本目終点から折り返し（実在製品のR型） ===== */
        else {

            // 1本目：通常カーブ
            const c1 = new Curve(this.x, this.y, this.id + '-A', dir);
            c1.angle = base ;
            c1.color = this.color;  // 8の字ポイントの色を適用

            // 2本目：1本目終点から 180° 反転
            const ep = c1.getEndpoints()[1];

            const c2 = new Curve(ep.x, ep.y, this.id + '-B', dir);
            c2.angle = reversedegAngle(ep.angle) ;
            c2.color = this.color;  // 8の字ポイントの色を適用

            this.curves.push(c1, c2);
        }
    }

    /* =========================
       同期
    ========================= */
    _sync() {
        this._buildCurves();
    }

    /* =========================
       描画
    ========================= */
    draw() {
        this._sync();
        this.curves.forEach(c => c.draw());
    }

    /* =========================
       当たり判定
    ========================= */
    contains(mx, my) {
        this._sync();
        return this.curves.some(c => c.contains(mx, my));
    }

    /* =========================
       endpoint
    ========================= */
    getEndpoints() {
        this._sync();
        const eps = [];

        // 起点（凹）
        eps.push({
            x: this.x,
            y: this.y,
            angle: this.angle,
            id: this.id + '-1',
            type: 'concave'
        });

        // L型の場合：起点共有・左右分岐（実在製品のL型）
        if (this.pointType === 'L' || this.pointType === 'L_REV') {
            // 1本目終点（凸）
            eps.push({
                ...this.curves[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凹）- L型は2本目が凹（接続を受ける側）
            const ep3 = this.curves[1].getEndpoints()[1];
            eps.push({
                x: ep3.x,
                y: ep3.y,
                angle: reversedegAngle(ep3.angle),  // 凹なので角度を反転
                id: this.id + '-3',
                type: 'concave'
            });
        }
        // R型の場合：1本目終点から折り返し（実在製品のR型）
        else {
            // 1本目終点（凸）
            eps.push({
                ...this.curves[0].getEndpoints()[1],
                id: this.id + '-2',
                type: 'convex'
            });

            // 2本目終点（凸）- R型は2本目も凸
            eps.push({
                ...this.curves[1].getEndpoints()[1],
                id: this.id + '-3',
                type: 'convex'
            });
        }

        return eps;
    }
}

    function drawAll() {

	ctx.restore();ctx.save();
	ctx.setTransform(1,0,0,1,0,0);
//        ctx.clearRect(-canvasOffsetX/scale, -canvasOffsetY/scale, canvas.width/scale, canvas.height/scale);
	ctx.translate(0,canvas.height);
	ctx.translate(canvasOffsetX,- canvasOffsetY);
	//ctx.scale(1,-1);

	ctx.scale(scale,-scale);
      	
        ctx.clearRect(-canvasOffsetX/scale, -canvasOffsetY/scale, canvas.width/scale, canvas.height/scale);


       // ctx.save(); ctx.setTransform(scale, 0, 0, scale, canvasOffsetX, canvasOffsetY);
        
	//    

	rails.forEach(rect =>rect.draw());


        drawEndpoints();
        ctx.restore();
    }

        function drawEndpoints() {
            const rootPoints = [];

            // 凸端点（接続する側）- 青色（色弱者対応）
            ctx.fillStyle = 'blue';
            rails.forEach(shape => {
                shape.getEndpoints().forEach(endpoint => {
                    // typeプロパティがある場合はそれを優先、なければIDで判定
                    const isConcave = endpoint.type === 'concave' || 
                                     (!endpoint.type && (endpoint.id.slice(-1) == '1' || endpoint.id.slice(-1) == '3'));
                    const isConvex = endpoint.type === 'convex' || 
                                    (!endpoint.type && (endpoint.id.slice(-1) == '2' || endpoint.id.slice(-1) == '4'));
                    
                    if (isConvex) {
                        const pointAngleRad = endpoint.angle * Math.PI / 180;
                        ctx.beginPath();
                        ctx.arc(endpoint.x, endpoint.y, 4, pointAngleRad, pointAngleRad + Math.PI);
                        ctx.fill();
                    } else if (isConcave) {
                        rootPoints.push(endpoint);
                    }
                });
            });

            // 凹端点（受け入れる側）- オレンジ色（色弱者対応）
            ctx.fillStyle = 'orange';
            rootPoints.forEach(rpoint => {
                const pointAngleRad = rpoint.angle * Math.PI / 180;
                ctx.beginPath();
                ctx.arc(rpoint.x, rpoint.y, 4, pointAngleRad + Math.PI, pointAngleRad + 2 * Math.PI);
                ctx.fill();
            });

        }

function snapToClosestEndpoint(shape) {
    const endpoints = shape.getEndpoints();
    let closestEndpoint = null;
    let closestDistance = Infinity;

    rails.forEach(otherShape => {
        if (otherShape !== shape) {
            otherShape.getEndpoints().forEach(endpoint => {
                endpoints.forEach(shapeEndpoint => {
                    const dx = shapeEndpoint.x - endpoint.x;
                    const dy = shapeEndpoint.y - endpoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestEndpoint = { shape: otherShape, endpoint, shapeEndpoint };
                    }
                });
            });
        }
    });

    if (closestDistance < 20) { // スナップ距離の閾値
        const angleDiff = closestEndpoint.endpoint.angle - closestEndpoint.shapeEndpoint.angle;
        shape.angle += angleDiff;

        // 再度端点を計算
        const newEndpoints = shape.getEndpoints();
        const newEndpoint = newEndpoints.find(ep => ep.id === closestEndpoint.shapeEndpoint.id);

        const dx = closestEndpoint.endpoint.x - newEndpoint.x;
        const dy = closestEndpoint.endpoint.y - newEndpoint.y;
        shape.x += dx;
        shape.y += dy;
    }
}
    canvas.addEventListener('mousedown', (e) => {
      //  console.log('Screen: x=' + e.offsetX + ', y=' + e.offsetY);
        const world = screenToWorld(e.offsetX, e.offsetY);
     //   console.log('World: x=' + world.x.toFixed(2) + ', y=' + world.y.toFixed(2));
        
        dragging = null;
        selectedShape = null;

        rails.forEach(rect => {
            if (rect.contains(world.x, world.y)) {
                dragging = rect;
                selectedShape = rect;
                offsetX = world.x - rect.x;
                offsetY = world.y - rect.y;
            }
        });

        if (!dragging) {
            isPanning = true;
            startX = e.offsetX;
            startY = e.offsetY;
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (dragging) {
            const world = screenToWorld(e.offsetX, e.offsetY);
            dragging.x = world.x - offsetX;
            dragging.y = world.y - offsetY;
            drawAll();
        } else if (isPanning) {
            const dx = e.offsetX - startX;
            const dy = e.offsetY - startY;
            canvasOffsetX += dx;
            canvasOffsetY -= dy;
            startX = e.offsetX;
            startY = e.offsetY;
            drawAll();
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (dragging) {
            snapToClosestEndpoint(dragging);
	    LastselectedShape = dragging;
            dragging = null;
        }
        isPanning = false;
        drawAll();
    });

    // ========================================
    // タッチイベントのサポート
    // ========================================
    
    function getTouchPos(canvas, touchEvent) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: touchEvent.touches[0].clientX - rect.left,
            y: touchEvent.touches[0].clientY - rect.top
        };
    }

    let lastTouchTime = 0;
    let touchStartPos = null;
    let lastTouchDistance = 0;

    canvas.addEventListener('touchstart', (e) => {
        // ピンチズーム開始（2本指）
        if (e.touches.length === 2) {
            e.preventDefault();
            isPanning = false;
            dragging = null;
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            lastTouchDistance = Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) +
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            return;
        }
        
        // 1本指タッチ
        if (e.touches.length === 1) {
            e.preventDefault();
            const touch = getTouchPos(canvas, e);
            const world = screenToWorld(touch.x, touch.y);
            
            // ダブルタップ検出
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTouchTime;
            if (tapLength < 300 && tapLength > 0) {
                // ダブルタップ: 削除
                rails.forEach((rect, index) => {
                    if (rect.contains(world.x, world.y)) {
                        rails.splice(index, 1);
                        drawAll();
                    }
                });
                lastTouchTime = 0;
                return;
            }
            lastTouchTime = currentTime;
            
            // シングルタップ: ドラッグ開始またはパン開始
            touchStartPos = {x: touch.x, y: touch.y};
            dragging = null;
            selectedShape = null;

            rails.forEach(rect => {
                if (rect.contains(world.x, world.y)) {
                    dragging = rect;
                    selectedShape = rect;
                    offsetX = world.x - rect.x;
                    offsetY = world.y - rect.y;
                }
            });

            if (!dragging) {
                isPanning = true;
                startX = touch.x;
                startY = touch.y;
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        
        // ピンチズーム（2本指）
        if (e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) +
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            
            if (lastTouchDistance > 0) {
                const delta = currentDistance - lastTouchDistance;
                if (delta > 0) {
                    scale *= 1.02;
                } else {
                    scale /= 1.02;
                }
                drawAll();
            }
            lastTouchDistance = currentDistance;
            return;
        }
        
        // 1本指ドラッグ/パン
        if (e.touches.length === 1) {
            const touch = getTouchPos(canvas, e);
            
            if (dragging) {
                const world = screenToWorld(touch.x, touch.y);
                dragging.x = world.x - offsetX;
                dragging.y = world.y - offsetY;
                drawAll();
            } else if (isPanning) {
                const dx = touch.x - startX;
                const dy = touch.y - startY;
                canvasOffsetX += dx;
                canvasOffsetY -= dy;
                startX = touch.x;
                startY = touch.y;
                drawAll();
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        
        // ピンチズーム終了
        if (e.touches.length < 2) {
            lastTouchDistance = 0;
        }
        
        // タッチ終了時の処理（1本指→0本指）
        if (e.touches.length === 0) {
            // 長押し検出（コンテキストメニュー表示）
            if (touchStartPos && selectedShape) {
                const touch = e.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const endX = touch.clientX - rect.left;
                const endY = touch.clientY - rect.top;
                const distance = Math.sqrt(
                    Math.pow(endX - touchStartPos.x, 2) + 
                    Math.pow(endY - touchStartPos.y, 2)
                );
                
                // ほとんど動いていない場合、コンテキストメニューを表示
                if (distance < 10) {
                    const menu = document.getElementById('contextMenu');
                    menu.style.left = `${touch.clientX}px`;
                    menu.style.top = `${touch.clientY}px`;
                    menu.style.display = 'block';
                }
            }
            
            if (dragging) {
                snapToClosestEndpoint(dragging);
                LastselectedShape = dragging;
                dragging = null;
            }
            isPanning = false;
            touchStartPos = null;
            drawAll();
        }
    }, {passive: false});

        canvas.addEventListener('dblclick', (e) => {
        const world = screenToWorld(e.offsetX, e.offsetY);

            rails.forEach((rect, index) => {
                if (rect.contains(world.x, world.y)) {
                    rails.splice(index, 1);
                    drawAll();
                }
            });


        });

 canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;

    if (e.deltaY < 0) {
        // ズームイン
        scale *= scaleFactor;
    } else {
        // ズームアウト
        scale /= scaleFactor;
    }

    // スケールに合わせてキャンバスを再描画
 //   ctx.setTransform(-scale, 0, 0, -scale, mouseX - scale * mouseX, mouseY - scale * mouseY);
    drawAll();
});




       canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const world = screenToWorld(e.offsetX, e.offsetY);

            selectedShape = null;
            rails.forEach(rect => {
                if (rect.contains(world.x, world.y)) {
                    selectedShape = rect;
                }
            });

            if (selectedShape) {
                const menu = document.getElementById('contextMenu');
                menu.style.left = `${e.pageX}px`;
                menu.style.top = `${e.pageY}px`;
                menu.style.display = 'block';
            }
        });

        document.getElementById('rotateRight').addEventListener('click', () => {
            if (selectedShape) {
                selectedShape.angle -= 45;
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.getElementById('rotateLeft').addEventListener('click', () => {
            if (selectedShape) {
                selectedShape.angle += 45;
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.getElementById('duplicate').addEventListener('click', () => {
            if (selectedShape) {console.log(selectedShape);
                if (selectedShape instanceof StraightRail) {
                    const newRect = new StraightRail(selectedShape.x + 100, selectedShape.y + 100, `S${rails.length + 1}`);
                    newRect.angle = selectedShape.angle;
		    rails.push(newRect);console.log(newRect);
                }else if (selectedShape instanceof Curve) {
                    const newRect = new Curve(selectedShape.x + 100, selectedShape.y + 100, `L${rails.length + 1}`);
                    newRect.angle = selectedShape.angle;
		    rails.push(newRect);console.log(newRect);
                }

                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.getElementById('delete').addEventListener('click', () => {
            if (selectedShape) {
                if (selectedShape) {
                    const index = rails.indexOf(selectedShape);
                    if (index > -1) {
                        rails.splice(index, 1);
                    }
                }
 //               console.log(rails);
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        // タイプ切替 (R/L, A/B)
        document.getElementById('toggleType').addEventListener('click', () => {
            if (selectedShape) {
                // ターンアウトのR/L切替
                if (selectedShape.turnoutType) {
                    selectedShape.turnoutType = selectedShape.turnoutType === 'R' ? 'L' : 'R';
                }
                // R-13ポイントのA/B切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'R13PointRail') {
                    selectedShape.pointType = selectedShape.pointType === 'A' ? 'B' : 'A';
                }
                // R-22 Y字ポイントのA/B切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'R22YPointRail') {
                    selectedShape.pointType = selectedShape.pointType === 'A' ? 'B' : 'A';
                }
                // R-15複線幅広ポイントのA/B切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'R15WidePointRail') {
                    selectedShape.pointType = selectedShape.pointType === 'A' ? 'B' : 'A';
                }
                // 8の字ポイントのR/L切替
                else if (selectedShape.pointType && selectedShape.constructor.name === 'Figure8PointRail') {
                    if (selectedShape.pointType === 'R') selectedShape.pointType = 'L';
                    else if (selectedShape.pointType === 'L') selectedShape.pointType = 'R';
                    else if (selectedShape.pointType === 'R_REV') selectedShape.pointType = 'L_REV';
                    else if (selectedShape.pointType === 'L_REV') selectedShape.pointType = 'R_REV';
                }
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        // 方向反転 (裏/表、左/右)
        document.getElementById('toggleDirection').addEventListener('click', () => {
            if (selectedShape) {
                if (selectedShape.direction) {
                    selectedShape.direction = selectedShape.direction === 'left' ? 'right' : 'left';
                }
                // スライドレールの方向反転
                if (selectedShape.slide !== undefined) {
                    selectedShape.slide = -selectedShape.slide;
                }
                // R-15複線幅広ポイントの裏タイプ切替
                if (selectedShape.isReversed !== undefined) {
                    selectedShape.isReversed = !selectedShape.isReversed;
                }
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        // 端点切替 (凹凸/凸凸/凹凹)
        document.getElementById('toggleEndpoints').addEventListener('click', () => {
            if (selectedShape && selectedShape.constructor.name === 'StraightRail') {
                // 現在の状態を判定
                const current = `${selectedShape.startType}-${selectedShape.endType}`;
                
                // 凹凸 → 凹凹 → 凸凸 → 凹凸 の順で切り替え
                if (current === 'concave-convex') {
                    selectedShape.startType = 'concave';
                    selectedShape.endType = 'concave';
                } else if (current === 'concave-concave') {
                    selectedShape.startType = 'convex';
                    selectedShape.endType = 'convex';
                } else {
                    selectedShape.startType = 'concave';
                    selectedShape.endType = 'convex';
                }
                drawAll();
                document.getElementById('contextMenu').style.display = 'none';
            }
        });

        document.addEventListener('click', () => {
            document.getElementById('contextMenu').style.display = 'none';
        });


// 最後に置いたレールの端点を取得する関数
function getLastEndpoint() {
    if (rails.length === 0 ) return {x: 0, y:0, angle:0};
    let endpoints;
    if (LastselectedShape == null){
    	const lastShape = rails.slice(-1)[0];//console.log(lastShape);
   	endpoints = lastShape.getEndpoints();
	}
	else {
   	endpoints = LastselectedShape.getEndpoints();
}

    return endpoints[1]; // 2つ目の端点を返す
}

// 直線を追加するボタンのイベントリスナー
document.getElementById('addStraight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id);
        rect.angle = lastEndpoint.angle;
        rails.push(rect);
       drawAll();

        LastselectedShape = rect;

    }
});

// 1/2直線を追加するボタンのイベントリスナー
document.getElementById('addHalfStraight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `H${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.5);
        rect.angle = lastEndpoint.angle;
        rect.color = 'lightblue';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// 1/4直線を追加するボタンのイベントリスナー
// 1/4直線を追加するボタンのイベントリスナー（凹凸）
document.getElementById('addQuarterStraight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `Q${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25);
        rect.angle = lastEndpoint.angle;
        rect.color = 'skyblue';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// 1/4直線を追加するボタンのイベントリスナー（凹凹）
document.getElementById('addQuarterCC').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `QCC${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25, 
            { startType: 'concave', endType: 'concave' });
        rect.angle = lastEndpoint.angle;
        rect.color = 'skyblue';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// 1/4直線を追加するボタンのイベントリスナー（凸凸）
document.getElementById('addQuarterVV').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `QVV${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 0.25, 
            { startType: 'convex', endType: 'convex' });
        rect.angle = lastEndpoint.angle;
        rect.color = 'skyblue';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// ジョイントレールを追加するボタンのイベントリスナー（凹凹）
document.getElementById('addJointCC').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `JCC${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH / 6, 
            { startType: 'concave', endType: 'concave' });
        rect.angle = lastEndpoint.angle;
        rect.color = 'lightgray';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// ジョイントレールを追加するボタンのイベントリスナー（凸凸）
document.getElementById('addJointVV').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `JVV${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH / 6, 
            { startType: 'convex', endType: 'convex' });
        rect.angle = lastEndpoint.angle;
        rect.color = 'lightgray';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// 2倍直線を追加するボタンのイベントリスナー
document.getElementById('addDoubleStraight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `D${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id, RAIL_LENGTH * 2);
        rect.angle = lastEndpoint.angle;
        rect.color = 'navy';
        rails.push(rect);
        drawAll();
        LastselectedShape = rect;
    }
});

// 右外側曲線を追加するボタンのイベントリスナー
document.getElementById('addRightOuterCurve').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `OR${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'right', RAIL_LENGTH + D_TRACK_WIDTH);
        curve.angle = (lastEndpoint.angle + 360) % 360;
        curve.color = "purple";
        rails.push(curve);
        drawAll();
        LastselectedShape = curve;
    }
});

// 左外側曲線を追加するボタンのイベントリスナー
document.getElementById('addLeftOuterCurve').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `OL${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'left', RAIL_LENGTH + D_TRACK_WIDTH);
        curve.angle = (lastEndpoint.angle + 360) % 360;
        curve.color = "purple";
        rails.push(curve);
        drawAll();
        LastselectedShape = curve;
    }
});

// スライド直線を追加するボタンのイベントリスナー
document.getElementById('addSlide').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `Sl${rails.length + 1}`;
        const rect = new Slide (lastEndpoint.x, lastEndpoint.y, id);
        rect.angle = lastEndpoint.angle;
	rect.slide = D_TRACK_WIDTH;

        rails.push(rect);
       drawAll();

        LastselectedShape = rect;

    }
});


// スライド直線を追加するボタンのイベントリスナー
document.getElementById('addRSlide').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `Sl${rails.length + 1}`;
        const rect = new Slide (lastEndpoint.x, lastEndpoint.y, id);
        rect.angle = lastEndpoint.angle;
	rect.slide = -D_TRACK_WIDTH;

        rails.push(rect);
       drawAll();

        LastselectedShape = rect;

    }
});


// 右に曲がるレールを追加するボタンのイベントリスナー
document.getElementById('addRightCurve').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'right');
        curve.angle = (lastEndpoint.angle+360)%360;
        rails.push(curve);
        drawAll();
	    LastselectedShape = curve;


    }
});

// 左に曲がるレールを追加するボタンのイベントリスナー
document.getElementById('addLeftCurve').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `L${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'left');
        curve.angle = lastEndpoint.angle;
        rails.push(curve);
        drawAll();

	    LastselectedShape = curve;


    }
});

// 倍曲線(右)を追加するボタンのイベントリスナー
document.getElementById('addDoubleLengthCurveRight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DLC_R${rails.length + 1}`;
        const curve = new DoubleLengthCurve(lastEndpoint.x, lastEndpoint.y, id, 'right');
        curve.angle = lastEndpoint.angle;
        rails.push(curve);
        LastselectedShape = curve;
        drawAll();
    }
});

// 倍曲線(左)を追加するボタンのイベントリスナー
document.getElementById('addDoubleLengthCurveLeft').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DLC_L${rails.length + 1}`;
        const curve = new DoubleLengthCurve(lastEndpoint.x, lastEndpoint.y, id, 'left');
        curve.angle = lastEndpoint.angle;
        rails.push(curve);
        LastselectedShape = curve;
        drawAll();
    }
});

// Uターンレール(U)を追加するボタンのイベントリスナー
document.getElementById('addUTurnRailU').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `UT_U${rails.length + 1}`;
        const uturn = new UTurnRail(lastEndpoint.x, lastEndpoint.y, id, 'U');
        uturn.angle = lastEndpoint.angle;
        rails.push(uturn);
        LastselectedShape = uturn;
        drawAll();
    }
});

// Uターンレール(V)を追加するボタンのイベントリスナー
document.getElementById('addUTurnRailV').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `UT_V${rails.length + 1}`;
        const uturn = new UTurnRail(lastEndpoint.x, lastEndpoint.y, id, 'V');
        uturn.angle = lastEndpoint.angle;
        rails.push(uturn);
        LastselectedShape = uturn;
        drawAll();
    }
});


// 右に曲がる外レールを追加するボタンのイベントリスナー(旧版)
// ターンアウトレールを追加するボタンのイベントリスナー
document.getElementById('addTurnoutLeft').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `TR${rails.length + 1}`;
        const turnout = new TurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'R', 'left');
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

document.getElementById('addTurnoutRight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `TR${rails.length + 1}`;
        const turnout = new TurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'R', 'right');
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

document.getElementById('addTurnoutLeftL').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `TL${rails.length + 1}`;
        const turnout = new TurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'L', 'left');
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

document.getElementById('addTurnoutRightL').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `TL${rails.length + 1}`;
        const turnout = new TurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'L', 'right');
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

// 8の字ポイントレールを追加するボタンのイベントリスナー(R)
document.getElementById('addFigure8Point').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `F8R${rails.length + 1}`;
        const figure8Point = new Figure8PointRail(lastEndpoint.x, lastEndpoint.y, id, 'R','right');
        figure8Point.angle = lastEndpoint.angle;
        rails.push(figure8Point);
        LastselectedShape = figure8Point;
        drawAll();
    }
});

// 8の字ポイントレールを追加するボタンのイベントリスナー(R反転)
document.getElementById('addFigure8PointRRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `F8RR${rails.length + 1}`;
        const figure8Point = new Figure8PointRail(lastEndpoint.x, lastEndpoint.y, id, 'R_REV','left');
        figure8Point.angle = lastEndpoint.angle;
        rails.push(figure8Point);
        LastselectedShape = figure8Point;
        drawAll();
    }
});

// 8の字ポイントレールを追加するボタンのイベントリスナー(L)
document.getElementById('addFigure8PointL').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `F8L${rails.length + 1}`;
        const figure8Point = new Figure8PointRail(lastEndpoint.x, lastEndpoint.y, id, 'L','right');
        figure8Point.angle = lastEndpoint.angle;
        rails.push(figure8Point);
        LastselectedShape = figure8Point;
        drawAll();
    }
});

// 8の字ポイントレールを追加するボタンのイベントリスナー(L反転)
document.getElementById('addFigure8PointLRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `F8LR${rails.length + 1}`;
        const figure8Point = new Figure8PointRail(lastEndpoint.x, lastEndpoint.y, id, 'L_REV','left');
        figure8Point.angle = lastEndpoint.angle;
        rails.push(figure8Point);
        LastselectedShape = figure8Point;
        drawAll();
    }
});

// R-13単線・複線ポイントレールを追加するボタンのイベントリスナー
document.getElementById('addR13PointBRight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R13BR${rails.length + 1}`;
        const r13Point = new R13PointRail(lastEndpoint.x, lastEndpoint.y, id, 'B', 'right');
        r13Point.angle = lastEndpoint.angle;
        rails.push(r13Point);
        LastselectedShape = r13Point;
        drawAll();
    }
});

document.getElementById('addR13PointBLeft').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R13BL${rails.length + 1}`;
        const r13Point = new R13PointRail(lastEndpoint.x, lastEndpoint.y, id, 'B', 'left');
        r13Point.angle = lastEndpoint.angle;
        rails.push(r13Point);
        LastselectedShape = r13Point;
        drawAll();
    }
});

document.getElementById('addR13PointARight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R13AR${rails.length + 1}`;
        const r13Point = new R13PointRail(lastEndpoint.x, lastEndpoint.y, id, 'A', 'right');
        r13Point.angle = lastEndpoint.angle;
        rails.push(r13Point);
        LastselectedShape = r13Point;
        drawAll();
    }
});

document.getElementById('addR13PointALeft').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R13AL${rails.length + 1}`;
        const r13Point = new R13PointRail(lastEndpoint.x, lastEndpoint.y, id, 'A', 'left');
        r13Point.angle = lastEndpoint.angle;
        rails.push(r13Point);
        LastselectedShape = r13Point;
        drawAll();
    }
});

// R-22 Y字ポイント(A)を追加するボタンのイベントリスナー
document.getElementById('addR22YPointA').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R22A${rails.length + 1}`;
        const r22Point = new R22YPointRail(lastEndpoint.x, lastEndpoint.y, id, 'A', false);
        r22Point.angle = lastEndpoint.angle;
        rails.push(r22Point);
        LastselectedShape = r22Point;
        drawAll();
    }
});

// R-22 Y字ポイント(A裏)を追加するボタンのイベントリスナー
document.getElementById('addR22YPointARev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R22AR${rails.length + 1}`;
        const r22Point = new R22YPointRail(lastEndpoint.x, lastEndpoint.y, id, 'A', true);
        r22Point.angle = lastEndpoint.angle;
        rails.push(r22Point);
        LastselectedShape = r22Point;
        drawAll();
    }
});

// R-22 Y字ポイント(B)を追加するボタンのイベントリスナー
document.getElementById('addR22YPointB').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R22B${rails.length + 1}`;
        const r22Point = new R22YPointRail(lastEndpoint.x, lastEndpoint.y, id, 'B', false);
        r22Point.angle = lastEndpoint.angle;
        rails.push(r22Point);
        LastselectedShape = r22Point;
        drawAll();
    }
});

// R-22 Y字ポイント(B裏)を追加するボタンのイベントリスナー
document.getElementById('addR22YPointBRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R22BR${rails.length + 1}`;
        const r22Point = new R22YPointRail(lastEndpoint.x, lastEndpoint.y, id, 'B', true);
        r22Point.angle = lastEndpoint.angle;
        rails.push(r22Point);
        LastselectedShape = r22Point;
        drawAll();
    }
});

// R-15複線幅広ポイント(A)を追加するボタンのイベントリスナー
document.getElementById('addR15WideA').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R15A${rails.length + 1}`;
        const r15Point = new R15WidePointRail(lastEndpoint.x, lastEndpoint.y, id, 'A', false);
        r15Point.angle = lastEndpoint.angle;
        rails.push(r15Point);
        LastselectedShape = r15Point;
        drawAll();
    }
});

// R-15複線幅広ポイント(A裏)を追加するボタンのイベントリスナー
document.getElementById('addR15WideARev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R15AR${rails.length + 1}`;
        const r15Point = new R15WidePointRail(lastEndpoint.x, lastEndpoint.y, id, 'A', true);
        r15Point.angle = lastEndpoint.angle;
        rails.push(r15Point);
        LastselectedShape = r15Point;
        drawAll();
    }
});

// R-15複線幅広ポイント(B)を追加するボタンのイベントリスナー
document.getElementById('addR15WideB').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R15B${rails.length + 1}`;
        const r15Point = new R15WidePointRail(lastEndpoint.x, lastEndpoint.y, id, 'B', false);
        r15Point.angle = lastEndpoint.angle;
        rails.push(r15Point);
        LastselectedShape = r15Point;
        drawAll();
    }
});

// R-15複線幅広ポイント(B裏)を追加するボタンのイベントリスナー
document.getElementById('addR15WideBRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `R15BR${rails.length + 1}`;
        const r15Point = new R15WidePointRail(lastEndpoint.x, lastEndpoint.y, id, 'B', true);
        r15Point.angle = lastEndpoint.angle;
        rails.push(r15Point);
        LastselectedShape = r15Point;
        drawAll();
    }
});

// 複線直線レールを追加するボタンのイベントリスナー
document.getElementById('addDoubleTrack').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DT${rails.length + 1}`;
        const doubleTrack = new DoubleTrackRail(lastEndpoint.x, lastEndpoint.y, id);
        doubleTrack.angle = lastEndpoint.angle;
        rails.push(doubleTrack);
        LastselectedShape = doubleTrack;
        drawAll();
    }
});

// 複曲線(左)レールを追加するボタンのイベントリスナー
document.getElementById('addDoubleCurveLeft').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DCL${rails.length + 1}`;
        const doubleCurve = new DoubleCurveRail(lastEndpoint.x, lastEndpoint.y, id, 'left');
        doubleCurve.angle = lastEndpoint.angle;
        rails.push(doubleCurve);
        LastselectedShape = doubleCurve;
        drawAll();
    }
});

// 複曲線(右)レールを追加するボタンのイベントリスナー
document.getElementById('addDoubleCurveRight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DCR${rails.length + 1}`;
        const doubleCurve = new DoubleCurveRail(lastEndpoint.x, lastEndpoint.y, id, 'right');
        doubleCurve.angle = lastEndpoint.angle;
        rails.push(doubleCurve);
        LastselectedShape = doubleCurve;
        drawAll();
    }
});

// 複線渡りを追加するボタンのイベントリスナー
document.getElementById('addDoubleTrackCrossover').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DTX${rails.length + 1}`;
        const crossover = new DoubleTrackCrossoverRail(lastEndpoint.x, lastEndpoint.y, id, false);
        crossover.angle = lastEndpoint.angle;
        rails.push(crossover);
        LastselectedShape = crossover;
        drawAll();
    }
});

// 複線渡り(裏)を追加するボタンのイベントリスナー
document.getElementById('addDoubleTrackCrossoverRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DTXR${rails.length + 1}`;
        const crossover = new DoubleTrackCrossoverRail(lastEndpoint.x, lastEndpoint.y, id, true);
        crossover.angle = lastEndpoint.angle;
        rails.push(crossover);
        LastselectedShape = crossover;
        drawAll();
    }
});

// 複線ターンアウト(左)を追加するボタンのイベントリスナー
document.getElementById('addDoubleTrackTurnoutLeft').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DTTL${rails.length + 1}`;
        const turnout = new DoubleTrackTurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'left', false);
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

// 複線ターンアウト(右)を追加するボタンのイベントリスナー
document.getElementById('addDoubleTrackTurnoutRight').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DTTR${rails.length + 1}`;
        const turnout = new DoubleTrackTurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'right', false);
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

// 複線ターンアウト(左裏)を追加するボタンのイベントリスナー
document.getElementById('addDoubleTrackTurnoutLeftRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DTTLR${rails.length + 1}`;
        const turnout = new DoubleTrackTurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'left', true);
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

// 複線ターンアウト(右裏)を追加するボタンのイベントリスナー
document.getElementById('addDoubleTrackTurnoutRightRev').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `DTTRR${rails.length + 1}`;
        const turnout = new DoubleTrackTurnoutRail(lastEndpoint.x, lastEndpoint.y, id, 'right', true);
        turnout.angle = lastEndpoint.angle;
        rails.push(turnout);
        LastselectedShape = turnout;
        drawAll();
    }
});

// 十字ポイントを追加するボタンのイベントリスナー
document.getElementById('addCrossPoint').addEventListener('click', () => {
    const lastEndpoint = getLastEndpoint();
    if (lastEndpoint) {
        const id = `CP${rails.length + 1}`;
        const crossPoint = new CrossPointRail(lastEndpoint.x, lastEndpoint.y, id);
        crossPoint.angle = lastEndpoint.angle;
        rails.push(crossPoint);
        LastselectedShape = crossPoint;
        drawAll();
    }
});







// レールを追加する関数
function addRail(type) {
    const lastEndpoint = getLastEndpoint();
    if (!lastEndpoint) return;

    if (type === 'S' || type ==='s') {
        const id = `S${rails.length + 1}`;
        const rect = new StraightRail(lastEndpoint.x, lastEndpoint.y, id);
        rect.angle = lastEndpoint.angle;
        LastselectedShape = rect;
        rails.push(rect);



    } else if (type === 'R'|| type ==='r') {
        const id = `R${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'right');
        curve.angle = (lastEndpoint.angle+360)%360;
        LastselectedShape = curve;
        rails.push(curve);


    } else if (type === 'L'|| type ==='l') {
        const id = `L${rails.length + 1}`;
        const curve = new Curve(lastEndpoint.x, lastEndpoint.y, id, 'left');
        curve.angle = lastEndpoint.angle;
        LastselectedShape = curve;
	rails.push(curve);


    }
    drawAll();
}

// 縮尺リセット　イベントリスナー
document.getElementById('canvasreset').addEventListener('click', () => {
 scale = 1;

     canvasOffsetX = canvW/2;
     canvasOffsetY = canvH/2;

drawAll();


});

// リセット　イベントリスナー
document.getElementById('allclear').addEventListener('click', () => {
 scale = 1;

     canvasOffsetX = canvW/2;
     canvasOffsetY = canvH/2;
     rails.length = 0;


drawAll();


});



// テキストボックスの入力を処理するイベントリスナー
document.getElementById('addRails').addEventListener('click', () => {
    const input = document.getElementById('railInput').value.toUpperCase();
    for (const char of input) {
        if (['S', 'R', 'L'].includes(char)) {
            addRail(char);
        }
    }
    document.getElementById('railInput').value = ''; // 入力をクリア
});


// レイアウトをコンパクトな文字列に変換
function saveLayout() {
    const data = rails.map(rail => {
        const type = rail.constructor.name;
        const parts = [
            type,
            rail.x.toFixed(1),  // 小数点1桁
            rail.y.toFixed(1),
            rail.angle.toFixed(0)  // 整数
        ];
        
        // 必要なプロパティのみ追加
        if (rail.direction) parts.push(rail.direction);
        else if (rail.slide !== undefined || rail.height || rail.radius || rail.pointType || rail.turnoutType || rail.startType || rail.endType || rail.isReversed) parts.push('');
        
        if (rail.slide !== undefined) parts.push(rail.slide.toFixed(1));
        else if (rail.height || rail.radius || rail.pointType || rail.turnoutType || rail.startType || rail.endType || rail.isReversed) parts.push('');
        
        if (rail.height) parts.push(rail.height.toFixed(1));
        else if (rail.radius || rail.pointType || rail.turnoutType || rail.startType || rail.endType || rail.isReversed) parts.push('');
        
        if (rail.radius && rail.radius !== RAIL_LENGTH) parts.push(rail.radius.toFixed(1));
        else if (rail.pointType || rail.turnoutType || rail.startType || rail.endType || rail.isReversed) parts.push('');
        
        if (rail.pointType) parts.push(rail.pointType);
        else if (rail.turnoutType || rail.startType || rail.endType || rail.isReversed) parts.push('');
        
        if (rail.turnoutType) parts.push(rail.turnoutType);
        else if (rail.startType || rail.endType || rail.isReversed) parts.push('');
        
        if (rail.startType) parts.push(rail.startType);
        else if (rail.endType || rail.isReversed) parts.push('');
        
        if (rail.endType) parts.push(rail.endType);
        else if (rail.isReversed) parts.push('');
        
        if (rail.isReversed) parts.push('1');
        
        return parts.join(',');
    }).join(';');
    
    document.getElementById('layoutData').value = data;
    return data;
}

function loadLayout() {
    const layoutData = document.getElementById('layoutData').value.trim();
    if (!layoutData) return;
    
    const items = layoutData.split(';');
    rails.length = 0;
    
    for (const item of items) {
        if (!item) continue;
        const [type, x, y, angle, direction, slide, height, radius, pointType, turnoutType, startType, endType, isReversed] = item.split(',');
        const id = `${type[0]}${rails.length + 1}`;
        let rail = null;

        if (type === 'StraightRail' || type === 'Rect') {
            const options = {};
            if (startType) options.startType = startType;
            if (endType) options.endType = endType;
            rail = new StraightRail(+x, +y, id, height ? +height : RAIL_LENGTH, options);
        } else if (type === 'Curve') {
            rail = new Curve(+x, +y, id, direction, radius ? +radius : RAIL_LENGTH);
        } else if (type === 'DoubleLengthCurve') {
            rail = new DoubleLengthCurve(+x, +y, id, direction, radius ? +radius : RAIL_LENGTH);
        } else if (type === 'UTurnRail') {
            rail = new UTurnRail(+x, +y, id, direction || 'U');
        } else if (type === 'TurnoutRail') {
            rail = new TurnoutRail(+x, +y, id, turnoutType || 'R', direction);
        } else if (type === 'R13PointRail') {
            rail = new R13PointRail(+x, +y, id, pointType || 'B', direction);
        } else if (type === 'R22YPointRail') {
            rail = new R22YPointRail(+x, +y, id, pointType || 'A', isReversed === '1');
        } else if (type === 'R15WidePointRail') {
            rail = new R15WidePointRail(+x, +y, id, pointType || 'A', isReversed === '1');
        } else if (type === 'Figure8PointRail') {
            rail = new Figure8PointRail(+x, +y, id, pointType || 'R');
        } else if (type === 'DoubleTrackRail') {
            rail = new DoubleTrackRail(+x, +y, id);
        } else if (type === 'DoubleCurveRail') {
            rail = new DoubleCurveRail(+x, +y, id, direction);
        } else if (type === 'DoubleTrackCrossoverRail') {
            rail = new DoubleTrackCrossoverRail(+x, +y, id, isReversed === '1');
        } else if (type === 'DoubleTrackTurnoutRail') {
            rail = new DoubleTrackTurnoutRail(+x, +y, id, direction, isReversed === '1');
        } else if (type === 'CrossPointRail') {
            rail = new CrossPointRail(+x, +y, id);
        } else if (type === 'Slide') {
            rail = new Slide(+x, +y, id, +slide, height ? +height : RAIL_LENGTH);
        }

        if (rail) {
            rail.angle = +angle;
            rails.push(rail);
        }
    }
    drawAll();
}

// LocalStorage保存/読込
function saveToSlot(slot) {
    const data = saveLayout();
    localStorage.setItem(`plarail_layout_slot${slot}`, data);
    showStatus(`スロット${slot}に保存しました`);
}

function loadFromSlot(slot) {
    const data = localStorage.getItem(`plarail_layout_slot${slot}`);
    if (data) {
        document.getElementById('layoutData').value = data;
        loadLayout();
        showStatus(`スロット${slot}から読み込みました`);
    } else {
        showStatus(`スロット${slot}は空です`);
    }
}

// URL共有機能
function getLayoutURL() {
    const data = saveLayout();
    const compressed = encodeURIComponent(data);
    const url = `${window.location.origin}${window.location.pathname}?layout=${compressed}`;
    return url;
}

function copyURLToClipboard() {
    const url = getLayoutURL();
    
    // クリップボードにコピー
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).then(() => {
            showStatus('URLをコピーしました！');
        }).catch(() => {
            fallbackCopyTextToClipboard(url);
        });
    } else {
        fallbackCopyTextToClipboard(url);
    }
}

function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.top = "0";
    textArea.style.left = "0";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showStatus('URLをコピーしました！');
    } catch (err) {
        showStatus('コピーに失敗しました');
    }
    
    document.body.removeChild(textArea);
}

function shareToTwitter() {
    const url = getLayoutURL();
    const text = 'プラレールレイアウトを作りました！';
    const twitterURL = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
    window.open(twitterURL, '_blank');
}

function showStatus(message) {
    const status = document.getElementById('urlStatus');
    status.textContent = message;
    setTimeout(() => {
        status.textContent = '';
    }, 3000);
}

// URLからレイアウトを読み込み
function loadFromURL() {
    const params = new URLSearchParams(window.location.search);
    const layoutData = params.get('layout');
    if (layoutData) {
        try {
            document.getElementById('layoutData').value = decodeURIComponent(layoutData);
            loadLayout();
            showStatus('URLからレイアウトを読み込みました');
        } catch (e) {
            console.error('レイアウト読み込みエラー:', e);
        }
    }
}

// イベントリスナー設定
document.getElementById('saveLayout').addEventListener('click', saveLayout);
document.getElementById('loadLayout').addEventListener('click', loadLayout);

// スロット保存/読込
for (let i = 1; i <= 5; i++) {
    document.getElementById(`saveSlot${i}`).addEventListener('click', () => saveToSlot(i));
    document.getElementById(`loadSlot${i}`).addEventListener('click', () => loadFromSlot(i));
}

// URL共有
document.getElementById('copyURL').addEventListener('click', copyURLToClipboard);
document.getElementById('shareTwitter').addEventListener('click', shareToTwitter);

// ページ読み込み時にURLからレイアウトを復元
window.addEventListener('DOMContentLoaded', loadFromURL);



        // 初期の長方形を追加
        for (let i = 0; i < 1; i++) {
            const id = `S${i + 1}`;
            const rect = new StraightRail(0 , 0, id);
	    rect.angle = 0;
            rails.push(rect);


        }

        drawAll();
    </script>
</body>

</html>